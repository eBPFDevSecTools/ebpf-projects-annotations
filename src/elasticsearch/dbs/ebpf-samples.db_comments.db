{"_default": {"1": {"capabilities": [], "helperCallParams": {}, "startLine": 24, "endLine": 32, "File": "/home/palani/github/palanik1/ebpf-projects-annotations/projects/ebpf-samples/original_source/tail_call_bad.c", "funcName": "caller", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": " Copyright (c) Prevail Verifier contributors."}, {"start_line": 2, "end_line": 2, "text": " SPDX-License-Identifier: MIT"}, {"start_line": 27, "end_line": 27, "text": " This should fail validation since the map is not a prog array."}, {"start_line": 30, "end_line": 30, "text": " bpf_tail_call failed at runtime."}], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *ctx"], "output": "int", "helper": ["bpf_tail_call"], "compatibleHookpoints": ["lwt_in", "sk_msg", "lwt_xmit", "sk_reuseport", "cgroup_sock", "xdp", "raw_tracepoint_writable", "lwt_out", "cgroup_sock_addr", "socket_filter", "sk_skb", "lwt_seg6local", "sock_ops", "tracepoint", "kprobe", "cgroup_skb", "sched_act", "perf_event", "raw_tracepoint", "flow_dissector", "sched_cls"], "source": ["int caller (struct xdp_md *ctx)\n", "{\n", "    long error = bpf_tail_call (ctx, & map, 0);\n", "    return (int) error;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}, {"description": "bpf_tail_call(ctx, &map, 0) helper function triggers a \"tail call\", i.e it jump into another eBPF program.\n                      The program attempts to jump into a program referenced at index=0 in map and passes a pointer to the context named ctx given input to the function.This program will return error because the map is of type BPF_MAP_TYPE_ARRAY. When the map is of type BPF_MAP_TYPE_PROG_ARRAY i.e a prog array, the program will not retrun any error", "author": "Utkalika Satapathy", "authorEmail": "utkalika.satapathy01@gmail.com", "date": "14.02.2023"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 1}, "2": {"capabilities": [], "helperCallParams": {}, "startLine": 24, "endLine": 31, "File": "/home/palani/github/palanik1/ebpf-projects-annotations/projects/ebpf-samples/original_source/tail_call.c", "funcName": "caller", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": " Copyright (c) Prevail Verifier contributors."}, {"start_line": 2, "end_line": 2, "text": " SPDX-License-Identifier: MIT"}, {"start_line": 29, "end_line": 29, "text": " bpf_tail_call failed at runtime."}], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *ctx"], "output": "int", "helper": ["bpf_tail_call"], "compatibleHookpoints": ["lwt_in", "sk_msg", "lwt_xmit", "sk_reuseport", "cgroup_sock", "xdp", "raw_tracepoint_writable", "lwt_out", "cgroup_sock_addr", "socket_filter", "sk_skb", "lwt_seg6local", "sock_ops", "tracepoint", "kprobe", "cgroup_skb", "sched_act", "perf_event", "raw_tracepoint", "flow_dissector", "sched_cls"], "source": ["int caller (struct xdp_md *ctx)\n", "{\n", "    long error = bpf_tail_call (ctx, & map, 0);\n", "    return (int) error;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}, {"description": "", "author": "", "authorEmail": "", "date": ""}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 1}, "3": {"capabilities": [], "helperCallParams": {}, "startLine": 34, "endLine": 38, "File": "/home/palani/github/palanik1/ebpf-projects-annotations/projects/ebpf-samples/original_source/tail_call_bad.c", "funcName": "callee", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["lwt_in", "sk_msg", "lwt_xmit", "sk_reuseport", "cgroup_sock", "xdp", "raw_tracepoint_writable", "lwt_out", "cgroup_sock_addr", "socket_filter", "sk_skb", "lwt_seg6local", "sock_ops", "tracepoint", "kprobe", "cgroup_skb", "cgroup_device", "sched_act", "perf_event", "cgroup_sysctl", "raw_tracepoint", "flow_dissector", "sched_cls"], "source": ["int callee (struct xdp_md *ctx)\n", "{\n", "    return 42;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}, {"description": "The function callee takes a pointer to ctx of type struct xdp_mdp as input.\n                      And it returns constant 42", "author": "Utkalika Satapathy", "authorEmail": "utkalika.satapathy01@gmail.com", "date": "17.02.2023"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 1}, "4": {"capabilities": [], "helperCallParams": {}, "startLine": 33, "endLine": 37, "File": "/home/palani/github/palanik1/ebpf-projects-annotations/projects/ebpf-samples/original_source/tail_call.c", "funcName": "callee", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["lwt_in", "sk_msg", "lwt_xmit", "sk_reuseport", "cgroup_sock", "xdp", "raw_tracepoint_writable", "lwt_out", "cgroup_sock_addr", "socket_filter", "sk_skb", "lwt_seg6local", "sock_ops", "tracepoint", "kprobe", "cgroup_skb", "cgroup_device", "sched_act", "perf_event", "cgroup_sysctl", "raw_tracepoint", "flow_dissector", "sched_cls"], "source": ["int callee (struct xdp_md *ctx)\n", "{\n", "    return 42;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}, {"description": "This is a callee function location which returns 42", "author": "Utkalika Satapathy", "authorEmail": "utkalika.satapathy01@gmail.com", "date": "14.02.2023"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 1}, "5": {"capabilities": [{"capability": "map_update", "map_update": [{"Project": "libbpf", "Return Type": "int", "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_map_update_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_update"]}]}], "helperCallParams": {}, "startLine": 29, "endLine": 36, "File": "/home/palani/github/palanik1/ebpf-projects-annotations/projects/ebpf-samples/original_source/exposeptr2.c", "funcName": "func", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": " Copyright (c) Prevail Verifier contributors."}, {"start_line": 2, "end_line": 2, "text": " SPDX-License-Identifier: MIT"}, {"start_line": 33, "end_line": 33, "text": " The following should fail verification since it stores"}, {"start_line": 34, "end_line": 34, "text": " a pointer in shared memory, thus exposing it to user-mode apps."}], "updateMaps": [" map"], "readMaps": [], "input": ["struct ctx *ctx"], "output": "int", "helper": ["bpf_map_update_elem"], "compatibleHookpoints": ["lwt_in", "sk_msg", "lwt_xmit", "sk_reuseport", "cgroup_sock", "xdp", "raw_tracepoint_writable", "lwt_out", "cgroup_sock_addr", "socket_filter", "sk_skb", "lwt_seg6local", "sock_ops", "tracepoint", "kprobe", "cgroup_skb", "cgroup_device", "sched_act", "perf_event", "cgroup_sysctl", "raw_tracepoint", "flow_dissector", "sched_cls"], "source": ["int func (struct ctx *ctx)\n", "{\n", "    uint32_t value = 0;\n", "    return ebpf_map_update_elem (&map, &ctx, &value, 0);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}, {"description": "Program defines structure ebpf_map of type bpf_map_def having\n                      elements type, key_size, value_size, max_entries, map_flags, \n                      inner_map_idx and numa_node of size 32 units each. \n                      exposeptr2_func() takes as input a structure pointer ctx of \n                      type ctx. It then initializes a variable 'value' of size 32 as\n                      0. Then it uses helper function ebpf_map_update_elem() to update\n                      the value of entry associated to ctx pointer\n                      in map with 'value' and return 0 on successful update, else\n                      return negative value. Here it returns  negative value as the \n                      helper function should fail verification since it stores a\n                      pointer in shared memory, thus exposing it to user-mode apps.", "author": "Neha Chowdhary", "authorEmail": "nehaniket79@gmail.com", "date": "06.02.2023"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 1}, "6": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 35, "endLine": 49, "File": "/home/palani/github/palanik1/ebpf-projects-annotations/projects/ebpf-samples/original_source/map_in_map.c", "funcName": "func", "developer_inline_comments": [{"start_line": 25, "end_line": 25, "text": " (uint32_t)&inner_map};"}], "updateMaps": [], "readMaps": ["  inner_map", " nolocal_lru_map", " array_of_maps"], "input": ["void *ctx"], "output": "int", "helper": ["bpf_map_lookup_elem"], "compatibleHookpoints": ["lwt_in", "sk_msg", "lwt_xmit", "sk_reuseport", "cgroup_sock", "xdp", "raw_tracepoint_writable", "lwt_out", "cgroup_sock_addr", "socket_filter", "sk_skb", "lwt_seg6local", "sock_ops", "tracepoint", "kprobe", "cgroup_skb", "cgroup_device", "sched_act", "perf_event", "cgroup_sysctl", "raw_tracepoint", "flow_dissector", "sched_cls"], "source": ["int func (void *ctx)\n", "{\n", "    uint32_t outer_key = 0;\n", "    void *nolocal_lru_map = bpf_map_lookup_elem (&array_of_maps, &outer_key);\n", "    if (nolocal_lru_map) {\n", "        uint32_t inner_key = 0;\n", "        void *ret = bpf_map_lookup_elem (nolocal_lru_map, &inner_key);\n", "        if (ret) {\n", "            return 0;\n", "        }\n", "        else {\n", "            ret = bpf_map_lookup_elem (& inner_map, & inner_key);\n", "            return 0;\n", "        }\n", "    }\n", "    return 0;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}, {"description": "Program defines two variables: 'uint32_t' of type unsigned int \n                      and 'uint64_t'of type unsigned long. Program defines structure \n                      ebpf_map of type bpf_map_def having elements type, key_size, \n                      value_size, max_entries, map_flags, inner_map_idx and numa_node \n                      of type uint32_t each. It defines two macros 'BPF_MAP_TYPE_ARRAY'\n                      as 2 and 'BPF_MAP_TYPE_ARRAY_OF_MAPS' as 12. Helper function \n                      bpf_map_lookup_elem() is used to look up outer_key and the result\n                      is stored in a variable 'nolocal_lru_map'. If this is 1, i.e. \n                      outer_map lookup is successful, then we use the same helper to look \n                      for inner_key using nolocal_lru_map and the result is stored in ret. \n                      If ret is true, function returns 0. Else ret is updated to value \n                      obtained on calling inner_key with inner_map via bpf_map_lookup_elem() \n                      and then function returns 0.", "author": "Neha Chowdhary", "authorEmail": "nehaniket79@gmail.com", "date": "06.02.2023"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 1}, "7": {"capabilities": [{"capability": "map_update", "map_update": [{"Project": "libbpf", "Return Type": "int", "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_map_update_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_update"]}]}], "helperCallParams": {}, "startLine": 29, "endLine": 38, "File": "/home/palani/github/palanik1/ebpf-projects-annotations/projects/ebpf-samples/original_source/mapunderflow.c", "funcName": "func", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": " Copyright (c) Prevail Verifier contributors."}, {"start_line": 2, "end_line": 2, "text": " SPDX-License-Identifier: MIT"}, {"start_line": 34, "end_line": 34, "text": " The following should fail verification since it tries to"}, {"start_line": 35, "end_line": 35, "text": " write before the start of the array, or past the end if -1"}, {"start_line": 36, "end_line": 36, "text": " is interpreted as unsigned."}], "updateMaps": [" map"], "readMaps": [], "input": ["struct ctx *ctx"], "output": "int", "helper": ["bpf_map_update_elem"], "compatibleHookpoints": ["lwt_in", "sk_msg", "lwt_xmit", "sk_reuseport", "cgroup_sock", "xdp", "raw_tracepoint_writable", "lwt_out", "cgroup_sock_addr", "socket_filter", "sk_skb", "lwt_seg6local", "sock_ops", "tracepoint", "kprobe", "cgroup_skb", "cgroup_device", "sched_act", "perf_event", "cgroup_sysctl", "raw_tracepoint", "flow_dissector", "sched_cls"], "source": ["int func (struct ctx *ctx)\n", "{\n", "    int key = -1;\n", "    uint64_t value = 0;\n", "    return ebpf_map_update_elem (&map, &key, &value, 0);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}, {"description": "Function tries to update the value of a key in a eBPF array.\n                      Program defines structure ebpf_map of type bpf_map_def having\n                      elements type, key_size, value_size, max_entries, map_flags, \n                      inner_map_idx and numa_node of size 32 units each. It also \n                      defines a macro BPF_MAP_TYPE_ARRAY of value 2. mapunderflow_func()\n                      defines two variables: 'key' of type integer having value -1 and \n                      'value' of size 64 having value 0. Then it uses \n                      ebpf_map_update_elem() helper function to update the map with \n                      value as 0 and key as -1. This will fail verification since it\n                      tries to write before the start of the array, or past the end \n                      if -1 is interpreted as unsigned. Function returns negative \n                      value on completion.", "author": "Neha Chowdhary", "authorEmail": "nehaniket79@gmail.com", "date": "06.02.2023"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 1}, "8": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}, {"capability": "read_sys_info", "read_sys_info": [{"Project": "cilium", "Return Type": "u32", "Description": "Get a pseudo-random number. From a security point of view , this helper uses its own pseudo-random internal state , and cannot be used to infer the seed of other random functions in the kernel. However , it is essential to note that the generator used by the helper is not cryptographically secure. ", "Return": " A random 32-bit unsigned value.", "Function Name": "get_prandom_u32", "Input Params": ["{Type: voi ,Var: void}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}]}], "helperCallParams": {}, "startLine": 29, "endLine": 48, "File": "/home/palani/github/palanik1/ebpf-projects-annotations/projects/ebpf-samples/original_source/twotypes.c", "funcName": "func", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": " Copyright (c) Prevail Verifier contributors."}, {"start_line": 2, "end_line": 2, "text": " SPDX-License-Identifier: MIT"}], "updateMaps": [], "readMaps": [" map"], "input": ["struct ctx *ctx"], "output": "int", "helper": ["bpf_map_lookup_elem", "get_prandom_u32"], "compatibleHookpoints": ["lwt_in", "sk_msg", "lwt_xmit", "sk_reuseport", "cgroup_sock", "xdp", "raw_tracepoint_writable", "lwt_out", "cgroup_sock_addr", "socket_filter", "sk_skb", "lwt_seg6local", "sock_ops", "tracepoint", "kprobe", "cgroup_skb", "sched_act", "perf_event", "raw_tracepoint", "flow_dissector", "sched_cls"], "source": ["int func (struct ctx *ctx)\n", "{\n", "    uint32_t rand32 = get_prandom_u32 ();\n", "    uint8_t stack_buffer [256] = {0};\n", "    *(uint32_t*) stack_buffer = rand32;\n", "    int map_key = 0;\n", "    uint8_t *map_value = (uint8_t *) bpf_map_lookup_elem (&map, &map_key);\n", "    if (map_value == 0)\n", "        return 0;\n", "    uint8_t *ptr;\n", "    if (rand32 & 1) {\n", "        ptr = map_value;\n", "    }\n", "    else {\n", "        ptr = stack_buffer + 128;\n", "    }\n", "    return (*ptr == stack_buffer[0]) ? 1 : 0;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}, {"description": "", "author": "", "authorEmail": "", "date": ""}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 1}, "9": {"capabilities": [{"capability": "map_update", "map_update": [{"Project": "libbpf", "Return Type": "int", "Description": "Add an entry to , or update a <[ map ]>(IP: 1) referencing sockets. The <[ skops ]>(IP: 0) is used as a new value for the entry associated to key. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 2) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 2) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. If the <[ map ]>(IP: 1) has eBPF programs (parser and verdict) , those will be inherited by the socket being added. If the socket is already attached to eBPF programs , this results in an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_sock_map_update", "Input Params": ["{Type: struct bpf_sock_ops ,Var: *skops}", "{Type:  struct bpf_map ,Var: *map}", "{Type:  void ,Var: *key}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sock_ops"], "capabilities": ["map_update"]}]}], "helperCallParams": {}, "startLine": 29, "endLine": 37, "File": "/home/palani/github/palanik1/ebpf-projects-annotations/projects/ebpf-samples/original_source/wronghelper.c", "funcName": "func", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": " Copyright (c) Prevail Verifier contributors."}, {"start_line": 2, "end_line": 2, "text": " SPDX-License-Identifier: MIT"}, {"start_line": 33, "end_line": 33, "text": " The following should fail because the ctx doesn't match, and in particular"}, {"start_line": 34, "end_line": 34, "text": " the memory pointed to by ctx might be smaller than the memory read by the helper."}], "updateMaps": [" ctx"], "readMaps": [], "input": ["void *ctx"], "output": "int", "helper": ["bpf_sock_map_update"], "compatibleHookpoints": ["sock_ops"], "source": ["int func (void *ctx)\n", "{\n", "    uint32_t key = 1;\n", "    int result = bpf_sock_map_update (ctx, & map, & key, 0);\n", "    return result;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}, {"description": "The function func() takes ctx of type void* as input parameter.\n                      bpf_sock_map_update(ctx, &map, &key, 0) adds an entry to a map referencing sockets as the flag is 0 i.e. BPF_NOEXIST. \n                      The ctx is used as a new value for the entry associated to key. \n                      The function will fail because the type of the ctx is not struct bpf_sock_ops.", "author": "Utkalika Satapathy", "authorEmail": "utkalika.satapathy01@gmail.com", "date": "14.02.2023"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 1}, "10": {"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "cilium", "Return Type": "u32", "Description": "Get a pseudo-random number. From a security point of view , this helper uses its own pseudo-random internal state , and cannot be used to infer the seed of other random functions in the kernel. However , it is essential to note that the generator used by the helper is not cryptographically secure. ", "Return": " A random 32-bit unsigned value.", "Function Name": "get_prandom_u32", "Input Params": ["{Type: voi ,Var: void}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}]}], "helperCallParams": {}, "startLine": 8, "endLine": 19, "File": "/home/palani/github/palanik1/ebpf-projects-annotations/projects/ebpf-samples/original_source/stackok.c", "funcName": "func", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": " Copyright (c) Prevail Verifier contributors."}, {"start_line": 2, "end_line": 2, "text": " SPDX-License-Identifier: MIT"}, {"start_line": 10, "end_line": 10, "text": " Initialize an array of 256 bytes (to all zeroes in this example)."}, {"start_line": 13, "end_line": 13, "text": " Set index to a random value in the interval [0,255]."}, {"start_line": 17, "end_line": 17, "text": " Return the array element at the specified index."}], "updateMaps": [], "readMaps": [], "input": ["void *ctx"], "output": "int", "helper": ["get_prandom_u32"], "compatibleHookpoints": ["lwt_in", "sk_msg", "lwt_xmit", "sk_reuseport", "cgroup_sock", "xdp", "raw_tracepoint_writable", "lwt_out", "cgroup_sock_addr", "socket_filter", "sk_skb", "lwt_seg6local", "sock_ops", "tracepoint", "kprobe", "cgroup_skb", "sched_act", "perf_event", "raw_tracepoint", "flow_dissector", "sched_cls"], "source": ["int func (void *ctx)\n", "{\n", "    char array [256] = \"\";\n", "    uint32_t rand32 = get_prandom_u32 ();\n", "    uint32_t index = *(unsignedchar*) &rand32;\n", "    return array[index];\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}, {"description": "An array of 256 bytes is initialized to 0.\n                      A random value of 8 bytes is generated using get_prandom_u32() and stored in rand32 variable. \n                      The index is set to rand32 value which is in the interval [0,255].\n                      The array element at the specified index is returned.", "author": "Utkalika Satapathy", "authorEmail": "utkalika.satapathy01@gmail.com", "date": "14.02.2023"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 1}, "11": {"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "bcc", "FunctionName": "bpf_get_current_comm", "Return Type": "int", "Description": "bpf_get_current_comm(char *buf, int size_of_buf) Return: 0 on success Populates the first argument address with the current process name. It should be a pointer to a char array of at least size TASK_COMM_LEN, which is defined in linux/sched.h. For example: ```C include ", "Return": "0 on success", "Input Prameters": ["{Type: char* ,Var: buf}", "{Type: int ,Var: size_of_buf}"], "compatible_hookpoints": ["kprobe", "tracepoint", "perf_event", "raw_tracepoint", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}]}], "helperCallParams": {}, "startLine": 8, "endLine": 15, "File": "/home/palani/github/palanik1/ebpf-projects-annotations/projects/ebpf-samples/original_source/badhelpercall.c", "funcName": "func", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": " Copyright (c) Prevail Verifier contributors."}, {"start_line": 2, "end_line": 2, "text": " SPDX-License-Identifier: MIT"}, {"start_line": 12, "end_line": 12, "text": " The following should fail verification since it asks the helper"}, {"start_line": 13, "end_line": 13, "text": " to write past the end of the stack."}], "updateMaps": [], "readMaps": [], "input": ["NA"], "output": "int", "helper": ["bpf_get_current_comm"], "compatibleHookpoints": ["raw_tracepoint_writable", "perf_event", "tracepoint", "kprobe", "raw_tracepoint"], "source": ["int func ()\n", "{\n", "    char buffer [1];\n", "    return ebpf_get_current_comm (buffer, 20);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}, {"description": "badhelpercall_func() defines a character array 'buffer' of size 1.\n                      It then calls the buffer for size 20 although it has\n                      been defined above as size 16. Thus this will give\n                      an error on calling ebpf_get_current_comm() helper\n                      function with buffer and 20 as arguments.", "author": "Neha Chowdhary", "authorEmail": "nehaniket79@gmail.com", "date": "02.02.2023"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 1}, "12": {"capabilities": [{"capability": "map_update", "map_update": [{"Project": "libbpf", "Return Type": "int", "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_map_update_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_update"]}]}], "helperCallParams": {}, "startLine": 31, "endLine": 38, "File": "/home/palani/github/palanik1/ebpf-projects-annotations/projects/ebpf-samples/original_source/badrelo.c", "funcName": "func", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": " Copyright (c) Prevail Verifier contributors."}, {"start_line": 2, "end_line": 2, "text": " SPDX-License-Identifier: MIT"}, {"start_line": 25, "end_line": 25, "text": " This will be an unresolved symbol in the resulting .o file."}, {"start_line": 35, "end_line": 35, "text": " And we can furthermore pass some bad parameters in here.  These"}, {"start_line": 36, "end_line": 36, "text": " would be illegal to pass to bpf_map_update_elem if it were resolved."}], "updateMaps": [" map2"], "readMaps": [], "input": ["struct ctx *ctx"], "output": "int", "helper": ["bpf_map_update_elem"], "compatibleHookpoints": ["lwt_in", "sk_msg", "lwt_xmit", "sk_reuseport", "cgroup_sock", "xdp", "raw_tracepoint_writable", "lwt_out", "cgroup_sock_addr", "socket_filter", "sk_skb", "lwt_seg6local", "sock_ops", "tracepoint", "kprobe", "cgroup_skb", "cgroup_device", "sched_act", "perf_event", "cgroup_sysctl", "raw_tracepoint", "flow_dissector", "sched_cls"], "source": ["int func (struct ctx *ctx)\n", "{\n", "    struct bpf_map map2;\n", "    return bpf_map_update_elem (&map2, (const void *) 0, (const void *) 0, 0);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}, {"description": "Program defines structure bpf_map having elements type, key_size,\n                      value_size, max_entries, map_flags, inner_map_idx and numa_node of \n                      size 32 units each. badrelo_func() takes a pointer ctx of type struct ctx \n                      as input. It creates a structure of type bpf_map 'map2' and calls the \n                      helper function bpf_map_update_elem() on map2. It returns an error \n                      because bpf_map_update_elem is defined in the program with respect\n                      to the structure map not map2. bpf_map() is an element of type\n                      BPF_MAP_TYPE_ARRAY. Function returns -1 because bpf_map_update_elem\n                      is unsuccessful.", "author": "Neha Chowdhary", "authorEmail": "nehaniket79@gmail.com", "date": "06.02.2023"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 1}, "13": {"capabilities": [{"capability": "map_update", "map_update": [{"Project": "libbpf", "Return Type": "int", "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_map_update_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_update"]}]}], "helperCallParams": {}, "startLine": 29, "endLine": 36, "File": "/home/palani/github/palanik1/ebpf-projects-annotations/projects/ebpf-samples/original_source/exposeptr.c", "funcName": "func", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": " Copyright (c) Prevail Verifier contributors."}, {"start_line": 2, "end_line": 2, "text": " SPDX-License-Identifier: MIT"}, {"start_line": 33, "end_line": 33, "text": " The following should fail verification since it stores"}, {"start_line": 34, "end_line": 34, "text": " a pointer in shared memory, thus exposing it to user-mode apps."}], "updateMaps": [" map"], "readMaps": [], "input": ["struct ctx *ctx"], "output": "int", "helper": ["bpf_map_update_elem"], "compatibleHookpoints": ["lwt_in", "sk_msg", "lwt_xmit", "sk_reuseport", "cgroup_sock", "xdp", "raw_tracepoint_writable", "lwt_out", "cgroup_sock_addr", "socket_filter", "sk_skb", "lwt_seg6local", "sock_ops", "tracepoint", "kprobe", "cgroup_skb", "cgroup_device", "sched_act", "perf_event", "cgroup_sysctl", "raw_tracepoint", "flow_dissector", "sched_cls"], "source": ["int func (struct ctx *ctx)\n", "{\n", "    uint32_t key = 0;\n", "    return ebpf_map_update_elem (&map, &key, &ctx, 0);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}, {"description": "Program defines structure ebpf_map of type bpf_map_def having elements type, key_size, value_size, max_entries, map_flags, inner_map_idx and numa_node of size 32 units each. exposeptr_func() takes as input a structure pointer ctx  of type ctx. It then initializes a variable 'key' of size 32 with value 0. Then it uses  helper function ebpf_map_update_elem() to update the value of entry associated to key in map with ctx pointer. It returns 0 on successful update, else returns negative value. Here it will not get loaded as the helper function should fail verification since it stores a  pointer in shared memory, thus exposing it to user-mode apps.", "author": "Neha Chowdhary", "authorEmail": "nehaniket79@gmail.com", "date": "06.02.2023"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 1}, "14": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 26, "endLine": 39, "File": "/home/palani/github/palanik1/ebpf-projects-annotations/projects/ebpf-samples/original_source/mapvalue-overrun.c", "funcName": "func", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": " Copyright (c) Prevail Verifier contributors."}, {"start_line": 2, "end_line": 2, "text": " SPDX-License-Identifier: MIT"}, {"start_line": 35, "end_line": 35, "text": " The map's value size can only hold a uint32_t."}, {"start_line": 36, "end_line": 36, "text": " So verification should fail if we try to read past the space returned."}], "updateMaps": [], "readMaps": [" map"], "input": ["void *ctx"], "output": "int", "helper": ["bpf_map_lookup_elem"], "compatibleHookpoints": ["lwt_in", "sk_msg", "lwt_xmit", "sk_reuseport", "cgroup_sock", "xdp", "raw_tracepoint_writable", "lwt_out", "cgroup_sock_addr", "socket_filter", "sk_skb", "lwt_seg6local", "sock_ops", "tracepoint", "kprobe", "cgroup_skb", "cgroup_device", "sched_act", "perf_event", "cgroup_sysctl", "raw_tracepoint", "flow_dissector", "sched_cls"], "source": ["int func (void *ctx)\n", "{\n", "    uint32_t key = 1;\n", "    uint64_t *ptr = bpf_map_lookup_elem (&map, &key);\n", "    if (ptr == 0) {\n", "        return 0;\n", "    }\n", "    uint64_t i = *ptr;\n", "    return (uint32_t) i;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}, {"description": "Program defines two variables: 'uint32_t' of type unsigned int \n                      and 'uint64_t'of type unsigned long. Program also defines \n                      structure ebpf_map of type bpf_map_def having elements type,\n                      key_size, value_size, max_entries, map_flags, inner_map_idx\n                      and numa_node of type uint32_t each. It also defines a macro\n                      BPF_MAP_TYPE_ARRAY of value 2. mapvalue-overrun_func() defines\n                      a key of type uint32_t having value 1. It uses helper function\n                      bpf_map_lookup_elem() to look up entry associate with key in\n                      map and stores the result in ptr pointer of type 'uint64_t'.\n                      If the entry is not found (i.e. ptr=0), function returns 0. Else\n                      ptr is stored in variable 'i' of type uint64_t' and the function\n                      returns typecast value of i with respect to type uint32_t.", "author": "Neha Chowdhary", "authorEmail": "nehaniket79@gmail.com", "date": "06.02.2023"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 1}, "15": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}, {"capability": "read_sys_info", "read_sys_info": [{"Project": "cilium", "Return Type": "u32", "Description": "Get a pseudo-random number. From a security point of view , this helper uses its own pseudo-random internal state , and cannot be used to infer the seed of other random functions in the kernel. However , it is essential to note that the generator used by the helper is not cryptographically secure. ", "Return": " A random 32-bit unsigned value.", "Function Name": "get_prandom_u32", "Input Params": ["{Type: voi ,Var: void}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}]}], "helperCallParams": {}, "startLine": 36, "endLine": 48, "File": "/home/palani/github/palanik1/ebpf-projects-annotations/projects/ebpf-samples/original_source/twomaps.c", "funcName": "func", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": " Copyright (c) Prevail Verifier contributors."}, {"start_line": 2, "end_line": 2, "text": " SPDX-License-Identifier: MIT"}, {"start_line": 46, "end_line": 46, "text": " The following is safe since both maps have the same value size."}], "updateMaps": [], "readMaps": [" map"], "input": ["struct ctx *ctx"], "output": "int", "helper": ["bpf_map_lookup_elem", "get_prandom_u32"], "compatibleHookpoints": ["lwt_in", "sk_msg", "lwt_xmit", "sk_reuseport", "cgroup_sock", "xdp", "raw_tracepoint_writable", "lwt_out", "cgroup_sock_addr", "socket_filter", "sk_skb", "lwt_seg6local", "sock_ops", "tracepoint", "kprobe", "cgroup_skb", "sched_act", "perf_event", "raw_tracepoint", "flow_dissector", "sched_cls"], "source": ["int func (struct ctx *ctx)\n", "{\n", "    uint32_t rand32 = get_prandom_u32 ();\n", "    struct ebpf_map *map = (rand32 & 1) ? &map1 : &map2;\n", "    int key = 10;\n", "    uint64_t *value = (uint64_t *) bpf_map_lookup_elem (map, &key);\n", "    if (value == 0)\n", "        return 0;\n", "    return (int) *value;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}, {"description": "", "author": "", "authorEmail": "", "date": ""}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 1}, "16": {"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "cilium", "Return Type": "u32", "Description": "Get a pseudo-random number. From a security point of view , this helper uses its own pseudo-random internal state , and cannot be used to infer the seed of other random functions in the kernel. However , it is essential to note that the generator used by the helper is not cryptographically secure. ", "Return": " A random 32-bit unsigned value.", "Function Name": "get_prandom_u32", "Input Params": ["{Type: voi ,Var: void}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}]}], "helperCallParams": {}, "startLine": 10, "endLine": 46, "File": "/home/palani/github/palanik1/ebpf-projects-annotations/projects/ebpf-samples/original_source/twostackvars.c", "funcName": "func", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": " Copyright (c) Prevail Verifier contributors."}, {"start_line": 2, "end_line": 2, "text": " SPDX-License-Identifier: MIT"}, {"start_line": 17, "end_line": 17, "text": " In this path we want ptr to point to one section"}, {"start_line": 18, "end_line": 18, "text": " of stack space that is known to be a number, and have"}, {"start_line": 19, "end_line": 19, "text": " the rest of the stack be unknown."}, {"start_line": 26, "end_line": 26, "text": " Do something with the pointer to force it to be saved in a"}, {"start_line": 27, "end_line": 27, "text": " register before joining the two paths."}, {"start_line": 30, "end_line": 30, "text": " In this path we want ptr to point to a different section"}, {"start_line": 31, "end_line": 31, "text": " of stack space that is known to be a number, and have"}, {"start_line": 32, "end_line": 32, "text": " the rest of the stack be unknown."}, {"start_line": 40, "end_line": 40, "text": " Here we want to dereference the pointer to get a number."}, {"start_line": 41, "end_line": 41, "text": " In both paths above, ptr safely points to a number, even"}, {"start_line": 42, "end_line": 42, "text": " though each part of stack_buffer is not necessarily a number"}, {"start_line": 43, "end_line": 43, "text": " at this point."}], "updateMaps": [], "readMaps": [], "input": ["struct ctx *ctx"], "output": "int", "helper": ["get_prandom_u32"], "compatibleHookpoints": ["lwt_in", "sk_msg", "lwt_xmit", "sk_reuseport", "cgroup_sock", "xdp", "raw_tracepoint_writable", "lwt_out", "cgroup_sock_addr", "socket_filter", "sk_skb", "lwt_seg6local", "sock_ops", "tracepoint", "kprobe", "cgroup_skb", "sched_act", "perf_event", "raw_tracepoint", "flow_dissector", "sched_cls"], "source": ["int func (struct ctx *ctx)\n", "{\n", "    int stack_buffer [16];\n", "    int *ptr = (int *) 0;\n", "    uint32_t rand32 = get_prandom_u32 ();\n", "    if (rand32 & 1) {\n", "        for (int i = 0; i < 8; i++) {\n", "            stack_buffer[i] = get_prandom_u32 ();\n", "        }\n", "        int index = rand32 % 8;\n", "        ptr = &stack_buffer[index];\n", "        ptr[index ^ 1] = 0;\n", "    }\n", "    else {\n", "        int *stack_buffer2 = &stack_buffer[8];\n", "        for (int i = 0; i < 8; i++) {\n", "            stack_buffer2[i] = get_prandom_u32 ();\n", "        }\n", "        ptr = &stack_buffer2[rand32 % 8];\n", "    }\n", "    return *ptr;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}, {"description": "The function func() takes the pointer to struct ctx as input parameter.\n                      An integer array of size 16 is declared named stack_buffer.\n                      An integer random value is generated of type uint32_t is generated using get_prandom_u32()\n                      If the random value is non-zero, the first half of stack_buffer with index [0-7] is filled with random values.\n                      The index variable is initalized with a value which is modulo 8 of rand32 variable i.e. any value from [0-7] is assigned to index.\n                      The pointer ptr points to the address of that index in the stack_buffer.\n                      Else if the random value is 0, the integer pointer stack_buffer2 points to the second half of the array stack_buffer[8].\n                      The second half of the array is filled with random interger values whereas the first half values are unknown.\n                      And the pointer ptr points to the first location of second half array of stack_buffer.\n                      The function func finally returns the value pointed by ptr in the array.", "author": "Utkalika Satapathy", "authorEmail": "utkalika.satapathy01@gmail.com", "date": "14.02.2023"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 1}, "17": {"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "cilium", "Return Type": "u32", "Description": "Get a pseudo-random number. From a security point of view , this helper uses its own pseudo-random internal state , and cannot be used to infer the seed of other random functions in the kernel. However , it is essential to note that the generator used by the helper is not cryptographically secure. ", "Return": " A random 32-bit unsigned value.", "Function Name": "get_prandom_u32", "Input Params": ["{Type: voi ,Var: void}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}]}], "helperCallParams": {}, "startLine": 8, "endLine": 26, "File": "/home/palani/github/palanik1/ebpf-projects-annotations/projects/ebpf-samples/original_source/byteswap.c", "funcName": "func", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": " Copyright (c) Prevail Verifier contributors."}, {"start_line": 2, "end_line": 2, "text": " SPDX-License-Identifier: MIT"}], "updateMaps": [], "readMaps": [], "input": ["struct ctx *ctx"], "output": "int", "helper": ["get_prandom_u32"], "compatibleHookpoints": ["lwt_in", "sk_msg", "lwt_xmit", "sk_reuseport", "cgroup_sock", "xdp", "raw_tracepoint_writable", "lwt_out", "cgroup_sock_addr", "socket_filter", "sk_skb", "lwt_seg6local", "sock_ops", "tracepoint", "kprobe", "cgroup_skb", "sched_act", "perf_event", "raw_tracepoint", "flow_dissector", "sched_cls"], "source": ["int func (struct ctx *ctx)\n", "{\n", "    int rand32 = get_prandom_u32 ();\n", "    if (rand32 & 0x01) {\n", "        asm volatile (\"r0 = le64 r0\\nexit\"\n", "            );\n", "    }\n", "    else if (rand32 & 0x02) {\n", "        asm volatile (\"r0 = le32 r0\\nexit\"\n", "            );\n", "    }\n", "    else if (rand32 & 0x04) {\n", "        asm volatile (\"r0 = le16 r0\\nexit\"\n", "            );\n", "    }\n", "    else if (rand32 & 0x10) {\n", "        asm volatile (\"r0 = be64 r0\\nexit\"\n", "            );\n", "    }\n", "    else if (rand32 & 0x20) {\n", "        asm volatile (\"r0 = be32 r0\\nexit\"\n", "            );\n", "    }\n", "    else {\n", "        asm volatile (\"r0 = be16 r0\\nexit\"\n", "            );\n", "    }\n", "    return 0;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}, {"description": "byteswap_func() takes as input a structure pointer ctx of type ctx.\n                      A random number is generated and stored in variable 'rand32'. Then\n                      this rand32 is compared with various hexadecimal values and according\n                      to the results of the comparison, a value is stored in register 'r0'.\n                      If rand32 is 0x001, value stored in r0 is 'le64 r0' and so on. If all\n                      the comparisons fail, 'be16 r0' is stored in r0 by default. Function\n                      returns 0 on completion.", "author": "Neha Chowdhary", "authorEmail": "nehaniket79@gmail.com", "date": "06.02.2023"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 1}, "18": {"capabilities": [{"capability": "map_update", "map_update": [{"Project": "libbpf", "Return Type": "int", "Description": "Add an entry to , or update a <[ map ]>(IP: 1) referencing sockets. The <[ skops ]>(IP: 0) is used as a new value for the entry associated to key. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 2) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 2) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. If the <[ map ]>(IP: 1) has eBPF programs (parser and verdict) , those will be inherited by the socket being added. If the socket is already attached to eBPF programs , this results in an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_sock_map_update", "Input Params": ["{Type: struct bpf_sock_ops ,Var: *skops}", "{Type:  struct bpf_map ,Var: *map}", "{Type:  void ,Var: *key}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sock_ops"], "capabilities": ["map_update"]}]}], "helperCallParams": {}, "startLine": 29, "endLine": 38, "File": "/home/palani/github/palanik1/ebpf-projects-annotations/projects/ebpf-samples/original_source/ctxoffset.c", "funcName": "func", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": " Copyright (c) Prevail Verifier contributors."}, {"start_line": 2, "end_line": 2, "text": " SPDX-License-Identifier: MIT"}, {"start_line": 33, "end_line": 33, "text": " The following should fail because the sock_ops ctx isn't the same pointer passed in"}, {"start_line": 34, "end_line": 34, "text": " but is offset 8 bytes into it."}], "updateMaps": [" ctx"], "readMaps": [], "input": ["void *ctx"], "output": "int", "helper": ["bpf_sock_map_update"], "compatibleHookpoints": ["sock_ops"], "source": ["int func (void *ctx)\n", "{\n", "    uint32_t key = 1;\n", "    ctx = ((char *) ctx) + 8;\n", "    int result = bpf_sock_map_update (ctx, & map, & key, 0);\n", "    return result;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}, {"description": "ctxoffset_func() takes as input a void pointer of type ctx.\n                      It initializes a variable 'key' of size 32 with value 1.\n                      Then it typecasts the ctx pointer to character and adds\n                      8 bits to it. It then uses helper function\n                      bpf_sock_map_update() to update the socket map using\n                      this ctx pointer which will give an error as 'ctx + 8' is\n                      an invalid pointer. Function will not pass verifier and \n                      will not get loaded.", "author": "Neha Chowdhary", "authorEmail": "nehaniket79@gmail.com", "date": "06.02.2023"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 1}, "19": {"capabilities": [{"capability": "map_update", "map_update": [{"Project": "libbpf", "Return Type": "int", "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_map_update_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_update"]}]}], "helperCallParams": {}, "startLine": 29, "endLine": 37, "File": "/home/palani/github/palanik1/ebpf-projects-annotations/projects/ebpf-samples/original_source/mapoverflow.c", "funcName": "func", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": " Copyright (c) Prevail Verifier contributors."}, {"start_line": 2, "end_line": 2, "text": " SPDX-License-Identifier: MIT"}, {"start_line": 34, "end_line": 34, "text": " The following should fail verification since it tries to"}, {"start_line": 35, "end_line": 35, "text": " write past the size of the array."}], "updateMaps": [" map"], "readMaps": [], "input": ["struct ctx *ctx"], "output": "int", "helper": ["bpf_map_update_elem"], "compatibleHookpoints": ["lwt_in", "sk_msg", "lwt_xmit", "sk_reuseport", "cgroup_sock", "xdp", "raw_tracepoint_writable", "lwt_out", "cgroup_sock_addr", "socket_filter", "sk_skb", "lwt_seg6local", "sock_ops", "tracepoint", "kprobe", "cgroup_skb", "cgroup_device", "sched_act", "perf_event", "cgroup_sysctl", "raw_tracepoint", "flow_dissector", "sched_cls"], "source": ["int func (struct ctx *ctx)\n", "{\n", "    uint32_t key = 10;\n", "    uint64_t value = 0;\n", "    return ebpf_map_update_elem (&map, &key, &value, 0);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}, {"description": "Function tries to update the value of a key in a eBPF array.Program defines two variables: 'uint32_t' of type unsigned int \n                      and 'uint64_t'of type unsigned long. Program defines structure ebpf_map of type bpf_map_def having elements type, key_size, \n                      value_size, max_entries, map_flags, inner_map_idx and numa_node of type uint32_t each. It also defines a macro BPF_MAP_TYPE_ARRAY \n                      of value 2. mapoverflow_func() defines two variables: 'key' of type  uint32_t having value 10 and 'value' of type uint64_t having value 0. Then it uses ebpf_map_update_elem() helper function to update the map with value as 0 and key as 10. This will fail  verification since it tries to write past the size of the   array. Function will return negative value on completion.", "author": "Neha Chowdhary", "authorEmail": "nehaniket79@gmail.com", "date": "06.02.2023"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 1}, "20": {"capabilities": [], "helperCallParams": {}, "startLine": 18, "endLine": 27, "File": "/home/palani/github/palanik1/ebpf-projects-annotations/projects/ebpf-samples/original_source/packet_overflow.c", "funcName": "read_write_packet_start", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": " Copyright (c) Prevail Verifier contributors."}, {"start_line": 2, "end_line": 2, "text": " SPDX-License-Identifier: MIT"}], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["lwt_in", "sk_msg", "lwt_xmit", "sk_reuseport", "cgroup_sock", "xdp", "raw_tracepoint_writable", "lwt_out", "cgroup_sock_addr", "socket_filter", "sk_skb", "lwt_seg6local", "sock_ops", "tracepoint", "kprobe", "cgroup_skb", "cgroup_device", "sched_act", "perf_event", "cgroup_sysctl", "raw_tracepoint", "flow_dissector", "sched_cls"], "source": ["int read_write_packet_start (struct xdp_md *ctx)\n", "{\n", "    void *data_end = (void *) (long) ctx->data_end;\n", "    void *data = (void *) (long) ctx->data;\n", "    if (data > data_end)\n", "        return 1;\n", "    int value = *(int*) data;\n", "    *(int*) data = value + 1;\n", "    return 0;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}, {"description": "struct xdp_md is an user-accessible metadata for the XDP packet hook.\n                      This is used as an input parameter of the function read_write_packet_start(), to access the packet contents via the XDP context.\n                      The packet contents are between ctx->data and ctx->data_end.\n                      It checks packet bounds i.e if the start of the packet is greater than the end of the packet, it returns 1 i.e. error in retrieving the packet contents.\n                      Else, it reads the integer content of the packet, increases the value by 1, and writes back to the packet.\n                      On successfully writing the value in the packet it returns 0.", "author": "Utkalika Satapathy", "authorEmail": "utkalika.satapathy01@gmail.com", "date": ""}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 1}, "21": {"capabilities": [], "helperCallParams": {}, "startLine": 18, "endLine": 27, "File": "/home/palani/github/palanik1/ebpf-projects-annotations/projects/ebpf-samples/original_source/packet_start_ok.c", "funcName": "read_write_packet_start", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": " Copyright (c) Prevail Verifier contributors."}, {"start_line": 2, "end_line": 2, "text": " SPDX-License-Identifier: MIT"}], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["lwt_in", "sk_msg", "lwt_xmit", "sk_reuseport", "cgroup_sock", "xdp", "raw_tracepoint_writable", "lwt_out", "cgroup_sock_addr", "socket_filter", "sk_skb", "lwt_seg6local", "sock_ops", "tracepoint", "kprobe", "cgroup_skb", "cgroup_device", "sched_act", "perf_event", "cgroup_sysctl", "raw_tracepoint", "flow_dissector", "sched_cls"], "source": ["int read_write_packet_start (struct xdp_md *ctx)\n", "{\n", "    void *data_end = (void *) (long) ctx->data_end;\n", "    void *data = (void *) (long) ctx->data;\n", "    if (data + sizeof (int) > data_end)\n", "        return 1;\n", "    int value = *(int*) data;\n", "    *(int*) data = value + 1;\n", "    return 0;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}, {"description": "", "author": "", "authorEmail": "", "date": ""}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 1}, "22": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 28, "endLine": 40, "File": "/home/palani/github/palanik1/ebpf-projects-annotations/projects/ebpf-samples/original_source/badmapptr.c", "funcName": "test_repro", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": " Copyright (c) Prevail Verifier contributors."}, {"start_line": 2, "end_line": 2, "text": " SPDX-License-Identifier: MIT"}, {"start_line": 22, "end_line": 22, "text": " BPF_MAP_TYPE_HASH"}, {"start_line": 35, "end_line": 35, "text": " Instead of passing in the correct map pointer, pass in a value past it."}, {"start_line": 36, "end_line": 36, "text": " This should fail verification."}], "updateMaps": [], "readMaps": [" map + 1"], "input": ["void *ctx"], "output": "int", "helper": ["bpf_map_lookup_elem"], "compatibleHookpoints": ["lwt_in", "sk_msg", "lwt_xmit", "sk_reuseport", "cgroup_sock", "xdp", "raw_tracepoint_writable", "lwt_out", "cgroup_sock_addr", "socket_filter", "sk_skb", "lwt_seg6local", "sock_ops", "tracepoint", "kprobe", "cgroup_skb", "cgroup_device", "sched_act", "perf_event", "cgroup_sysctl", "raw_tracepoint", "flow_dissector", "sched_cls"], "source": ["int test_repro (void *ctx)\n", "{\n", "    uint32_t key = 1;\n", "    bpf_map_def_t *map = &test_map;\n", "    uint32_t *value = ebpf_map_lookup_elem (map + 1, &key);\n", "    return (value != 0);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}, {"description": "Program defines structure bpf_map_def_t of type bpf_map_def\n                      having elements type, key_size, value_size, max_entries,\n                      map_flags, inner_map_idx and numa_node of size 32 units\n                      each. badmapptr_test_repro() defines a key of value 1. A test map\n                      of type bpf_map_def_t is defined. Two values 'map + 1' and 'key'\n                      are passed in ebpf_map_lookup_elem which will return value\n                      in 'value'. If value!=0, then function returns 1 else 0.", "author": "Neha Chowdhary", "authorEmail": "nehaniket79@gmail.com", "date": "02.02.2023"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 1}, "23": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 28, "endLine": 40, "File": "/home/palani/github/palanik1/ebpf-projects-annotations/projects/ebpf-samples/original_source/nullmapref.c", "funcName": "test_repro", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": " Copyright (c) Prevail Verifier contributors."}, {"start_line": 2, "end_line": 2, "text": " SPDX-License-Identifier: MIT"}, {"start_line": 22, "end_line": 22, "text": " BPF_MAP_TYPE_HASH"}, {"start_line": 35, "end_line": 35, "text": " ebpf_map_lookup_elem can return NULL if not found,"}, {"start_line": 36, "end_line": 36, "text": " so this unchecked dereference should fail verification."}], "updateMaps": [], "readMaps": [" test_map"], "input": ["void *ctx"], "output": "int", "helper": ["bpf_map_lookup_elem"], "compatibleHookpoints": ["lwt_in", "sk_msg", "lwt_xmit", "sk_reuseport", "cgroup_sock", "xdp", "raw_tracepoint_writable", "lwt_out", "cgroup_sock_addr", "socket_filter", "sk_skb", "lwt_seg6local", "sock_ops", "tracepoint", "kprobe", "cgroup_skb", "cgroup_device", "sched_act", "perf_event", "cgroup_sysctl", "raw_tracepoint", "flow_dissector", "sched_cls"], "source": ["int test_repro (void *ctx)\n", "{\n", "    uint32_t key = 1;\n", "    uint32_t *value = ebpf_map_lookup_elem (&test_map, &key);\n", "    *value = 1;\n", "    return 0;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}, {"description": "This function updates a value for key==1 in test_map.\n                      Program defines variable 'uint32_t' of type unsigned int\n                      and a structure _bpf_map_def of type bpf_map_def having \n                      elements type, key_size, value_size, max_entries, map_flags,\n                      inner_map_idx and numa_node of type uint32_t each. Function\n                      nullmapref_test_repro() takes as input a void pointer ctx. It\n                      defines a variable key of type uint32_t with value 1. Then it\n                      calls helper function ebpf_map_lookup_elem() to look for entry\n                      associated to key in test_map and store the result in variable\n                      'value' of type uint32_t. ebpf_map_lookup_elem can return NULL\n                      if not found, so this unchecked dereference should fail \n                      verification. Then we update 'value' to 1. Function returns 0\n                      on completion.", "author": "Neha Chowdhary", "authorEmail": "nehaniket79@gmail.com", "date": "06.02.2023"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 1}, "24": {"capabilities": [{"capability": "update_pkt", "update_pkt": [{"Project": "libbpf", "Return Type": "int", "Description": "Grows headroom of packet associated to <[ skb ]>(IP: 0) and adjusts the offset of the MAC header accordingly , adding <[ len ]>(IP: 1) bytes of space. It automatically extends and reallocates memory as required. This helper can be used on a layer 3 <[ skb ]>(IP: 0) to push a MAC header for redirection into a layer 2 device. All values for <[ flags ]>(IP: 2) are reserved for future usage , and must be left at zero. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_skb_change_head", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: len}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "lwt_xmit", "sk_skb"], "capabilities": ["update_pkt"]}]}], "helperCallParams": {}, "startLine": 17, "endLine": 34, "File": "/home/palani/github/palanik1/ebpf-projects-annotations/projects/ebpf-samples/original_source/packet_reallocate.c", "funcName": "reallocate_invalidates", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": " Copyright (c) Prevail Verifier contributors."}, {"start_line": 2, "end_line": 2, "text": " SPDX-License-Identifier: MIT"}], "updateMaps": [], "readMaps": [], "input": ["struct sk_buff *ctx"], "output": "int", "helper": ["bpf_skb_change_head"], "compatibleHookpoints": ["sk_skb", "lwt_xmit", "sched_cls", "sched_act"], "source": ["int reallocate_invalidates (struct sk_buff *ctx)\n", "{\n", "    void *data_end = (void *) (long) ctx->data_end;\n", "    void *data = (void *) (long) ctx->data;\n", "    if (data + sizeof (int) > data_end)\n", "        return 1;\n", "    int value = *(int*) data;\n", "    *(int*) data = value + 1;\n", "    bpf_skb_change_head (ctx, 4, 0);\n", "    value = *(int*) data;\n", "    *(int*) data = value + 1;\n", "    return 0;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}, {"description": "", "author": "", "authorEmail": "", "date": ""}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 1}, "25": {"capabilities": [], "helperCallParams": {}, "startLine": 13, "endLine": 31, "File": "/home/palani/github/palanik1/ebpf-projects-annotations/projects/ebpf-samples/original_source/loop.c", "funcName": "foo", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": " Copyright (c) Prevail Verifier contributors."}, {"start_line": 2, "end_line": 2, "text": " SPDX-License-Identifier: MIT"}], "updateMaps": [], "readMaps": [], "input": ["struct test_md *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["lwt_in", "sk_msg", "lwt_xmit", "sk_reuseport", "cgroup_sock", "xdp", "raw_tracepoint_writable", "lwt_out", "cgroup_sock_addr", "socket_filter", "sk_skb", "lwt_seg6local", "sock_ops", "tracepoint", "kprobe", "cgroup_skb", "cgroup_device", "sched_act", "perf_event", "cgroup_sysctl", "raw_tracepoint", "flow_dissector", "sched_cls"], "source": ["int foo (struct test_md *ctx)\n", "{\n", "    int index;\n", "    int cumul = 0;\n", "    uint8_t array [ARRAY_LENGTH] = {0};\n", "    for (index = 0; index < sizeof (array); index++) {\n", "        if ((ctx->data_start + index) >= ctx->data_end)\n", "            break;\n", "        array[index] = 1;\n", "    }\n", "    for (index = 0; index < sizeof (array); index++) {\n", "        cumul += array[index];\n", "    }\n", "    return cumul;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}, {"description": "Function writes 1 in each element of an array of size ARRAY_LENGTH and \n                      then returns the sum of elements of the array. Hence, in absence of errors,\n                      the code should return ARRAY_LENGTH.Program defines a structure test_md\n                      having two elements data_start and data_end of type uint8_t. uint8_t \n                      is defined earlier in the program  as variable type unsigned char. It\n                      also defines a macro ARRAY_LENGTH of value 40. foo() takes as input a \n                      pointer ctx of type struct test_md. It has two variables named index\n                      and cumul initialized as 0. It also defines an array of length \n                      ARRAY_LENGTH (i.e. 40) initialized as 0. Then the function runs a for \n                      loop over index = (0 to size of array) to check whether the difference \n                      of data_start and data_end is greater than value in 'index'. If yes it \n                      sets array at index value 'index' as 1. Finally it runs a for loop from\n                      index = (0 to array size) and calculates the sum of all the elements.\n                      Function returns this sum which is stored in 'cumul' on completion.", "author": "Neha Chowdhary", "authorEmail": "nehaniket79@gmail.com", "date": "06.02.2023"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 1}, "26": {"capabilities": [], "helperCallParams": {}, "startLine": 24, "endLine": 32, "File": "/home/palani/github/palanik1/ebpf-projects-annotations/projects/ebpf-samples/original_source/ringbuf_uninit.c", "funcName": "test", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": " Copyright (c) Prevail Verifier contributors."}, {"start_line": 2, "end_line": 2, "text": " SPDX-License-Identifier: MIT"}, {"start_line": 28, "end_line": 28, "text": " The following call should fail verification as test is not initialized."}], "updateMaps": [], "readMaps": [], "input": ["void *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["lwt_in", "sk_msg", "lwt_xmit", "sk_reuseport", "cgroup_sock", "xdp", "raw_tracepoint_writable", "lwt_out", "cgroup_sock_addr", "socket_filter", "sk_skb", "lwt_seg6local", "sock_ops", "tracepoint", "kprobe", "cgroup_skb", "cgroup_device", "sched_act", "perf_event", "cgroup_sysctl", "raw_tracepoint", "flow_dissector", "sched_cls"], "source": ["int test (void *ctx)\n", "{\n", "    uint64_t test;\n", "    bpf_ringbuf_output (&ring_buffer, &test, sizeof (test), 0);\n", "    return 0;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}, {"description": " ebpf_map is a structure which stores following fields: type, key_size, value_size, max_entries, map_flags, inner_map_idx, numa_node.\n                       ring_buffer is a eBPF ring buffer type map that contains upto 256*1024 entries.\n                       bpf_ringbuf_output(&ring_buffer, &test, sizeof(test), 0) copies 8 bytes (i.e. sizeof(test)) from variable test into a ring buffer\n                       ring_buffer. It will return 0 on successfully copying the data else returns 1 on failure.", "author": "Utkalika Satapathy", "authorEmail": "utkalika.satapathy01@gmail.com", "date": ""}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 1}, "27": {"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "cilium", "Return Type": "u32", "Description": "Get a pseudo-random number. From a security point of view , this helper uses its own pseudo-random internal state , and cannot be used to infer the seed of other random functions in the kernel. However , it is essential to note that the generator used by the helper is not cryptographically secure. ", "Return": " A random 32-bit unsigned value.", "Function Name": "get_prandom_u32", "Input Params": ["{Type: voi ,Var: void}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}]}], "helperCallParams": {}, "startLine": 18, "endLine": 58, "File": "/home/palani/github/palanik1/ebpf-projects-annotations/projects/ebpf-samples/original_source/packet_access.c", "funcName": "test_packet_access", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": " Copyright (c) Prevail Verifier contributors."}, {"start_line": 2, "end_line": 2, "text": " SPDX-License-Identifier: MIT"}, {"start_line": 26, "end_line": 26, "text": " We now do two code paths that should have identical results."}, {"start_line": 32, "end_line": 44, "text": " The above code results in the following assembly:         *            r0 <<= 2         *            r0 &= 60         *            r1 = *(u32 *)(r6 + 0)         *            r1 += r0     In the ELSE clause below, this becomes         *                         \"r0 += r1\" then \"r1 = r0\".         *            r0 = 1         *            r2 = r1         *            r2 += 4         *            r3 = *(u32 *)(r6 + 4)         *            if r2 > r3 goto +13         *            r0 = *(u32 *)(r1 + 0)         "}, {"start_line": 49, "end_line": 49, "text": " In the IF clause above, these two instructions"}, {"start_line": 50, "end_line": 50, "text": " are \"r1 += r0\"."}], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *ctx"], "output": "int", "helper": ["get_prandom_u32"], "compatibleHookpoints": ["lwt_in", "sk_msg", "lwt_xmit", "sk_reuseport", "cgroup_sock", "xdp", "raw_tracepoint_writable", "lwt_out", "cgroup_sock_addr", "socket_filter", "sk_skb", "lwt_seg6local", "sock_ops", "tracepoint", "kprobe", "cgroup_skb", "sched_act", "perf_event", "raw_tracepoint", "flow_dissector", "sched_cls"], "source": ["int test_packet_access (struct xdp_md *ctx)\n", "{\n", "    uint32_t rand32 = get_prandom_u32 ();\n", "    void *data_end = (void *) (long) ctx->data_end;\n", "    void *data = (void *) (long) ctx->data;\n", "    int offset = (rand32 & 0x0F) * 4;\n", "    int *ptr;\n", "    if (rand32 & 1) {\n", "        if (data + offset + sizeof (int) > data_end)\n", "            return 1;\n", "        ptr = offset + data;\n", "        return *(int*) ptr;\n", "    }\n", "    else {\n", "        asm volatile (\"r0 <<= 2\\n\"\n", "            \"r0 &= 60\\n\"\n", "            \"r1 = *(u32 *)(r6 + 0)\\n\"\n", "            \"r0 += r1\\n\"\n", "            \"r1 = r0\\n\"\n", "            \"r0 = 1\\n\"\n", "            \"r2 = r1\\n\"\n", "            \"r2 += 4\\n\"\n", "            \"r3 = *(u32 *)(r6 + 4)\\n\"\n", "            \"if r2 > r3 goto +1\\n\"\n", "            \"r0 = *(u32 *)(r1 + 0)\\n\"\n", "            );\n", "    }\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}, {"description": "The function checks whether the compiler generated assembly matches the handcrafted one.\n                      A structure xdp_md is created to store data, data_end, data_meta, _1, _2, _3 of type uint32_t\n                      This struct xdp_md is passed as argument to the function.\n                      A random number is generated and saved in rand32 variable.\n                      a offset is calulated and it is checked whether the data plus the offset is less than the data_end or not,\n                      if it is less than data_end, 1 is returned and ptr value is updated to offset+data i.e. points to the next data.\n                      Else the compiler executes a set of assembly as it is.", "author": "Utkalika Satapathy", "authorEmail": "utkalika.satapathy01@gmail.com", "date": "02.02.2023"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 1}}}
