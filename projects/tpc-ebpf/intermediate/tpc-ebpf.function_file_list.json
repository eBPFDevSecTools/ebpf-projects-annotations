{
  "inner_loop": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 16,
      "endLine": 41,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/tpc-ebpf/original_source/ebpf_timeout_changer.c",
      "funcName": "inner_loop",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 5,
          "text": "  * This program is free software; you can redistribute it and/or * modify it under the terms of version 2 of the GNU General Public * License as published by the Free Software Foundation. "
        },
        {
          "start_line": 23,
          "end_line": 23,
          "text": " Wrong SRH ID -> might be inconsistent state, so skip"
        },
        {
          "start_line": 24,
          "end_line": 24,
          "text": " Not a valid SRH for the destination"
        },
        {
          "start_line": 25,
          "end_line": 25,
          "text": " Same SRH"
        },
        {
          "start_line": 26,
          "end_line": 26,
          "text": " 1"
        },
        {
          "start_line": 27,
          "end_line": 27,
          "text": "bpf_debug(\"Cannot find the SRH entry indexed at %d at a dest entry\\n\", i);"
        },
        {
          "start_line": 31,
          "end_line": 31,
          "text": " 1"
        },
        {
          "start_line": 32,
          "end_line": 32,
          "text": "bpf_debug(\"SRH entry indexed at %d by the dest entry is invalid\\n\", i);"
        },
        {
          "start_line": 33,
          "end_line": 33,
          "text": " Not a valid SRH for the destination"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "__u32 srh_id",
        " struct dst_infos *dst_infos"
      ],
      "output": "static__u32",
      "helper": [],
      "compatibleHookpoints": [
        "kprobe",
        "sk_reuseport",
        "sched_cls",
        "sk_skb",
        "sched_act",
        "cgroup_sysctl",
        "socket_filter",
        "tracepoint",
        "xdp",
        "cgroup_sock_addr",
        "flow_dissector",
        "raw_tracepoint_writable",
        "perf_event",
        "sock_ops",
        "cgroup_skb",
        "lwt_seg6local",
        "cgroup_device",
        "sk_msg",
        "cgroup_sock",
        "lwt_in",
        "raw_tracepoint",
        "lwt_out",
        "lwt_xmit"
      ],
      "source": [
        "static __u32 inner_loop (__u32 srh_id, struct dst_infos *dst_infos)\n",
        "{\n",
        "\n",
        "#pragma clang loop unroll(full)\n",
        "    for (__u32 i = 0; i <= MAX_SRH_BY_DEST - 1; i++) {\n",
        "        if (!dst_infos)\n",
        "            continue;\n",
        "        struct srh_record_t *srh_record = &dst_infos->srhs[i];\n",
        "        if (!srh_record || !srh_record->srh.type) {\n",
        "            continue;\n",
        "        }\n",
        "        if (!srh_record->is_valid) {\n",
        "            continue;\n",
        "        }\n",
        "        if (i > srh_id) {\n",
        "            return i;\n",
        "        }\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 16,
      "endLine": 41,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/tpc-ebpf/original_source/ebpf_n_rto_changer.c",
      "funcName": "inner_loop",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 5,
          "text": "  * This program is free software; you can redistribute it and/or * modify it under the terms of version 2 of the GNU General Public * License as published by the Free Software Foundation. "
        },
        {
          "start_line": 23,
          "end_line": 23,
          "text": " Wrong SRH ID -> might be inconsistent state, so skip"
        },
        {
          "start_line": 24,
          "end_line": 24,
          "text": " Not a valid SRH for the destination"
        },
        {
          "start_line": 25,
          "end_line": 25,
          "text": " Same SRH"
        },
        {
          "start_line": 26,
          "end_line": 26,
          "text": " 1"
        },
        {
          "start_line": 27,
          "end_line": 27,
          "text": "bpf_debug(\"Cannot find the SRH entry indexed at %d at a dest entry\\n\", i);"
        },
        {
          "start_line": 31,
          "end_line": 31,
          "text": " 1"
        },
        {
          "start_line": 32,
          "end_line": 32,
          "text": "bpf_debug(\"SRH entry indexed at %d by the dest entry is invalid\\n\", i);"
        },
        {
          "start_line": 33,
          "end_line": 33,
          "text": " Not a valid SRH for the destination"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "__u32 srh_id",
        " struct dst_infos *dst_infos"
      ],
      "output": "static__u32",
      "helper": [],
      "compatibleHookpoints": [
        "kprobe",
        "sk_reuseport",
        "sched_cls",
        "sk_skb",
        "sched_act",
        "cgroup_sysctl",
        "socket_filter",
        "tracepoint",
        "xdp",
        "cgroup_sock_addr",
        "flow_dissector",
        "raw_tracepoint_writable",
        "perf_event",
        "sock_ops",
        "cgroup_skb",
        "lwt_seg6local",
        "cgroup_device",
        "sk_msg",
        "cgroup_sock",
        "lwt_in",
        "raw_tracepoint",
        "lwt_out",
        "lwt_xmit"
      ],
      "source": [
        "static __u32 inner_loop (__u32 srh_id, struct dst_infos *dst_infos)\n",
        "{\n",
        "\n",
        "#pragma clang loop unroll(full)\n",
        "    for (__u32 i = 0; i <= MAX_SRH_BY_DEST - 1; i++) {\n",
        "        if (!dst_infos)\n",
        "            continue;\n",
        "        struct srh_record_t *srh_record = &dst_infos->srhs[i];\n",
        "        if (!srh_record || !srh_record->srh.type) {\n",
        "            continue;\n",
        "        }\n",
        "        if (!srh_record->is_valid) {\n",
        "            continue;\n",
        "        }\n",
        "        if (i > srh_id) {\n",
        "            return i;\n",
        "        }\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "move_path": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        },
        {
          "capability": "update_pkt",
          "update_pkt": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Emulate a call to setsockopt() on the socket associated to <[ bpf_socket ]>(IP: 0) , which must be a full socket. The <[ level ]>(IP: 1) at which the option resides and the name <[ optname ]>(IP: 2) of the option must be specified , see setsockopt(2) for more information. The option value of length <[ optlen ]>(IP: 4) is pointed by optval. This helper actually implements a subset of setsockopt(). It supports the following levels: \u00b7 SOL_SOCKET , which supports the following optnames: SO_RCVBUF , SO_SNDBUF , SO_MAX_PACING_RATE , SO_PRIORITY , SO_RCVLOWAT , SO_MARK. \u00b7 IPPROTO_TCP , which supports the following optnames: TCP_CONGESTION , TCP_BPF_IW , TCP_BPF_SNDCWND_CLAMP. \u00b7 IPPROTO_IP , which supports <[ optname ]>(IP: 2) IP_TOS. \u00b7 IPPROTO_IPV6 , which supports <[ optname ]>(IP: 2) IPV6_TCLASS. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_setsockopt",
              "Input Params": [
                "{Type: struct bpf_sock_ops ,Var: *bpf_socket}",
                "{Type:  int ,Var: level}",
                "{Type:  int ,Var: optname}",
                "{Type:  char ,Var: *optval}",
                "{Type:  int ,Var: optlen}"
              ],
              "compatible_hookpoints": [
                "sock_ops"
              ],
              "capabilities": [
                "update_pkt"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 43,
      "endLine": 76,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/tpc-ebpf/original_source/ebpf_timeout_changer.c",
      "funcName": "move_path",
      "developer_inline_comments": [
        {
          "start_line": 52,
          "end_line": 52,
          "text": " Check needed to avoid verifier complaining about unbounded access"
        },
        {
          "start_line": 53,
          "end_line": 53,
          "text": " The check needs to be placed very near the actual line"
        },
        {
          "start_line": 60,
          "end_line": 60,
          "text": " Reset congestion control"
        },
        {
          "start_line": 61,
          "end_line": 61,
          "text": " TODO This removes the estimation of the RTT and puts a timeout of 1 seconds by default"
        },
        {
          "start_line": 62,
          "end_line": 62,
          "text": " It will do nothing if there is no actual change..."
        },
        {
          "start_line": 63,
          "end_line": 63,
          "text": " The problem is that it does not reset the retransmission timeout..."
        },
        {
          "start_line": 64,
          "end_line": 64,
          "text": "rv = bpf_getsockopt(skops, SOL_TCP, TCP_CONGESTION, cc, sizeof(cc));"
        },
        {
          "start_line": 65,
          "end_line": 65,
          "text": "if (!rv) {  TODO Handle case with reno as base congestion control"
        },
        {
          "start_line": 66,
          "end_line": 66,
          "text": "\trv = bpf_setsockopt(skops, SOL_TCP, TCP_CONGESTION, tmp_cc, sizeof(tmp_cc));"
        },
        {
          "start_line": 67,
          "end_line": 67,
          "text": "\trv = bpf_setsockopt(skops, SOL_TCP, TCP_CONGESTION, cc, sizeof(cc));"
        },
        {
          "start_line": 68,
          "end_line": 68,
          "text": "}"
        }
      ],
      "updateMaps": [],
      "readMaps": [
        " dst_map"
      ],
      "input": [
        "struct bpf_elf_map *dst_map",
        " void *id",
        " __u32 key",
        " struct bpf_sock_ops *skops"
      ],
      "output": "staticint",
      "helper": [
        "bpf_map_lookup_elem",
        "bpf_setsockopt"
      ],
      "compatibleHookpoints": [
        "sock_ops"
      ],
      "source": [
        "static int move_path (struct bpf_elf_map *dst_map, void *id, __u32 key, struct bpf_sock_ops *skops)\n",
        "{\n",
        "    int val = 1;\n",
        "    int rv = 1;\n",
        "    char cc [20];\n",
        "    char tmp_cc [5] = \"reno\";\n",
        "    struct dst_infos *dst_infos = (void *) bpf_map_lookup_elem (dst_map, id);\n",
        "    if (dst_infos) {\n",
        "        struct ip6_srh_t *srh = NULL;\n",
        "        if (key >= 0 && key < MAX_SRH_BY_DEST) {\n",
        "            srh = &(dst_infos->srhs[key].srh);\n",
        "            rv = bpf_setsockopt (skops, SOL_IPV6, IPV6_RTHDR, srh, sizeof (* srh));\n",
        "        }\n",
        "        if (!rv) {\n",
        "            if (!rv) {\n",
        "                rv = bpf_setsockopt (skops, SOL_TCP, TCP_PATH_CHANGED, & val, sizeof (val));\n",
        "                bpf_debug (\"Set Path changed - returned %u\\n\", rv);\n",
        "            }\n",
        "        }\n",
        "    }\n",
        "    return !!rv;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    },
    {
      "capabilities": [
        {
          "capability": "update_pkt",
          "update_pkt": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Emulate a call to setsockopt() on the socket associated to <[ bpf_socket ]>(IP: 0) , which must be a full socket. The <[ level ]>(IP: 1) at which the option resides and the name <[ optname ]>(IP: 2) of the option must be specified , see setsockopt(2) for more information. The option value of length <[ optlen ]>(IP: 4) is pointed by optval. This helper actually implements a subset of setsockopt(). It supports the following levels: \u00b7 SOL_SOCKET , which supports the following optnames: SO_RCVBUF , SO_SNDBUF , SO_MAX_PACING_RATE , SO_PRIORITY , SO_RCVLOWAT , SO_MARK. \u00b7 IPPROTO_TCP , which supports the following optnames: TCP_CONGESTION , TCP_BPF_IW , TCP_BPF_SNDCWND_CLAMP. \u00b7 IPPROTO_IP , which supports <[ optname ]>(IP: 2) IP_TOS. \u00b7 IPPROTO_IPV6 , which supports <[ optname ]>(IP: 2) IPV6_TCLASS. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_setsockopt",
              "Input Params": [
                "{Type: struct bpf_sock_ops ,Var: *bpf_socket}",
                "{Type:  int ,Var: level}",
                "{Type:  int ,Var: optname}",
                "{Type:  char ,Var: *optval}",
                "{Type:  int ,Var: optlen}"
              ],
              "compatible_hookpoints": [
                "sock_ops"
              ],
              "capabilities": [
                "update_pkt"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 16,
      "endLine": 29,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/tpc-ebpf/original_source/ebpf_exp3_lowest_delay.c",
      "funcName": "move_path",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 5,
          "text": "  * This program is free software; you can redistribute it and/or * modify it under the terms of version 2 of the GNU General Public * License as published by the Free Software Foundation. "
        },
        {
          "start_line": 21,
          "end_line": 21,
          "text": " Check needed to avoid verifier complaining about unbounded access"
        },
        {
          "start_line": 22,
          "end_line": 22,
          "text": " The check needs to be placed very near the actual line"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct dst_infos *dst_infos",
        " __u32 key",
        " struct bpf_sock_ops *skops"
      ],
      "output": "static__inlineint",
      "helper": [
        "bpf_setsockopt"
      ],
      "compatibleHookpoints": [
        "sock_ops"
      ],
      "source": [
        "static __inline int move_path (struct dst_infos *dst_infos, __u32 key, struct bpf_sock_ops *skops)\n",
        "{\n",
        "    int rv = 1;\n",
        "    char cc [20];\n",
        "    struct ip6_srh_t *srh = NULL;\n",
        "    if (key >= 0 && key < MAX_SRH_BY_DEST) {\n",
        "        srh = &(dst_infos->srhs[key].srh);\n",
        "        rv = bpf_setsockopt (skops, SOL_IPV6, IPV6_RTHDR, srh, sizeof (* srh));\n",
        "        bpf_debug (\"bpf_setsockopt !!!!! %d\\n\", rv);\n",
        "    }\n",
        "    return !!rv;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    },
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        },
        {
          "capability": "update_pkt",
          "update_pkt": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Emulate a call to setsockopt() on the socket associated to <[ bpf_socket ]>(IP: 0) , which must be a full socket. The <[ level ]>(IP: 1) at which the option resides and the name <[ optname ]>(IP: 2) of the option must be specified , see setsockopt(2) for more information. The option value of length <[ optlen ]>(IP: 4) is pointed by optval. This helper actually implements a subset of setsockopt(). It supports the following levels: \u00b7 SOL_SOCKET , which supports the following optnames: SO_RCVBUF , SO_SNDBUF , SO_MAX_PACING_RATE , SO_PRIORITY , SO_RCVLOWAT , SO_MARK. \u00b7 IPPROTO_TCP , which supports the following optnames: TCP_CONGESTION , TCP_BPF_IW , TCP_BPF_SNDCWND_CLAMP. \u00b7 IPPROTO_IP , which supports <[ optname ]>(IP: 2) IP_TOS. \u00b7 IPPROTO_IPV6 , which supports <[ optname ]>(IP: 2) IPV6_TCLASS. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_setsockopt",
              "Input Params": [
                "{Type: struct bpf_sock_ops ,Var: *bpf_socket}",
                "{Type:  int ,Var: level}",
                "{Type:  int ,Var: optname}",
                "{Type:  char ,Var: *optval}",
                "{Type:  int ,Var: optlen}"
              ],
              "compatible_hookpoints": [
                "sock_ops"
              ],
              "capabilities": [
                "update_pkt"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 15,
      "endLine": 29,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/tpc-ebpf/original_source/ebpf_use_second_path.c",
      "funcName": "move_path",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 5,
          "text": "  * This program is free software; you can redistribute it and/or * modify it under the terms of version 2 of the GNU General Public * License as published by the Free Software Foundation. "
        },
        {
          "start_line": 21,
          "end_line": 21,
          "text": " Check needed to avoid verifier complaining about unbounded access"
        },
        {
          "start_line": 22,
          "end_line": 22,
          "text": " The check needs to be placed very near the actual line"
        }
      ],
      "updateMaps": [],
      "readMaps": [
        " dst_map"
      ],
      "input": [
        "struct bpf_elf_map *dst_map",
        " void *id",
        " __u32 key",
        " struct bpf_sock_ops *skops"
      ],
      "output": "staticint",
      "helper": [
        "bpf_map_lookup_elem",
        "bpf_setsockopt"
      ],
      "compatibleHookpoints": [
        "sock_ops"
      ],
      "source": [
        "static int move_path (struct bpf_elf_map *dst_map, void *id, __u32 key, struct bpf_sock_ops *skops)\n",
        "{\n",
        "    int rv = 1;\n",
        "    struct dst_infos *dst_infos = (void *) bpf_map_lookup_elem (dst_map, id);\n",
        "    if (dst_infos) {\n",
        "        struct ip6_srh_t *srh = NULL;\n",
        "        if (key >= 0 && key < MAX_SRH_BY_DEST) {\n",
        "            srh = &(dst_infos->srhs[key].srh);\n",
        "            rv = bpf_setsockopt (skops, SOL_IPV6, IPV6_RTHDR, srh, sizeof (* srh));\n",
        "        }\n",
        "    }\n",
        "    return !!rv;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    },
    {
      "capabilities": [
        {
          "capability": "update_pkt",
          "update_pkt": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Emulate a call to setsockopt() on the socket associated to <[ bpf_socket ]>(IP: 0) , which must be a full socket. The <[ level ]>(IP: 1) at which the option resides and the name <[ optname ]>(IP: 2) of the option must be specified , see setsockopt(2) for more information. The option value of length <[ optlen ]>(IP: 4) is pointed by optval. This helper actually implements a subset of setsockopt(). It supports the following levels: \u00b7 SOL_SOCKET , which supports the following optnames: SO_RCVBUF , SO_SNDBUF , SO_MAX_PACING_RATE , SO_PRIORITY , SO_RCVLOWAT , SO_MARK. \u00b7 IPPROTO_TCP , which supports the following optnames: TCP_CONGESTION , TCP_BPF_IW , TCP_BPF_SNDCWND_CLAMP. \u00b7 IPPROTO_IP , which supports <[ optname ]>(IP: 2) IP_TOS. \u00b7 IPPROTO_IPV6 , which supports <[ optname ]>(IP: 2) IPV6_TCLASS. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_setsockopt",
              "Input Params": [
                "{Type: struct bpf_sock_ops ,Var: *bpf_socket}",
                "{Type:  int ,Var: level}",
                "{Type:  int ,Var: optname}",
                "{Type:  char ,Var: *optval}",
                "{Type:  int ,Var: optlen}"
              ],
              "compatible_hookpoints": [
                "sock_ops"
              ],
              "capabilities": [
                "update_pkt"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 15,
      "endLine": 28,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/tpc-ebpf/original_source/ebpf_reverse_srh.c",
      "funcName": "move_path",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 5,
          "text": "  * This program is free software; you can redistribute it and/or * modify it under the terms of version 2 of the GNU General Public * License as published by the Free Software Foundation. "
        },
        {
          "start_line": 17,
          "end_line": 17,
          "text": " TODO Useful ?"
        },
        {
          "start_line": 19,
          "end_line": 19,
          "text": "bpf_debug(\"bpf_setsockopt !!!!! %d\\n\", rv);"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct ip6_srh_t *srh",
        " struct bpf_sock_ops *skops"
      ],
      "output": "staticint",
      "helper": [
        "bpf_setsockopt"
      ],
      "compatibleHookpoints": [
        "sock_ops"
      ],
      "source": [
        "static int move_path (struct ip6_srh_t *srh, struct bpf_sock_ops *skops)\n",
        "{\n",
        "    srh->nexthdr = 0;\n",
        "    int rv = bpf_setsockopt (skops, SOL_IPV6, IPV6_RTHDR, srh, sizeof (* srh));\n",
        "    if (rv) {\n",
        "        bpf_debug (\"optval %p - optlen %llu\\n\", srh, sizeof (*srh));\n",
        "        bpf_debug (\"optlen %llu - header_len %u\\n\", sizeof (*srh), (srh->hdrlen + 1) << 3);\n",
        "        bpf_debug (\"next extension %u - rt_type %u\\n\", srh->nexthdr, srh->type);\n",
        "        bpf_debug (\"first segment %u - segments_left %u\\n\", srh->first_segment, srh->segments_left);\n",
        "        bpf_debug (\"max_last_entry %u\\n\", (srh->hdrlen / 2) - 1);\n",
        "    }\n",
        "    return !!rv;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    },
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        },
        {
          "capability": "update_pkt",
          "update_pkt": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Emulate a call to setsockopt() on the socket associated to <[ bpf_socket ]>(IP: 0) , which must be a full socket. The <[ level ]>(IP: 1) at which the option resides and the name <[ optname ]>(IP: 2) of the option must be specified , see setsockopt(2) for more information. The option value of length <[ optlen ]>(IP: 4) is pointed by optval. This helper actually implements a subset of setsockopt(). It supports the following levels: \u00b7 SOL_SOCKET , which supports the following optnames: SO_RCVBUF , SO_SNDBUF , SO_MAX_PACING_RATE , SO_PRIORITY , SO_RCVLOWAT , SO_MARK. \u00b7 IPPROTO_TCP , which supports the following optnames: TCP_CONGESTION , TCP_BPF_IW , TCP_BPF_SNDCWND_CLAMP. \u00b7 IPPROTO_IP , which supports <[ optname ]>(IP: 2) IP_TOS. \u00b7 IPPROTO_IPV6 , which supports <[ optname ]>(IP: 2) IPV6_TCLASS. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_setsockopt",
              "Input Params": [
                "{Type: struct bpf_sock_ops ,Var: *bpf_socket}",
                "{Type:  int ,Var: level}",
                "{Type:  int ,Var: optname}",
                "{Type:  char ,Var: *optval}",
                "{Type:  int ,Var: optlen}"
              ],
              "compatible_hookpoints": [
                "sock_ops"
              ],
              "capabilities": [
                "update_pkt"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 43,
      "endLine": 76,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/tpc-ebpf/original_source/ebpf_n_rto_changer.c",
      "funcName": "move_path",
      "developer_inline_comments": [
        {
          "start_line": 52,
          "end_line": 52,
          "text": " Check needed to avoid verifier complaining about unbounded access"
        },
        {
          "start_line": 53,
          "end_line": 53,
          "text": " The check needs to be placed very near the actual line"
        },
        {
          "start_line": 60,
          "end_line": 60,
          "text": " Reset congestion control"
        },
        {
          "start_line": 61,
          "end_line": 61,
          "text": " TODO This removes the estimation of the RTT and puts a timeout of 1 seconds by default"
        },
        {
          "start_line": 62,
          "end_line": 62,
          "text": " It will do nothing if there is no actual change..."
        },
        {
          "start_line": 63,
          "end_line": 63,
          "text": " The problem is that it does not reset the retransmission timeout..."
        },
        {
          "start_line": 64,
          "end_line": 64,
          "text": "rv = bpf_getsockopt(skops, SOL_TCP, TCP_CONGESTION, cc, sizeof(cc));"
        },
        {
          "start_line": 65,
          "end_line": 65,
          "text": "if (!rv) {  TODO Handle case with reno as base congestion control"
        },
        {
          "start_line": 66,
          "end_line": 66,
          "text": "\trv = bpf_setsockopt(skops, SOL_TCP, TCP_CONGESTION, tmp_cc, sizeof(tmp_cc));"
        },
        {
          "start_line": 67,
          "end_line": 67,
          "text": "\trv = bpf_setsockopt(skops, SOL_TCP, TCP_CONGESTION, cc, sizeof(cc));"
        },
        {
          "start_line": 68,
          "end_line": 68,
          "text": "}"
        },
        {
          "start_line": 71,
          "end_line": 71,
          "text": "bpf_debug(\"Set Path changed - returned %u\\n\", rv);"
        }
      ],
      "updateMaps": [],
      "readMaps": [
        " dst_map"
      ],
      "input": [
        "struct bpf_elf_map *dst_map",
        " void *id",
        " __u32 key",
        " struct bpf_sock_ops *skops"
      ],
      "output": "staticint",
      "helper": [
        "bpf_map_lookup_elem",
        "bpf_setsockopt"
      ],
      "compatibleHookpoints": [
        "sock_ops"
      ],
      "source": [
        "static int move_path (struct bpf_elf_map *dst_map, void *id, __u32 key, struct bpf_sock_ops *skops)\n",
        "{\n",
        "    int val = 1;\n",
        "    int rv = 1;\n",
        "    char cc [20];\n",
        "    char tmp_cc [5] = \"reno\";\n",
        "    struct dst_infos *dst_infos = (void *) bpf_map_lookup_elem (dst_map, id);\n",
        "    if (dst_infos) {\n",
        "        struct ip6_srh_t *srh = NULL;\n",
        "        if (key >= 0 && key < MAX_SRH_BY_DEST) {\n",
        "            srh = &(dst_infos->srhs[key].srh);\n",
        "            rv = bpf_setsockopt (skops, SOL_IPV6, IPV6_RTHDR, srh, sizeof (* srh));\n",
        "        }\n",
        "        if (!rv) {\n",
        "            if (!rv) {\n",
        "                rv = bpf_setsockopt (skops, SOL_TCP, TCP_PATH_CHANGED, & val, sizeof (val));\n",
        "            }\n",
        "        }\n",
        "    }\n",
        "    return !!rv;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    },
    {
      "capabilities": [
        {
          "capability": "update_pkt",
          "update_pkt": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Emulate a call to setsockopt() on the socket associated to <[ bpf_socket ]>(IP: 0) , which must be a full socket. The <[ level ]>(IP: 1) at which the option resides and the name <[ optname ]>(IP: 2) of the option must be specified , see setsockopt(2) for more information. The option value of length <[ optlen ]>(IP: 4) is pointed by optval. This helper actually implements a subset of setsockopt(). It supports the following levels: \u00b7 SOL_SOCKET , which supports the following optnames: SO_RCVBUF , SO_SNDBUF , SO_MAX_PACING_RATE , SO_PRIORITY , SO_RCVLOWAT , SO_MARK. \u00b7 IPPROTO_TCP , which supports the following optnames: TCP_CONGESTION , TCP_BPF_IW , TCP_BPF_SNDCWND_CLAMP. \u00b7 IPPROTO_IP , which supports <[ optname ]>(IP: 2) IP_TOS. \u00b7 IPPROTO_IPV6 , which supports <[ optname ]>(IP: 2) IPV6_TCLASS. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_setsockopt",
              "Input Params": [
                "{Type: struct bpf_sock_ops ,Var: *bpf_socket}",
                "{Type:  int ,Var: level}",
                "{Type:  int ,Var: optname}",
                "{Type:  char ,Var: *optval}",
                "{Type:  int ,Var: optlen}"
              ],
              "compatible_hookpoints": [
                "sock_ops"
              ],
              "capabilities": [
                "update_pkt"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 16,
      "endLine": 29,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/tpc-ebpf/original_source/ebpf_exp3_lowest_completion.c",
      "funcName": "move_path",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 5,
          "text": "  * This program is free software; you can redistribute it and/or * modify it under the terms of version 2 of the GNU General Public * License as published by the Free Software Foundation. "
        },
        {
          "start_line": 21,
          "end_line": 21,
          "text": " Check needed to avoid verifier complaining about unbounded access"
        },
        {
          "start_line": 22,
          "end_line": 22,
          "text": " The check needs to be placed very near the actual line"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct dst_infos *dst_infos",
        " __u32 key",
        " struct bpf_sock_ops *skops"
      ],
      "output": "static__inlineint",
      "helper": [
        "bpf_setsockopt"
      ],
      "compatibleHookpoints": [
        "sock_ops"
      ],
      "source": [
        "static __inline int move_path (struct dst_infos *dst_infos, __u32 key, struct bpf_sock_ops *skops)\n",
        "{\n",
        "    int rv = 1;\n",
        "    char cc [20];\n",
        "    struct ip6_srh_t *srh = NULL;\n",
        "    if (key >= 0 && key < MAX_SRH_BY_DEST) {\n",
        "        srh = &(dst_infos->srhs[key].srh);\n",
        "        rv = bpf_setsockopt (skops, SOL_IPV6, IPV6_RTHDR, srh, sizeof (* srh));\n",
        "        bpf_debug (\"bpf_setsockopt !!!!! %d\\n\", rv);\n",
        "    }\n",
        "    return !!rv;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "create_new_flow_infos": [
    {
      "capabilities": [
        {
          "capability": "map_update",
          "map_update": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_map_update_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}",
                "{Type:  const void ,Var: *value}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_update"
              ]
            }
          ]
        },
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 78,
      "endLine": 92,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/tpc-ebpf/original_source/ebpf_timeout_changer.c",
      "funcName": "create_new_flow_infos",
      "developer_inline_comments": [
        {
          "start_line": 84,
          "end_line": 84,
          "text": " Timers"
        },
        {
          "start_line": 88,
          "end_line": 88,
          "text": " Listening connections"
        },
        {
          "start_line": 90,
          "end_line": 90,
          "text": " Insert flow to map"
        }
      ],
      "updateMaps": [
        " c_map"
      ],
      "readMaps": [
        " dt_map"
      ],
      "input": [
        "struct bpf_elf_map *dt_map",
        " struct bpf_elf_map *c_map",
        " struct flow_tuple *flow_id",
        " __u64 cur_time",
        " struct bpf_sock_ops *skops"
      ],
      "output": "staticint",
      "helper": [
        "bpf_map_update_elem",
        "bpf_map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "kprobe",
        "sk_reuseport",
        "sched_cls",
        "sk_skb",
        "sched_act",
        "cgroup_sysctl",
        "tracepoint",
        "socket_filter",
        "xdp",
        "cgroup_sock_addr",
        "flow_dissector",
        "raw_tracepoint_writable",
        "perf_event",
        "sock_ops",
        "cgroup_skb",
        "lwt_seg6local",
        "cgroup_device",
        "sk_msg",
        "cgroup_sock",
        "lwt_in",
        "raw_tracepoint",
        "lwt_out",
        "lwt_xmit"
      ],
      "source": [
        "static int create_new_flow_infos (struct bpf_elf_map *dt_map, struct bpf_elf_map *c_map, struct flow_tuple *flow_id, __u64 cur_time, struct bpf_sock_ops *skops)\n",
        "{\n",
        "    struct flow_infos *flow_info;\n",
        "    struct flow_infos new_flow;\n",
        "    int rv = 0;\n",
        "    memset (&new_flow, 0, sizeof (struct flow_infos));\n",
        "    new_flow.last_move_time = cur_time;\n",
        "    struct dst_infos *dst_infos = (void *) bpf_map_lookup_elem (dt_map, flow_id->remote_addr);\n",
        "    if (!dst_infos)\n",
        "        return 1;\n",
        "    return bpf_map_update_elem (c_map, flow_id, &new_flow, BPF_ANY);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    },
    {
      "capabilities": [
        {
          "capability": "map_update",
          "map_update": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_map_update_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}",
                "{Type:  const void ,Var: *value}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_update"
              ]
            }
          ]
        },
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 31,
      "endLine": 52,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/tpc-ebpf/original_source/ebpf_exp3_lowest_delay.c",
      "funcName": "create_new_flow_infos",
      "developer_inline_comments": [
        {
          "start_line": 37,
          "end_line": 37,
          "text": "bpf_debug(\"flow not found, adding it\\n\");"
        },
        {
          "start_line": 42,
          "end_line": 42,
          "text": " Listening connections"
        },
        {
          "start_line": 44,
          "end_line": 44,
          "text": " Inititialize to 1 EXP3 weight and probabilities"
        },
        {
          "start_line": 50,
          "end_line": 50,
          "text": " Insert flow to map"
        }
      ],
      "updateMaps": [
        " c_map"
      ],
      "readMaps": [
        " dt_map"
      ],
      "input": [
        "struct bpf_elf_map *dt_map",
        " struct bpf_elf_map *c_map",
        " struct flow_tuple *flow_id",
        " __u64 cur_time",
        " struct bpf_sock_ops *skops"
      ],
      "output": "staticint",
      "helper": [
        "bpf_map_update_elem",
        "bpf_map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "kprobe",
        "sk_reuseport",
        "sched_cls",
        "sk_skb",
        "sched_act",
        "cgroup_sysctl",
        "tracepoint",
        "socket_filter",
        "xdp",
        "cgroup_sock_addr",
        "flow_dissector",
        "raw_tracepoint_writable",
        "perf_event",
        "sock_ops",
        "cgroup_skb",
        "lwt_seg6local",
        "cgroup_device",
        "sk_msg",
        "cgroup_sock",
        "lwt_in",
        "raw_tracepoint",
        "lwt_out",
        "lwt_xmit"
      ],
      "source": [
        "static int create_new_flow_infos (struct bpf_elf_map *dt_map, struct bpf_elf_map *c_map, struct flow_tuple *flow_id, __u64 cur_time, struct bpf_sock_ops *skops)\n",
        "{\n",
        "    struct flow_infos *flow_info;\n",
        "    struct flow_infos new_flow;\n",
        "    int rv = 0;\n",
        "    memset (&new_flow, 0, sizeof (struct flow_infos));\n",
        "    new_flow.exp3_last_number_actions = 1;\n",
        "    new_flow.exp3_start_snd_nxt = skops->snd_nxt;\n",
        "    struct dst_infos *dst_infos = (void *) bpf_map_lookup_elem (dt_map, flow_id->remote_addr);\n",
        "    if (!dst_infos)\n",
        "        return 1;\n",
        "    new_flow.exp3_last_probability.mantissa = LARGEST_BIT;\n",
        "    new_flow.exp3_last_probability.exponent = BIAS;\n",
        "    bpf_debug (\"HHHHHHHHH FLOW src port %u - dst port %u\\n\", flow_id->local_port, flow_id->remote_port);\n",
        "    return bpf_map_update_elem (c_map, flow_id, &new_flow, BPF_ANY);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    },
    {
      "capabilities": [
        {
          "capability": "map_update",
          "map_update": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_map_update_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}",
                "{Type:  const void ,Var: *value}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_update"
              ]
            }
          ]
        },
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 78,
      "endLine": 92,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/tpc-ebpf/original_source/ebpf_n_rto_changer.c",
      "funcName": "create_new_flow_infos",
      "developer_inline_comments": [
        {
          "start_line": 84,
          "end_line": 84,
          "text": " Timers"
        },
        {
          "start_line": 88,
          "end_line": 88,
          "text": " Listening connections"
        },
        {
          "start_line": 90,
          "end_line": 90,
          "text": " Insert flow to map"
        }
      ],
      "updateMaps": [
        " c_map"
      ],
      "readMaps": [
        " dt_map"
      ],
      "input": [
        "struct bpf_elf_map *dt_map",
        " struct bpf_elf_map *c_map",
        " struct flow_tuple *flow_id",
        " __u64 cur_time",
        " struct bpf_sock_ops *skops"
      ],
      "output": "staticint",
      "helper": [
        "bpf_map_update_elem",
        "bpf_map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "kprobe",
        "sk_reuseport",
        "sched_cls",
        "sk_skb",
        "sched_act",
        "cgroup_sysctl",
        "tracepoint",
        "socket_filter",
        "xdp",
        "cgroup_sock_addr",
        "flow_dissector",
        "raw_tracepoint_writable",
        "perf_event",
        "sock_ops",
        "cgroup_skb",
        "lwt_seg6local",
        "cgroup_device",
        "sk_msg",
        "cgroup_sock",
        "lwt_in",
        "raw_tracepoint",
        "lwt_out",
        "lwt_xmit"
      ],
      "source": [
        "static int create_new_flow_infos (struct bpf_elf_map *dt_map, struct bpf_elf_map *c_map, struct flow_tuple *flow_id, __u64 cur_time, struct bpf_sock_ops *skops)\n",
        "{\n",
        "    struct flow_infos *flow_info;\n",
        "    struct flow_infos new_flow;\n",
        "    int rv = 0;\n",
        "    memset (&new_flow, 0, sizeof (struct flow_infos));\n",
        "    new_flow.last_move_time = cur_time;\n",
        "    struct dst_infos *dst_infos = (void *) bpf_map_lookup_elem (dt_map, flow_id->remote_addr);\n",
        "    if (!dst_infos)\n",
        "        return 1;\n",
        "    return bpf_map_update_elem (c_map, flow_id, &new_flow, BPF_ANY);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    },
    {
      "capabilities": [
        {
          "capability": "map_update",
          "map_update": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_map_update_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}",
                "{Type:  const void ,Var: *value}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_update"
              ]
            }
          ]
        },
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 31,
      "endLine": 52,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/tpc-ebpf/original_source/ebpf_exp3_lowest_completion.c",
      "funcName": "create_new_flow_infos",
      "developer_inline_comments": [
        {
          "start_line": 37,
          "end_line": 37,
          "text": "bpf_debug(\"flow not found, adding it\\n\");"
        },
        {
          "start_line": 42,
          "end_line": 42,
          "text": " Listening connections"
        },
        {
          "start_line": 44,
          "end_line": 44,
          "text": " Inititialize to 1 EXP3 weight and probabilities"
        },
        {
          "start_line": 48,
          "end_line": 48,
          "text": "bpf_debug(\"HHHHHHHHH FLOW src port %u - dst port %u\\n\", flow_id->local_port, flow_id->remote_port);"
        },
        {
          "start_line": 50,
          "end_line": 50,
          "text": " Insert flow to map"
        }
      ],
      "updateMaps": [
        " c_map"
      ],
      "readMaps": [
        " dt_map"
      ],
      "input": [
        "struct bpf_elf_map *dt_map",
        " struct bpf_elf_map *c_map",
        " struct flow_tuple *flow_id",
        " __u64 cur_time",
        " struct bpf_sock_ops *skops"
      ],
      "output": "staticint",
      "helper": [
        "bpf_map_update_elem",
        "bpf_map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "kprobe",
        "sk_reuseport",
        "sched_cls",
        "sk_skb",
        "sched_act",
        "cgroup_sysctl",
        "tracepoint",
        "socket_filter",
        "xdp",
        "cgroup_sock_addr",
        "flow_dissector",
        "raw_tracepoint_writable",
        "perf_event",
        "sock_ops",
        "cgroup_skb",
        "lwt_seg6local",
        "cgroup_device",
        "sk_msg",
        "cgroup_sock",
        "lwt_in",
        "raw_tracepoint",
        "lwt_out",
        "lwt_xmit"
      ],
      "source": [
        "static int create_new_flow_infos (struct bpf_elf_map *dt_map, struct bpf_elf_map *c_map, struct flow_tuple *flow_id, __u64 cur_time, struct bpf_sock_ops *skops)\n",
        "{\n",
        "    struct flow_infos *flow_info;\n",
        "    struct flow_infos new_flow;\n",
        "    int rv = 0;\n",
        "    memset (&new_flow, 0, sizeof (struct flow_infos));\n",
        "    new_flow.exp3_last_number_actions = 1;\n",
        "    new_flow.exp3_start_snd_nxt = skops->snd_nxt;\n",
        "    struct dst_infos *dst_infos = (void *) bpf_map_lookup_elem (dt_map, flow_id->remote_addr);\n",
        "    if (!dst_infos)\n",
        "        return 1;\n",
        "    new_flow.exp3_last_probability.mantissa = LARGEST_BIT;\n",
        "    new_flow.exp3_last_probability.exponent = BIAS;\n",
        "    return bpf_map_update_elem (c_map, flow_id, &new_flow, BPF_ANY);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "handle_sockop": [
    {
      "capabilities": [
        {
          "capability": "map_update",
          "map_update": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_map_update_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}",
                "{Type:  const void ,Var: *value}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_update"
              ]
            }
          ]
        },
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        },
        {
          "capability": "read_sys_info",
          "read_sys_info": [
            {
              "Project": "bcc",
              "FunctionName": "bpf_ktime_get_ns",
              "Return Type": "u64",
              "Description": "u64 bpf_ktime_get_ns(void) Return: u64 number of nanoseconds. Starts at system boot time but stops during suspend. Examples in situ: \"https://github.com/iovisor/bcc/search?q=bpf_ktime_get_ns+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=bpf_ktime_get_ns+path%3Atools&type=Code search /tools ",
              "Return": "u64 number of nanoseconds",
              "Input Prameters": [],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 95,
      "endLine": 261,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/tpc-ebpf/original_source/ebpf_timeout_changer.c",
      "funcName": "handle_sockop",
      "developer_inline_comments": [
        {
          "start_line": 105,
          "end_line": 105,
          "text": " Only execute the prog for scp "
        },
        {
          "start_line": 116,
          "end_line": 116,
          "text": " XXX No break; here"
        },
        {
          "start_line": 117,
          "end_line": 117,
          "text": " Call EXP4 for servers (because setting the SRH for request socks does not work)"
        },
        {
          "start_line": 119,
          "end_line": 119,
          "text": " TODO Problem if listening connections => no destination defined !!!"
        },
        {
          "start_line": 120,
          "end_line": 120,
          "text": " TODO Also does not work on SYN+ACK request socks"
        },
        {
          "start_line": 145,
          "end_line": 145,
          "text": " Change in the state of the TCP CONNECTION"
        },
        {
          "start_line": 146,
          "end_line": 146,
          "text": " This flow is closed, cleanup the maps"
        },
        {
          "start_line": 152,
          "end_line": 152,
          "text": " Delete the flow from the flows map"
        },
        {
          "start_line": 153,
          "end_line": 153,
          "text": " take_snapshot(&stat_map, flow_info, &flow_id);"
        },
        {
          "start_line": 158,
          "end_line": 158,
          "text": " We reroute when there is a problem, so we need to know"
        },
        {
          "start_line": 159,
          "end_line": 159,
          "text": " when was the last time that everything was ok"
        },
        {
          "start_line": 160,
          "end_line": 160,
          "text": " TODO Check validity"
        },
        {
          "start_line": 172,
          "end_line": 172,
          "text": "bpf_debug(\"Duplicated ack to %u: nbr %llu for %llu - timer %llu\\n\", skops->remote_port, flow_info->retrans_count, skops->rcv_nxt, flow_info->last_move_time);"
        },
        {
          "start_line": 174,
          "end_line": 174,
          "text": " Data was acked so issue was solved"
        },
        {
          "start_line": 182,
          "end_line": 182,
          "text": " TODO This number needs to be strictly lower than the RTO trigger..."
        },
        {
          "start_line": 183,
          "end_line": 183,
          "text": " It can work with equal values if bytes were in flight at the failure but never greater values"
        },
        {
          "start_line": 188,
          "end_line": 188,
          "text": " This assumes that SRH 0 is always valid"
        },
        {
          "start_line": 191,
          "end_line": 191,
          "text": "bpf_debug(\"DUP ACK - Change path to %u\\n\", key_dup);"
        },
        {
          "start_line": 194,
          "end_line": 194,
          "text": " This can't be helped"
        },
        {
          "start_line": 199,
          "end_line": 199,
          "text": " Move to the next path"
        },
        {
          "start_line": 203,
          "end_line": 203,
          "text": " Update flow informations"
        },
        {
          "start_line": 207,
          "end_line": 207,
          "text": "bpf_debug(\"DUP ACK - Path changed to %u\\n\", key_dup);"
        },
        {
          "start_line": 216,
          "end_line": 216,
          "text": "bpf_debug(\"Retransmission timeout: nbr %llu for %llu - timer diff %llu\\n\", flow_info->retrans_count, skops->snd_una, cur_time - flow_info->last_move_time);"
        },
        {
          "start_line": 217,
          "end_line": 217,
          "text": "bpf_debug(\"Params: %u %u %u\\n\", skops->args[0], skops->args[1], skops->args[2]);"
        },
        {
          "start_line": 219,
          "end_line": 219,
          "text": " Data was acked so issue was solved"
        },
        {
          "start_line": 231,
          "end_line": 231,
          "text": " After three duplicated acknowledgments for the same data, switch path"
        },
        {
          "start_line": 233,
          "end_line": 233,
          "text": " This assumes that SRH 0 is always valid"
        },
        {
          "start_line": 236,
          "end_line": 236,
          "text": "bpf_debug(\"RTO - Change path to %u\\n\", key);"
        },
        {
          "start_line": 239,
          "end_line": 239,
          "text": " This can't be helped"
        },
        {
          "start_line": 244,
          "end_line": 244,
          "text": " Move to the next path"
        },
        {
          "start_line": 248,
          "end_line": 248,
          "text": " Update flow informations"
        },
        {
          "start_line": 252,
          "end_line": 252,
          "text": "bpf_debug(\"RTO - Path changed to %u\\n\", key);"
        }
      ],
      "updateMaps": [
        "  conn_map",
        " conn_map"
      ],
      "readMaps": [
        " conn_map",
        " dest_map"
      ],
      "input": [
        "struct bpf_sock_ops *skops"
      ],
      "output": "int",
      "helper": [
        "bpf_sock_ops_cb_flags_set",
        "bpf_map_delete_elem",
        "bpf_map_update_elem",
        "bpf_map_lookup_elem",
        "bpf_ktime_get_ns"
      ],
      "compatibleHookpoints": [
        "sock_ops"
      ],
      "source": [
        "int handle_sockop (struct bpf_sock_ops *skops)\n",
        "{\n",
        "    struct flow_infos *flow_info;\n",
        "    struct flow_tuple flow_id;\n",
        "    int rv = 0;\n",
        "    __u64 cur_time;\n",
        "    cur_time = bpf_ktime_get_ns ();\n",
        "    if (skops->family != AF_INET6) {\n",
        "        skops->reply = -1;\n",
        "        return 0;\n",
        "    }\n",
        "    get_flow_id_from_sock (&flow_id, skops);\n",
        "    flow_info = (void *) bpf_map_lookup_elem (&conn_map, &flow_id);\n",
        "    switch ((int) skops->op) {\n",
        "    case BPF_SOCK_OPS_TCP_CONNECT_CB :\n",
        "        bpf_debug (\"active SYN sent from %u\\n\", skops->local_port);\n",
        "    case BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB :\n",
        "        if (!flow_info) {\n",
        "            if (create_new_flow_infos (&dest_map, &conn_map, &flow_id, cur_time, skops)) {\n",
        "                return 1;\n",
        "            }\n",
        "            flow_info = (void *) bpf_map_lookup_elem (&conn_map, &flow_id);\n",
        "            if (!flow_info) {\n",
        "                return 1;\n",
        "            }\n",
        "        }\n",
        "        flow_info->last_move_time = cur_time;\n",
        "        flow_info->srh_id = 0;\n",
        "        move_path (&dest_map, flow_id.remote_addr, flow_info->srh_id, skops);\n",
        "        rv = bpf_map_update_elem (& conn_map, & flow_id, flow_info, BPF_ANY);\n",
        "        if (rv)\n",
        "            return 1;\n",
        "        take_snapshot (&stat_map, flow_info, &flow_id, skops->op);\n",
        "        bpf_sock_ops_cb_flags_set (skops, (BPF_SOCK_OPS_RETRANS_CB_FLAG | BPF_SOCK_OPS_RTO_CB_FLAG | BPF_SOCK_OPS_RTT_CB_FLAG | BPF_SOCK_OPS_STATE_CB_FLAG));\n",
        "        skops->reply = rv;\n",
        "        if (skops->op == BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB)\n",
        "            bpf_debug (\"passive established - timer %llu\\n\", flow_info->last_move_time);\n",
        "        break;\n",
        "    case BPF_SOCK_OPS_STATE_CB :\n",
        "        if (skops->args[1] == BPF_TCP_CLOSE || skops->args[1] == BPF_TCP_CLOSE_WAIT || skops->args[1] == BPF_TCP_CLOSING || skops->args[1] == BPF_TCP_FIN_WAIT1 || skops->args[1] == BPF_TCP_FIN_WAIT2) {\n",
        "            if (!flow_info) {\n",
        "                return 0;\n",
        "            }\n",
        "            bpf_debug (\"Close %u -> %u\\n\", skops->local_port, skops->remote_port);\n",
        "            bpf_map_delete_elem (&conn_map, &flow_id);\n",
        "        }\n",
        "        break;\n",
        "    case BPF_SOCK_OPS_RTT_CB :\n",
        "        if (!flow_info) {\n",
        "            return 1;\n",
        "        }\n",
        "        flow_info->last_move_time = cur_time;\n",
        "        rv = bpf_map_update_elem (& conn_map, & flow_id, flow_info, BPF_ANY);\n",
        "        break;\n",
        "    case BPF_SOCK_OPS_DUPACK :\n",
        "        if (!flow_info) {\n",
        "            return 1;\n",
        "        }\n",
        "        flow_info->retrans_count += 1;\n",
        "        if (flow_info->last_rcv_nxt != skops->rcv_nxt) {\n",
        "            flow_info->last_rcv_nxt = skops->rcv_nxt;\n",
        "            flow_info->retrans_count = 1;\n",
        "            rv = bpf_map_update_elem (& conn_map, & flow_id, flow_info, BPF_ANY);\n",
        "            break;\n",
        "        }\n",
        "        if (flow_info->retrans_count < 2) {\n",
        "            rv = bpf_map_update_elem (& conn_map, & flow_id, flow_info, BPF_ANY);\n",
        "            break;\n",
        "        }\n",
        "        __u32 key_dup = 0;\n",
        "        struct dst_infos *dst_infos_dup = (void *) bpf_map_lookup_elem (&dest_map, flow_id.remote_addr);\n",
        "        key_dup = inner_loop (flow_info -> srh_id, dst_infos_dup);\n",
        "        if (key_dup == flow_info->srh_id) {\n",
        "            rv = bpf_map_update_elem (& conn_map, & flow_id, flow_info, BPF_ANY);\n",
        "            break;\n",
        "        }\n",
        "        rv = move_path (& dest_map, flow_id.remote_addr, key_dup, skops);\n",
        "        if (!rv) {\n",
        "            bpf_debug (\"DUP ACK from %u to %u causes a change path to %u\\n\", skops->local_port, skops->remote_port, key_dup);\n",
        "            flow_info->srh_id = key_dup;\n",
        "            flow_info->last_move_time = cur_time;\n",
        "            flow_info->retrans_count = 0;\n",
        "            take_snapshot (&stat_map, flow_info, &flow_id, skops->op);\n",
        "        }\n",
        "        break;\n",
        "    case BPF_SOCK_OPS_RTO_CB :\n",
        "        if (!flow_info) {\n",
        "            return 1;\n",
        "        }\n",
        "        flow_info->retrans_count += 1;\n",
        "        if (flow_info->last_snd_una != skops->snd_una) {\n",
        "            flow_info->last_snd_una = skops->snd_una;\n",
        "            flow_info->retrans_count = 1;\n",
        "            rv = bpf_map_update_elem (& conn_map, & flow_id, flow_info, BPF_ANY);\n",
        "            break;\n",
        "        }\n",
        "        if (cur_time - flow_info->last_move_time < MIN_TIME_BEFORE_MOVING_NS) {\n",
        "            rv = bpf_map_update_elem (& conn_map, & flow_id, flow_info, BPF_ANY);\n",
        "            break;\n",
        "        }\n",
        "        __u32 key = 0;\n",
        "        struct dst_infos *dst_infos = (void *) bpf_map_lookup_elem (&dest_map, flow_id.remote_addr);\n",
        "        key = inner_loop (flow_info -> srh_id, dst_infos);\n",
        "        if (key == flow_info->srh_id) {\n",
        "            rv = bpf_map_update_elem (& conn_map, & flow_id, flow_info, BPF_ANY);\n",
        "            break;\n",
        "        }\n",
        "        bpf_debug (\"RTO in %u - Change path to %u\\n\", skops->local_port, key);\n",
        "        rv = move_path (& dest_map, flow_id.remote_addr, key, skops);\n",
        "        if (!rv) {\n",
        "            flow_info->srh_id = key;\n",
        "            flow_info->last_move_time = cur_time;\n",
        "            flow_info->retrans_count = 0;\n",
        "        }\n",
        "        take_snapshot (&stat_map, flow_info, &flow_id, skops->op);\n",
        "        rv = bpf_map_update_elem (& conn_map, & flow_id, flow_info, BPF_ANY);\n",
        "        break;\n",
        "    }\n",
        "    skops->reply = rv;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "move_path",
        "create_new_flow_infos",
        "inner_loop",
        "exp3_next_path",
        "get_flow_id_from_sock",
        "traceroute",
        "take_snapshot",
        "exp3_reward_path"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    },
    {
      "capabilities": [
        {
          "capability": "update_pkt",
          "update_pkt": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Attempt to set the value of the bpf_sock_ops_cb_flags field for the full TCP socket associated to bpf_sock_ops to argval. The primary use of this field is to determine if there should be calls to eBPF programs of type BPF_PROG_TYPE_SOCK_OPS at various points in the TCP code. A program of the same type can change its value , per connection and as necessary , when the connection is established. This field is directly accessible for reading , but this helper must be used for updates in order to return an error if an eBPF program tries to set a callback that is not supported in the current kernel. <[ argval ]>(IP: 1) is a flag array which can combine these flags: \u00b7 BPF_SOCK_OPS_RTO_CB_FLAG (retransmission time out) \u00b7 BPF_SOCK_OPS_RETRANS_CB_FLAG (retransmission) \u00b7 BPF_SOCK_OPS_STATE_CB_FLAG (TCP state change) \u00b7 BPF_SOCK_OPS_RTT_CB_FLAG (every RTT) Therefore , this function can be used to clear a callback flag by setting the appropriate bit to zero. e. g. to disable the RTO callback: bpf_sock_ops_cb_flags_set(bpf_sock , bpf_sock->bpf_sock_ops_cb_flags & ~BPF_SOCK_OPS_RTO_CB_FLAG) Here are some examples of where one could call such eBPF program: \u00b7 When RTO fires. \u00b7 When a packet is retransmitted. \u00b7 When the connection terminates. \u00b7 When a packet is sent. \u00b7 When a packet is received. ",
              "Return": " Code -EINVAL if the socket is not a full TCP socket; otherwise,  a  positive                     number  containing  the  bits that could not be set is returned (which comes                     down to 0 if all bits were set as required).",
              "Function Name": "bpf_sock_ops_cb_flags_set",
              "Input Params": [
                "{Type: struct bpf_sock_ops ,Var: *bpf_sock}",
                "{Type:  int ,Var: argval}"
              ],
              "compatible_hookpoints": [
                "sock_ops"
              ],
              "capabilities": [
                "update_pkt"
              ]
            }
          ]
        },
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        },
        {
          "capability": "map_update",
          "map_update": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_map_update_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}",
                "{Type:  const void ,Var: *value}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_update"
              ]
            }
          ]
        },
        {
          "capability": "read_sys_info",
          "read_sys_info": [
            {
              "Project": "bcc",
              "FunctionName": "bpf_ktime_get_ns",
              "Return Type": "u64",
              "Description": "u64 bpf_ktime_get_ns(void) Return: u64 number of nanoseconds. Starts at system boot time but stops during suspend. Examples in situ: \"https://github.com/iovisor/bcc/search?q=bpf_ktime_get_ns+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=bpf_ktime_get_ns+path%3Atools&type=Code search /tools ",
              "Return": "u64 number of nanoseconds",
              "Input Prameters": [],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 55,
      "endLine": 137,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/tpc-ebpf/original_source/ebpf_exp3_lowest_delay.c",
      "funcName": "handle_sockop",
      "developer_inline_comments": [
        {
          "start_line": 68,
          "end_line": 68,
          "text": " Only execute the prog for scp "
        },
        {
          "start_line": 75,
          "end_line": 75,
          "text": "bpf_debug(\"HERE operation %d\\n\", op);"
        },
        {
          "start_line": 76,
          "end_line": 76,
          "text": " TODO Problem if listening connections => no destination defined !!!"
        },
        {
          "start_line": 77,
          "end_line": 77,
          "text": "bpf_debug(\"HERE flow creation\\n\");"
        },
        {
          "start_line": 86,
          "end_line": 86,
          "text": "bpf_debug(\"HERE flow created %d\\n\", BPF_SOCK_OPS_ALL_CB_FLAGS);"
        },
        {
          "start_line": 93,
          "end_line": 93,
          "text": "bpf_debug(\"operation: %d\\n\", op);"
        },
        {
          "start_line": 94,
          "end_line": 94,
          "text": "bpf_debug(\"snd_una: %lu rate : %lu interval: %lu\\n\", skops->snd_una, skops->rate_delivered, skops->rate_interval_us);"
        },
        {
          "start_line": 96,
          "end_line": 96,
          "text": " TODO Case for SYN SENT (need to not return when creating the new flow info)"
        },
        {
          "start_line": 97,
          "end_line": 97,
          "text": " Call EXP3 for servers (because setting the SRH for request socks does not work)"
        },
        {
          "start_line": 98,
          "end_line": 98,
          "text": "bpf_debug(\"passive established\\n\");"
        },
        {
          "start_line": 113,
          "end_line": 113,
          "text": " Change in the state of the TCP CONNECTION"
        },
        {
          "start_line": 114,
          "end_line": 114,
          "text": " This flow is closed, cleanup the maps"
        },
        {
          "start_line": 119,
          "end_line": 119,
          "text": " Store experience if we use EXP3, otherwise, pure random"
        },
        {
          "start_line": 122,
          "end_line": 122,
          "text": " Delete the flow from the flows map"
        },
        {
          "start_line": 124,
          "end_line": 124,
          "text": " Save updated weights"
        },
        {
          "start_line": 128,
          "end_line": 128,
          "text": " Save data"
        }
      ],
      "updateMaps": [
        "  short_conn_map",
        " short_conn_map",
        "  short_dest_map"
      ],
      "readMaps": [
        " short_conn_map",
        " short_dest_map"
      ],
      "input": [
        "struct bpf_sock_ops *skops"
      ],
      "output": "int",
      "helper": [
        "bpf_sock_ops_cb_flags_set",
        "bpf_map_delete_elem",
        "bpf_map_update_elem",
        "bpf_map_lookup_elem",
        "bpf_ktime_get_ns"
      ],
      "compatibleHookpoints": [
        "sock_ops"
      ],
      "source": [
        "int handle_sockop (struct bpf_sock_ops *skops)\n",
        "{\n",
        "    struct dst_infos *dst_infos;\n",
        "    struct flow_infos *flow_info;\n",
        "    struct flow_tuple flow_id;\n",
        "    int op;\n",
        "    int rv = 0;\n",
        "    __u64 cur_time;\n",
        "    cur_time = bpf_ktime_get_ns ();\n",
        "    op = (int) skops->op;\n",
        "    if (skops->family != AF_INET6) {\n",
        "        skops->reply = -1;\n",
        "        return 0;\n",
        "    }\n",
        "    get_flow_id_from_sock (&flow_id, skops);\n",
        "    flow_info = (void *) bpf_map_lookup_elem (&short_conn_map, &flow_id);\n",
        "    if (!flow_info) {\n",
        "        if (create_new_flow_infos (&short_dest_map, &short_conn_map, &flow_id, cur_time, skops)) {\n",
        "            return 1;\n",
        "        }\n",
        "        flow_info = (void *) bpf_map_lookup_elem (&short_conn_map, &flow_id);\n",
        "        if (flow_info) {\n",
        "            dst_infos = (void *) bpf_map_lookup_elem (&short_dest_map, flow_id.remote_addr);\n",
        "            if (dst_infos) {\n",
        "                skops->reply = rv;\n",
        "                return 0;\n",
        "            }\n",
        "        }\n",
        "        return 1;\n",
        "    }\n",
        "    switch (op) {\n",
        "    case BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB :\n",
        "        flow_info->srh_id = exp3_next_path (&short_dest_map, flow_info, flow_id.remote_addr);\n",
        "        dst_infos = (void *) bpf_map_lookup_elem (&short_dest_map, flow_id.remote_addr);\n",
        "        rv = bpf_sock_ops_cb_flags_set (skops, BPF_SOCK_OPS_ALL_CB_FLAGS);\n",
        "        bpf_debug (\"Set flags %lld\\n\", rv);\n",
        "        if (dst_infos) {\n",
        "            move_path (dst_infos, flow_info->srh_id, skops);\n",
        "            flow_info->exp3_start_snd_nxt = skops->snd_nxt;\n",
        "            if (flow_info->srh_id >= 0 && flow_info->srh_id <= MAX_SRH_BY_DEST - 1)\n",
        "                flow_info->exp3_curr_reward = dst_infos->srhs[flow_info->srh_id].curr_bw;\n",
        "            rv = bpf_map_update_elem (& short_conn_map, & flow_id, flow_info, BPF_ANY);\n",
        "        }\n",
        "        break;\n",
        "    case BPF_SOCK_OPS_STATE_CB :\n",
        "        bpf_debug (\"close: %d\\n\", skops->args[1]);\n",
        "        if (skops->args[1] == BPF_TCP_CLOSE) {\n",
        "            dst_infos = (void *) bpf_map_lookup_elem (&short_dest_map, flow_id.remote_addr);\n",
        "            if (dst_infos) {\n",
        "                if (USE_EXP3)\n",
        "                    exp3_reward_path (flow_info, dst_infos, skops);\n",
        "                bpf_map_delete_elem (&short_conn_map, &flow_id);\n",
        "                rv = bpf_map_update_elem (& short_dest_map, flow_id.remote_addr, dst_infos, BPF_ANY);\n",
        "                if (rv)\n",
        "                    return 1;\n",
        "                take_snapshot (&short_stat_map, dst_infos, flow_info);\n",
        "            }\n",
        "        }\n",
        "        break;\n",
        "    }\n",
        "    skops->reply = rv;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "move_path",
        "create_new_flow_infos",
        "inner_loop",
        "exp3_next_path",
        "get_flow_id_from_sock",
        "traceroute",
        "take_snapshot",
        "exp3_reward_path"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    },
    {
      "capabilities": [
        {
          "capability": "map_update",
          "map_update": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_map_update_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}",
                "{Type:  const void ,Var: *value}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_update"
              ]
            }
          ]
        },
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        },
        {
          "capability": "read_sys_info",
          "read_sys_info": [
            {
              "Project": "bcc",
              "FunctionName": "bpf_ktime_get_ns",
              "Return Type": "u64",
              "Description": "u64 bpf_ktime_get_ns(void) Return: u64 number of nanoseconds. Starts at system boot time but stops during suspend. Examples in situ: \"https://github.com/iovisor/bcc/search?q=bpf_ktime_get_ns+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=bpf_ktime_get_ns+path%3Atools&type=Code search /tools ",
              "Return": "u64 number of nanoseconds",
              "Input Prameters": [],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 60,
      "endLine": 143,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/tpc-ebpf/original_source/ebpf_traceroute.c",
      "funcName": "handle_sockop",
      "developer_inline_comments": [
        {
          "start_line": 73,
          "end_line": 73,
          "text": " Only execute the prog for scp "
        },
        {
          "start_line": 81,
          "end_line": 81,
          "text": " IPerf client to server connection only"
        },
        {
          "start_line": 84,
          "end_line": 84,
          "text": " We did not receive an answer yet !"
        },
        {
          "start_line": 87,
          "end_line": 89,
          "text": " else if (op > BASE_OP) {        bpf_debug(\"Timeout debug: %d\\n\", op);    }"
        },
        {
          "start_line": 94,
          "end_line": 94,
          "text": " TODO Problem if listening connections => no destination defined !!!"
        },
        {
          "start_line": 97,
          "end_line": 97,
          "text": " Ignore iperf metadata connection"
        },
        {
          "start_line": 107,
          "end_line": 107,
          "text": " Start traceroute"
        },
        {
          "start_line": 114,
          "end_line": 114,
          "text": " An ICMP is received"
        },
        {
          "start_line": 122,
          "end_line": 122,
          "text": " Get the last Hop Limit tried"
        },
        {
          "start_line": 125,
          "end_line": 125,
          "text": " Continue traceroute"
        }
      ],
      "updateMaps": [
        " conn_map"
      ],
      "readMaps": [
        " conn_map"
      ],
      "input": [
        "struct bpf_sock_ops *skops"
      ],
      "output": "int",
      "helper": [
        "bpf_map_update_elem",
        "bpf_map_lookup_elem",
        "bpf_ktime_get_ns"
      ],
      "compatibleHookpoints": [
        "kprobe",
        "sk_reuseport",
        "sched_cls",
        "sk_skb",
        "sched_act",
        "tracepoint",
        "socket_filter",
        "xdp",
        "cgroup_sock_addr",
        "flow_dissector",
        "raw_tracepoint_writable",
        "perf_event",
        "sock_ops",
        "cgroup_skb",
        "lwt_seg6local",
        "sk_msg",
        "cgroup_sock",
        "lwt_in",
        "raw_tracepoint",
        "lwt_out",
        "lwt_xmit"
      ],
      "source": [
        "int handle_sockop (struct bpf_sock_ops *skops)\n",
        "{\n",
        "    int op;\n",
        "    int rv = 0;\n",
        "    __u64 cur_time;\n",
        "    struct ipv6hdr *ip6;\n",
        "    struct icmp6hdr *icmp;\n",
        "    struct flow_tuple flow_id;\n",
        "    struct flow_infos *flow_info;\n",
        "    cur_time = bpf_ktime_get_ns ();\n",
        "    op = (int) skops->op;\n",
        "    if (skops->family != AF_INET6) {\n",
        "        skops->reply = -1;\n",
        "        return 0;\n",
        "    }\n",
        "    get_flow_id_from_sock (&flow_id, skops);\n",
        "    flow_info = (void *) bpf_map_lookup_elem (&conn_map, &flow_id);\n",
        "    if (flow_id.remote_port != 5201)\n",
        "        return 0;\n",
        "    if (flow_info && op == BASE_OP + flow_info->increment_hops - 1) {\n",
        "        bpf_debug (\"Traceroute stopped\\n\");\n",
        "        return 0;\n",
        "    }\n",
        "    switch (op) {\n",
        "    case BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB :\n",
        "    case BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB :\n",
        "        if (!flow_info) {\n",
        "            connection_number++;\n",
        "            if (connection_number != 2)\n",
        "                return 0;\n",
        "            struct flow_infos new_flow;\n",
        "            int rv = 0;\n",
        "            new_flow.increment_hops = 1;\n",
        "            bpf_map_update_elem (&conn_map, &flow_id, &new_flow, BPF_ANY);\n",
        "            flow_info = (void *) bpf_map_lookup_elem (&conn_map, &flow_id);\n",
        "            if (!flow_info) {\n",
        "                return 1;\n",
        "            }\n",
        "        }\n",
        "        bpf_debug (\"Triggering traceroute\\n\");\n",
        "        rv = traceroute (skops, flow_info -> increment_hops);\n",
        "        flow_info->increment_hops++;\n",
        "        bpf_map_update_elem (&conn_map, &flow_id, flow_info, BPF_ANY);\n",
        "        break;\n",
        "    case BPF_SOCK_OPS_PARSE_ICMP_CB :\n",
        "        if (!flow_info)\n",
        "            return 1;\n",
        "        ip6 = skops->skb_data;\n",
        "        if ((void *) (ip6 + 1) <= skops->skb_data_end) {\n",
        "            icmp = (struct icmp6hdr *) (ip6 + 1);\n",
        "            if ((void *) (icmp + 1) <= skops->skb_data_end) {\n",
        "                if (icmp->icmp6_type == ICMPV6_TIME_EXCEEDED) {\n",
        "                    bpf_debug (\"Hop %d is %pI6c\\n\", flow_info->increment_hops - 1, &ip6->saddr);\n",
        "                    traceroute (skops, flow_info->increment_hops);\n",
        "                    flow_info->increment_hops++;\n",
        "                    bpf_map_update_elem (&conn_map, &flow_id, flow_info, BPF_ANY);\n",
        "                }\n",
        "                else {\n",
        "                    bpf_debug (\"ICMP of type %u and code %u\\n\", icmp->icmp6_type, icmp->icmp6_code);\n",
        "                }\n",
        "            }\n",
        "            else {\n",
        "                bpf_debug (\"Not enough skb to read the ICMPv6 header\\n\");\n",
        "            }\n",
        "        }\n",
        "        else {\n",
        "            bpf_debug (\"Not enough skb to read the IPv6 header\\n\");\n",
        "        }\n",
        "        break;\n",
        "    }\n",
        "    skops->reply = rv;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "move_path",
        "create_new_flow_infos",
        "inner_loop",
        "exp3_next_path",
        "get_flow_id_from_sock",
        "traceroute",
        "take_snapshot",
        "exp3_reward_path"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    },
    {
      "capabilities": [
        {
          "capability": "read_sys_info",
          "read_sys_info": [
            {
              "Project": "bcc",
              "FunctionName": "bpf_ktime_get_ns",
              "Return Type": "u64",
              "Description": "u64 bpf_ktime_get_ns(void) Return: u64 number of nanoseconds. Starts at system boot time but stops during suspend. Examples in situ: \"https://github.com/iovisor/bcc/search?q=bpf_ktime_get_ns+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=bpf_ktime_get_ns+path%3Atools&type=Code search /tools ",
              "Return": "u64 number of nanoseconds",
              "Input Prameters": [],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 32,
      "endLine": 58,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/tpc-ebpf/original_source/ebpf_use_second_path.c",
      "funcName": "handle_sockop",
      "developer_inline_comments": [
        {
          "start_line": 41,
          "end_line": 41,
          "text": " Only execute the prog for scp "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct bpf_sock_ops *skops"
      ],
      "output": "int",
      "helper": [
        "bpf_ktime_get_ns"
      ],
      "compatibleHookpoints": [
        "kprobe",
        "sk_reuseport",
        "sched_cls",
        "sk_skb",
        "sched_act",
        "socket_filter",
        "tracepoint",
        "xdp",
        "cgroup_sock_addr",
        "flow_dissector",
        "raw_tracepoint_writable",
        "perf_event",
        "sock_ops",
        "cgroup_skb",
        "lwt_seg6local",
        "sk_msg",
        "cgroup_sock",
        "lwt_in",
        "raw_tracepoint",
        "lwt_out",
        "lwt_xmit"
      ],
      "source": [
        "int handle_sockop (struct bpf_sock_ops *skops)\n",
        "{\n",
        "    struct flow_tuple flow_id;\n",
        "    int rv = 0;\n",
        "    __u64 cur_time;\n",
        "    cur_time = bpf_ktime_get_ns ();\n",
        "    if (skops->family != AF_INET6) {\n",
        "        skops->reply = -1;\n",
        "        return 0;\n",
        "    }\n",
        "    get_flow_id_from_sock (&flow_id, skops);\n",
        "    switch ((int) skops->op) {\n",
        "    case BPF_SOCK_OPS_TCP_CONNECT_CB :\n",
        "    case BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB :\n",
        "        rv = move_path (&dest_map, flow_id.remote_addr, 1, skops);\n",
        "        bpf_debug (\"Move to path %d\\n\", rv);\n",
        "        break;\n",
        "    }\n",
        "    skops->reply = rv;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "move_path",
        "create_new_flow_infos",
        "inner_loop",
        "exp3_next_path",
        "get_flow_id_from_sock",
        "traceroute",
        "take_snapshot",
        "exp3_reward_path"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    },
    {
      "capabilities": [
        {
          "capability": "read_sys_info",
          "read_sys_info": [
            {
              "Project": "bcc",
              "FunctionName": "bpf_ktime_get_ns",
              "Return Type": "u64",
              "Description": "u64 bpf_ktime_get_ns(void) Return: u64 number of nanoseconds. Starts at system boot time but stops during suspend. Examples in situ: \"https://github.com/iovisor/bcc/search?q=bpf_ktime_get_ns+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=bpf_ktime_get_ns+path%3Atools&type=Code search /tools ",
              "Return": "u64 number of nanoseconds",
              "Input Prameters": [],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            }
          ]
        },
        {
          "capability": "update_pkt",
          "update_pkt": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Emulate a call to setsockopt() on the socket associated to <[ bpf_socket ]>(IP: 0) , which must be a full socket. The <[ level ]>(IP: 1) at which the option resides and the name <[ optname ]>(IP: 2) of the option must be specified , see setsockopt(2) for more information. The option value of length <[ optlen ]>(IP: 4) is pointed by optval. This helper actually implements a subset of setsockopt(). It supports the following levels: \u00b7 SOL_SOCKET , which supports the following optnames: SO_RCVBUF , SO_SNDBUF , SO_MAX_PACING_RATE , SO_PRIORITY , SO_RCVLOWAT , SO_MARK. \u00b7 IPPROTO_TCP , which supports the following optnames: TCP_CONGESTION , TCP_BPF_IW , TCP_BPF_SNDCWND_CLAMP. \u00b7 IPPROTO_IP , which supports <[ optname ]>(IP: 2) IP_TOS. \u00b7 IPPROTO_IPV6 , which supports <[ optname ]>(IP: 2) IPV6_TCLASS. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_setsockopt",
              "Input Params": [
                "{Type: struct bpf_sock_ops ,Var: *bpf_socket}",
                "{Type:  int ,Var: level}",
                "{Type:  int ,Var: optname}",
                "{Type:  char ,Var: *optval}",
                "{Type:  int ,Var: optlen}"
              ],
              "compatible_hookpoints": [
                "sock_ops"
              ],
              "capabilities": [
                "update_pkt"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 31,
      "endLine": 108,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/tpc-ebpf/original_source/ebpf_reverse_srh.c",
      "funcName": "handle_sockop",
      "developer_inline_comments": [
        {
          "start_line": 45,
          "end_line": 45,
          "text": " Only execute the prog for scp "
        },
        {
          "start_line": 58,
          "end_line": 58,
          "text": " We cannot set a SRH on a request sock, only on a full sock"
        },
        {
          "start_line": 60,
          "end_line": 60,
          "text": " TODO Print Received SRH"
        },
        {
          "start_line": 63,
          "end_line": 63,
          "text": "bpf_debug(\"IP version %d\\n\", ip6->version);"
        },
        {
          "start_line": 66,
          "end_line": 66,
          "text": " There is a routing extension header that is readable"
        },
        {
          "start_line": 81,
          "end_line": 81,
          "text": " Copy each element in reverse, ignoring the segment at index 0 because it will be the destination"
        },
        {
          "start_line": 84,
          "end_line": 84,
          "text": " TODO "
        },
        {
          "start_line": 89,
          "end_line": 89,
          "text": " Check for the verifier"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct bpf_sock_ops *skops"
      ],
      "output": "int",
      "helper": [
        "bpf_ktime_get_ns",
        "bpf_setsockopt"
      ],
      "compatibleHookpoints": [
        "sock_ops"
      ],
      "source": [
        "int handle_sockop (struct bpf_sock_ops *skops)\n",
        "{\n",
        "    int op;\n",
        "    int val = 0;\n",
        "    int rv = 0;\n",
        "    __u64 cur_time;\n",
        "    struct ipv6hdr *ip6;\n",
        "    struct ip6_srh_t reversed_srh;\n",
        "    struct ip6_srh_t *skb_srh;\n",
        "    struct ip6_addr_t tmp;\n",
        "    cur_time = bpf_ktime_get_ns ();\n",
        "    op = (int) skops->op;\n",
        "    if (skops->family != AF_INET6) {\n",
        "        skops->reply = -1;\n",
        "        return 0;\n",
        "    }\n",
        "    switch (op) {\n",
        "    case BPF_SOCK_OPS_TCP_CONNECT_CB :\n",
        "    case BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB :\n",
        "        val = 1;\n",
        "        rv = bpf_setsockopt (skops, SOL_IPV6, IPV6_RECVRTHDR, & val, sizeof (int));\n",
        "        break;\n",
        "    case BPF_SOCK_OPS_PARSE_EXT_HDR_CB :\n",
        "        if (skops->is_fullsock) {\n",
        "            ip6 = (struct ipv6hdr *) skops->skb_data;\n",
        "            if (ip6 + 1 <= skops->skb_data_end && ip6->nexthdr == NEXTHDR_ROUTING) {\n",
        "                skb_srh = (struct ip6_srh_t *) (ip6 + 1);\n",
        "                if (((void *) (skb_srh + 1)) - sizeof (reversed_srh.segments) <= skops->skb_data_end && skb_srh->type == 4) {\n",
        "                    int skb_srh_size = (skb_srh->hdrlen + 1) << 3;\n",
        "                    if (((void *) skb_srh) + skb_srh_size > skops->skb_data_end) {\n",
        "                        bpf_debug (\"SRH cut in the middle\\n\");\n",
        "                        return 1;\n",
        "                    }\n",
        "                    if (skb_srh_size > sizeof (struct ip6_srh_t)) {\n",
        "                        bpf_debug (\"A too big SRH for the reserved size\\n\");\n",
        "                        return 1;\n",
        "                    }\n",
        "                    memset (&reversed_srh, 0, sizeof (reversed_srh));\n",
        "                    memcpy (&reversed_srh, skb_srh, 8);\n",
        "                    reversed_srh.segments_left = reversed_srh.first_segment;\n",
        "\n",
        "#pragma clang loop unroll(full)\n",
        "                    for (int i = 0; i < MAX_SEGS_NBR - 1; i++) {\n",
        "                        if (i < reversed_srh.first_segment) {\n",
        "                            if (skb_srh->segments + i + 2 <= skops->skb_data_end) {\n",
        "                                tmp = skb_srh->segments[i + 1];\n",
        "                                int idx = reversed_srh.first_segment - i;\n",
        "                                if (idx >= 0 && idx < MAX_SEGS_NBR) {\n",
        "                                    reversed_srh.segments[idx] = tmp;\n",
        "                                }\n",
        "                            }\n",
        "                        }\n",
        "                    }\n",
        "                    move_path (&reversed_srh, skops);\n",
        "                }\n",
        "                else {\n",
        "                    bpf_debug (\"Not enough space for IPv6 SRH\\n\");\n",
        "                }\n",
        "            }\n",
        "            else {\n",
        "                bpf_debug (\"No IPv6 SRH\\n\");\n",
        "            }\n",
        "        }\n",
        "        break;\n",
        "    }\n",
        "    skops->reply = rv;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "move_path",
        "create_new_flow_infos",
        "inner_loop",
        "exp3_next_path",
        "get_flow_id_from_sock",
        "traceroute",
        "take_snapshot",
        "exp3_reward_path"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    },
    {
      "capabilities": [
        {
          "capability": "map_update",
          "map_update": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_map_update_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}",
                "{Type:  const void ,Var: *value}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_update"
              ]
            }
          ]
        },
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        },
        {
          "capability": "read_sys_info",
          "read_sys_info": [
            {
              "Project": "bcc",
              "FunctionName": "bpf_ktime_get_ns",
              "Return Type": "u64",
              "Description": "u64 bpf_ktime_get_ns(void) Return: u64 number of nanoseconds. Starts at system boot time but stops during suspend. Examples in situ: \"https://github.com/iovisor/bcc/search?q=bpf_ktime_get_ns+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=bpf_ktime_get_ns+path%3Atools&type=Code search /tools ",
              "Return": "u64 number of nanoseconds",
              "Input Prameters": [],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 95,
      "endLine": 263,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/tpc-ebpf/original_source/ebpf_n_rto_changer.c",
      "funcName": "handle_sockop",
      "developer_inline_comments": [
        {
          "start_line": 105,
          "end_line": 105,
          "text": " Only execute the prog for scp "
        },
        {
          "start_line": 115,
          "end_line": 115,
          "text": "bpf_debug(\"active SYN sent from %u\\n\", skops->local_port);"
        },
        {
          "start_line": 116,
          "end_line": 116,
          "text": " XXX No break; here"
        },
        {
          "start_line": 117,
          "end_line": 117,
          "text": " Call EXP4 for servers (because setting the SRH for request socks does not work)"
        },
        {
          "start_line": 141,
          "end_line": 141,
          "text": "if (skops->op == BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB)"
        },
        {
          "start_line": 142,
          "end_line": 142,
          "text": "\tbpf_debug(\"passive established - timer %llu\\n\", flow_info->last_move_time);"
        },
        {
          "start_line": 144,
          "end_line": 144,
          "text": " Change in the state of the TCP CONNECTION"
        },
        {
          "start_line": 145,
          "end_line": 145,
          "text": " This flow is closed, cleanup the maps"
        },
        {
          "start_line": 147,
          "end_line": 147,
          "text": "bpf_debug(\"Close\\n\");"
        },
        {
          "start_line": 151,
          "end_line": 151,
          "text": " Delete the flow from the flows map"
        },
        {
          "start_line": 152,
          "end_line": 152,
          "text": " take_snapshot(&stat_map, flow_info, &flow_id);"
        },
        {
          "start_line": 161,
          "end_line": 161,
          "text": "bpf_debug(\"Duplicated ack: nbr %llu for %llu\\n\", flow_info->retrans_count, skops->rcv_nxt);"
        },
        {
          "start_line": 163,
          "end_line": 163,
          "text": " Data was acked so issue was solved"
        },
        {
          "start_line": 171,
          "end_line": 171,
          "text": " TODO This number needs to be strictly lower than the RTO trigger..."
        },
        {
          "start_line": 172,
          "end_line": 172,
          "text": " It can work with equal values if bytes were in flight at the failure but never greater values"
        },
        {
          "start_line": 177,
          "end_line": 177,
          "text": " This assumes that SRH 0 is always valid"
        },
        {
          "start_line": 180,
          "end_line": 180,
          "text": "bpf_debug(\"DUP ACK - Change path to %u\\n\", key_dup);"
        },
        {
          "start_line": 183,
          "end_line": 183,
          "text": " This can't be helped"
        },
        {
          "start_line": 188,
          "end_line": 188,
          "text": " Move to the next path"
        },
        {
          "start_line": 192,
          "end_line": 192,
          "text": " Update flow informations"
        },
        {
          "start_line": 200,
          "end_line": 200,
          "text": " TODO Retransmission"
        },
        {
          "start_line": 205,
          "end_line": 205,
          "text": " TODO Remove ?"
        },
        {
          "start_line": 207,
          "end_line": 207,
          "text": " TODO Retransmission timeout"
        },
        {
          "start_line": 208,
          "end_line": 208,
          "text": " TODO The problem is that the connection is cut from the server to the client as well..."
        },
        {
          "start_line": 209,
          "end_line": 209,
          "text": " TODO So the server also needs this program (or a single-side cut)..."
        },
        {
          "start_line": 210,
          "end_line": 210,
          "text": " TODO But it won't work if the server is only acking because no eBPF is made..."
        },
        {
          "start_line": 216,
          "end_line": 216,
          "text": "bpf_debug(\"Params: %u %u %u\\n\", skops->args[0], skops->args[1], skops->args[2]);"
        },
        {
          "start_line": 219,
          "end_line": 219,
          "text": " Data was acked so issue was solved TODO Try with a delta of two packets"
        },
        {
          "start_line": 233,
          "end_line": 233,
          "text": " After three duplicated acknowledgments for the same data, switch path"
        },
        {
          "start_line": 235,
          "end_line": 235,
          "text": " This assumes that SRH 0 is always valid"
        },
        {
          "start_line": 238,
          "end_line": 238,
          "text": "bpf_debug(\"RTO - Change path to %u\\n\", key);"
        },
        {
          "start_line": 241,
          "end_line": 241,
          "text": " This can't be helped"
        },
        {
          "start_line": 246,
          "end_line": 246,
          "text": " Move to the next path"
        },
        {
          "start_line": 250,
          "end_line": 250,
          "text": " Update flow informations"
        }
      ],
      "updateMaps": [
        "  conn_map",
        " conn_map"
      ],
      "readMaps": [
        " conn_map",
        " dest_map"
      ],
      "input": [
        "struct bpf_sock_ops *skops"
      ],
      "output": "int",
      "helper": [
        "bpf_sock_ops_cb_flags_set",
        "bpf_map_delete_elem",
        "bpf_map_update_elem",
        "bpf_map_lookup_elem",
        "bpf_ktime_get_ns"
      ],
      "compatibleHookpoints": [
        "sock_ops"
      ],
      "source": [
        "int handle_sockop (struct bpf_sock_ops *skops)\n",
        "{\n",
        "    struct flow_infos *flow_info;\n",
        "    struct flow_tuple flow_id;\n",
        "    int rv = 0;\n",
        "    __u64 cur_time;\n",
        "    cur_time = bpf_ktime_get_ns ();\n",
        "    if (skops->family != AF_INET6) {\n",
        "        skops->reply = -1;\n",
        "        return 0;\n",
        "    }\n",
        "    get_flow_id_from_sock (&flow_id, skops);\n",
        "    flow_info = (void *) bpf_map_lookup_elem (&conn_map, &flow_id);\n",
        "    switch ((int) skops->op) {\n",
        "    case BPF_SOCK_OPS_TCP_CONNECT_CB :\n",
        "    case BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB :\n",
        "        if (!flow_info) {\n",
        "            if (create_new_flow_infos (&dest_map, &conn_map, &flow_id, cur_time, skops)) {\n",
        "                return 1;\n",
        "            }\n",
        "            flow_info = (void *) bpf_map_lookup_elem (&conn_map, &flow_id);\n",
        "            if (!flow_info) {\n",
        "                return 1;\n",
        "            }\n",
        "        }\n",
        "        bpf_debug (\"INIT CONN snd_cwnd: %u\\n\", skops->snd_cwnd);\n",
        "        flow_info->last_move_time = cur_time;\n",
        "        flow_info->srh_id = 0;\n",
        "        move_path (&dest_map, flow_id.remote_addr, flow_info->srh_id, skops);\n",
        "        rv = bpf_map_update_elem (& conn_map, & flow_id, flow_info, BPF_ANY);\n",
        "        if (rv)\n",
        "            return 1;\n",
        "        take_snapshot (&stat_map, flow_info, &flow_id, skops->op);\n",
        "        bpf_sock_ops_cb_flags_set (skops, (BPF_SOCK_OPS_RETRANS_CB_FLAG | BPF_SOCK_OPS_RTO_CB_FLAG | BPF_SOCK_OPS_RTT_CB_FLAG | BPF_SOCK_OPS_STATE_CB_FLAG));\n",
        "        skops->reply = rv;\n",
        "        break;\n",
        "    case BPF_SOCK_OPS_STATE_CB :\n",
        "        if (skops->args[1] == BPF_TCP_CLOSE || skops->args[1] == BPF_TCP_CLOSE_WAIT || skops->args[1] == BPF_TCP_CLOSING || skops->args[1] == BPF_TCP_FIN_WAIT1 || skops->args[1] == BPF_TCP_FIN_WAIT2) {\n",
        "            if (!flow_info) {\n",
        "                return 0;\n",
        "            }\n",
        "            bpf_map_delete_elem (&conn_map, &flow_id);\n",
        "        }\n",
        "        break;\n",
        "    case BPF_SOCK_OPS_DUPACK :\n",
        "        if (!flow_info) {\n",
        "            return 1;\n",
        "        }\n",
        "        flow_info->retrans_count += 1;\n",
        "        if (flow_info->last_rcv_nxt != skops->rcv_nxt) {\n",
        "            flow_info->last_rcv_nxt = skops->rcv_nxt;\n",
        "            flow_info->retrans_count = 1;\n",
        "            rv = bpf_map_update_elem (& conn_map, & flow_id, flow_info, BPF_ANY);\n",
        "            break;\n",
        "        }\n",
        "        if (flow_info->retrans_count < 2) {\n",
        "            rv = bpf_map_update_elem (& conn_map, & flow_id, flow_info, BPF_ANY);\n",
        "            break;\n",
        "        }\n",
        "        __u32 key_dup = 0;\n",
        "        struct dst_infos *dst_infos_dup = (void *) bpf_map_lookup_elem (&dest_map, flow_id.remote_addr);\n",
        "        key_dup = inner_loop (flow_info -> srh_id, dst_infos_dup);\n",
        "        if (key_dup == flow_info->srh_id) {\n",
        "            rv = bpf_map_update_elem (& conn_map, & flow_id, flow_info, BPF_ANY);\n",
        "            break;\n",
        "        }\n",
        "        bpf_debug (\"DUP ACK - Change path to %u\\n\", key_dup);\n",
        "        rv = move_path (& dest_map, flow_id.remote_addr, key_dup, skops);\n",
        "        if (!rv) {\n",
        "            flow_info->srh_id = key_dup;\n",
        "            flow_info->last_move_time = cur_time;\n",
        "            flow_info->retrans_count = 0;\n",
        "            bpf_debug (\"DUP ACK - Path changed to %u\\n\", key_dup);\n",
        "        }\n",
        "        take_snapshot (&stat_map, flow_info, &flow_id, skops->op);\n",
        "        break;\n",
        "    case BPF_SOCK_OPS_RETRANS_CB :\n",
        "        if (!flow_info) {\n",
        "            return 0;\n",
        "        }\n",
        "        bpf_debug (\"Retransmission: for %llu\\n\", skops->snd_una);\n",
        "        take_snapshot (&stat_map, flow_info, &flow_id, skops->op);\n",
        "        break;\n",
        "    case BPF_SOCK_OPS_RTO_CB :\n",
        "        if (!flow_info) {\n",
        "            return 1;\n",
        "        }\n",
        "        flow_info->retrans_count += 1;\n",
        "        bpf_debug (\"Retransmission timeout: nbr %llu for %llu\\n\", flow_info->retrans_count, skops->snd_una);\n",
        "        bpf_debug (\"snd_cwnd: %u - packets_out %u\\n\", skops->snd_cwnd, skops->packets_out);\n",
        "        if (flow_info->last_snd_una + 3000 < skops->snd_una) {\n",
        "            flow_info->last_snd_una = skops->snd_una;\n",
        "            flow_info->retrans_count = 1;\n",
        "            rv = bpf_map_update_elem (& conn_map, & flow_id, flow_info, BPF_ANY);\n",
        "            take_snapshot (&stat_map, flow_info, &flow_id, skops->op);\n",
        "            break;\n",
        "        }\n",
        "        if (flow_info->retrans_count < 3) {\n",
        "            rv = bpf_map_update_elem (& conn_map, & flow_id, flow_info, BPF_ANY);\n",
        "            take_snapshot (&stat_map, flow_info, &flow_id, skops->op);\n",
        "            break;\n",
        "        }\n",
        "        __u32 key = 0;\n",
        "        struct dst_infos *dst_infos = (void *) bpf_map_lookup_elem (&dest_map, flow_id.remote_addr);\n",
        "        key = inner_loop (flow_info -> srh_id, dst_infos);\n",
        "        if (key == flow_info->srh_id) {\n",
        "            rv = bpf_map_update_elem (& conn_map, & flow_id, flow_info, BPF_ANY);\n",
        "            break;\n",
        "        }\n",
        "        bpf_debug (\"RTO - Change path to %u\\n\", key);\n",
        "        rv = move_path (& dest_map, flow_id.remote_addr, key, skops);\n",
        "        if (!rv) {\n",
        "            flow_info->srh_id = key;\n",
        "            flow_info->last_move_time = cur_time;\n",
        "            flow_info->retrans_count = 0;\n",
        "            bpf_debug (\"RTO - Path changed to %u\\n\", key);\n",
        "        }\n",
        "        take_snapshot (&stat_map, flow_info, &flow_id, skops->op);\n",
        "        rv = bpf_map_update_elem (& conn_map, & flow_id, flow_info, BPF_ANY);\n",
        "        break;\n",
        "    }\n",
        "    skops->reply = rv;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "move_path",
        "create_new_flow_infos",
        "inner_loop",
        "exp3_next_path",
        "get_flow_id_from_sock",
        "traceroute",
        "take_snapshot",
        "exp3_reward_path"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    },
    {
      "capabilities": [
        {
          "capability": "map_update",
          "map_update": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_map_update_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}",
                "{Type:  const void ,Var: *value}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_update"
              ]
            }
          ]
        },
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        },
        {
          "capability": "read_sys_info",
          "read_sys_info": [
            {
              "Project": "bcc",
              "FunctionName": "bpf_ktime_get_ns",
              "Return Type": "u64",
              "Description": "u64 bpf_ktime_get_ns(void) Return: u64 number of nanoseconds. Starts at system boot time but stops during suspend. Examples in situ: \"https://github.com/iovisor/bcc/search?q=bpf_ktime_get_ns+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=bpf_ktime_get_ns+path%3Atools&type=Code search /tools ",
              "Return": "u64 number of nanoseconds",
              "Input Prameters": [],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 60,
      "endLine": 147,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/tpc-ebpf/original_source/ebpf_traceroute_parallel.c",
      "funcName": "handle_sockop",
      "developer_inline_comments": [
        {
          "start_line": 73,
          "end_line": 73,
          "text": " Only execute the prog for scp "
        },
        {
          "start_line": 81,
          "end_line": 81,
          "text": " IPerf client to server connection only"
        },
        {
          "start_line": 84,
          "end_line": 84,
          "text": " We did not receive an answer yet !"
        },
        {
          "start_line": 87,
          "end_line": 89,
          "text": " else if (op > BASE_OP) {        bpf_debug(\"Timeout debug: %d\\n\", op);    }"
        },
        {
          "start_line": 94,
          "end_line": 94,
          "text": " TODO Problem if listening connections => no destination defined !!!"
        },
        {
          "start_line": 97,
          "end_line": 97,
          "text": " Ignore iperf metadata connection"
        },
        {
          "start_line": 107,
          "end_line": 107,
          "text": " Start traceroute"
        },
        {
          "start_line": 116,
          "end_line": 116,
          "text": " An ICMP is received"
        },
        {
          "start_line": 124,
          "end_line": 124,
          "text": " Get the last Hop Limit tried"
        },
        {
          "start_line": 127,
          "end_line": 127,
          "text": " Continue traceroute"
        }
      ],
      "updateMaps": [
        " conn_map"
      ],
      "readMaps": [
        " conn_map"
      ],
      "input": [
        "struct bpf_sock_ops *skops"
      ],
      "output": "int",
      "helper": [
        "bpf_map_update_elem",
        "bpf_map_lookup_elem",
        "bpf_ktime_get_ns"
      ],
      "compatibleHookpoints": [
        "kprobe",
        "sk_reuseport",
        "sched_cls",
        "sk_skb",
        "sched_act",
        "tracepoint",
        "socket_filter",
        "xdp",
        "cgroup_sock_addr",
        "flow_dissector",
        "raw_tracepoint_writable",
        "perf_event",
        "sock_ops",
        "cgroup_skb",
        "lwt_seg6local",
        "sk_msg",
        "cgroup_sock",
        "lwt_in",
        "raw_tracepoint",
        "lwt_out",
        "lwt_xmit"
      ],
      "source": [
        "int handle_sockop (struct bpf_sock_ops *skops)\n",
        "{\n",
        "    int op;\n",
        "    int rv = 0;\n",
        "    __u64 cur_time;\n",
        "    struct ipv6hdr *ip6;\n",
        "    struct icmp6hdr *icmp;\n",
        "    struct flow_tuple flow_id;\n",
        "    struct flow_infos *flow_info;\n",
        "    cur_time = bpf_ktime_get_ns ();\n",
        "    op = (int) skops->op;\n",
        "    if (skops->family != AF_INET6) {\n",
        "        skops->reply = -1;\n",
        "        return 0;\n",
        "    }\n",
        "    get_flow_id_from_sock (&flow_id, skops);\n",
        "    flow_info = (void *) bpf_map_lookup_elem (&conn_map, &flow_id);\n",
        "    if (flow_id.remote_port != 5201)\n",
        "        return 0;\n",
        "    if (flow_info && op == BASE_OP + flow_info->increment_hops - 1) {\n",
        "        bpf_debug (\"Traceroute stopped\\n\");\n",
        "        return 0;\n",
        "    }\n",
        "    switch (op) {\n",
        "    case BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB :\n",
        "    case BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB :\n",
        "        if (!flow_info) {\n",
        "            connection_number++;\n",
        "            if (connection_number != 2)\n",
        "                return 0;\n",
        "            struct flow_infos new_flow;\n",
        "            int rv = 0;\n",
        "            new_flow.increment_hops = 1;\n",
        "            bpf_map_update_elem (&conn_map, &flow_id, &new_flow, BPF_ANY);\n",
        "            flow_info = (void *) bpf_map_lookup_elem (&conn_map, &flow_id);\n",
        "            if (!flow_info) {\n",
        "                return 1;\n",
        "            }\n",
        "        }\n",
        "        bpf_debug (\"Triggering traceroute\\n\");\n",
        "        for (int i = 0; i < 15; i++) {\n",
        "            rv = traceroute (skops, flow_info -> increment_hops);\n",
        "            flow_info->increment_hops++;\n",
        "        }\n",
        "        bpf_map_update_elem (&conn_map, &flow_id, flow_info, BPF_ANY);\n",
        "        break;\n",
        "    case BPF_SOCK_OPS_PARSE_ICMP_CB :\n",
        "        if (!flow_info)\n",
        "            return 1;\n",
        "        ip6 = skops->skb_data;\n",
        "        if ((void *) (ip6 + 1) <= skops->skb_data_end) {\n",
        "            icmp = (struct icmp6hdr *) (ip6 + 1);\n",
        "            if ((void *) (icmp + 1) <= skops->skb_data_end) {\n",
        "                if (icmp->icmp6_type == ICMPV6_TIME_EXCEEDED) {\n",
        "                    bpf_debug (\"Hop %d is %pI6c\\n\", flow_info->increment_hops - 1, &ip6->saddr);\n",
        "                    for (int i = 0; i < 15; i++) {\n",
        "                        rv = traceroute (skops, flow_info -> increment_hops);\n",
        "                        flow_info->increment_hops++;\n",
        "                    }\n",
        "                    bpf_map_update_elem (&conn_map, &flow_id, flow_info, BPF_ANY);\n",
        "                }\n",
        "                else {\n",
        "                    bpf_debug (\"ICMP of type %u and code %u\\n\", icmp->icmp6_type, icmp->icmp6_code);\n",
        "                }\n",
        "            }\n",
        "            else {\n",
        "                bpf_debug (\"Not enough skb to read the ICMPv6 header\\n\");\n",
        "            }\n",
        "        }\n",
        "        else {\n",
        "            bpf_debug (\"Not enough skb to read the IPv6 header\\n\");\n",
        "        }\n",
        "        break;\n",
        "    }\n",
        "    skops->reply = rv;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "move_path",
        "create_new_flow_infos",
        "inner_loop",
        "exp3_next_path",
        "get_flow_id_from_sock",
        "traceroute",
        "take_snapshot",
        "exp3_reward_path"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    },
    {
      "capabilities": [
        {
          "capability": "map_update",
          "map_update": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_map_update_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}",
                "{Type:  const void ,Var: *value}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_update"
              ]
            }
          ]
        },
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        },
        {
          "capability": "read_sys_info",
          "read_sys_info": [
            {
              "Project": "bcc",
              "FunctionName": "bpf_ktime_get_ns",
              "Return Type": "u64",
              "Description": "u64 bpf_ktime_get_ns(void) Return: u64 number of nanoseconds. Starts at system boot time but stops during suspend. Examples in situ: \"https://github.com/iovisor/bcc/search?q=bpf_ktime_get_ns+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=bpf_ktime_get_ns+path%3Atools&type=Code search /tools ",
              "Return": "u64 number of nanoseconds",
              "Input Prameters": [],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 55,
      "endLine": 146,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/tpc-ebpf/original_source/ebpf_exp3_lowest_completion.c",
      "funcName": "handle_sockop",
      "developer_inline_comments": [
        {
          "start_line": 68,
          "end_line": 68,
          "text": " Only execute the prog for scp "
        },
        {
          "start_line": 75,
          "end_line": 75,
          "text": "bpf_debug(\"HERE operation %d\\n\", op);"
        },
        {
          "start_line": 76,
          "end_line": 76,
          "text": " TODO Problem if listening connections => no destination defined !!!"
        },
        {
          "start_line": 77,
          "end_line": 77,
          "text": "bpf_debug(\"HERE flow creation\\n\");"
        },
        {
          "start_line": 87,
          "end_line": 87,
          "text": "bpf_debug(\"HERE flow created %d\\n\", BPF_SOCK_OPS_ALL_CB_FLAGS);"
        },
        {
          "start_line": 94,
          "end_line": 94,
          "text": "bpf_debug(\"operation: %d\\n\", op);"
        },
        {
          "start_line": 95,
          "end_line": 95,
          "text": "bpf_debug(\"snd_una: %lu rate : %lu interval: %lu\\n\", skops->snd_una, skops->rate_delivered, skops->rate_interval_us);"
        },
        {
          "start_line": 97,
          "end_line": 97,
          "text": " Call EXP3 for servers (because setting the SRH for request socks does not work)"
        },
        {
          "start_line": 105,
          "end_line": 105,
          "text": " Retrieve time for completion time (advantage: ignores SYN+ACK delay)"
        },
        {
          "start_line": 119,
          "end_line": 119,
          "text": " Change in the state of the TCP CONNECTION"
        },
        {
          "start_line": 120,
          "end_line": 120,
          "text": " This flow is closed, cleanup the maps"
        },
        {
          "start_line": 123,
          "end_line": 123,
          "text": "bpf_debug(\"close syn delay %llu\\n\", flow_info->established_timestamp);"
        },
        {
          "start_line": 124,
          "end_line": 124,
          "text": "bpf_debug(\"close rtt delay %llu\\n\", flow_info->rtt_timestamp);"
        },
        {
          "start_line": 125,
          "end_line": 125,
          "text": "bpf_debug(\"close delay %llu\\n\", flow_info->rtt_timestamp - flow_info->established_timestamp);"
        },
        {
          "start_line": 128,
          "end_line": 128,
          "text": " Store experience if we use EXP3, otherwise, pure random"
        },
        {
          "start_line": 131,
          "end_line": 131,
          "text": " Delete the flow from the flows map"
        },
        {
          "start_line": 133,
          "end_line": 133,
          "text": " Save updated weights"
        },
        {
          "start_line": 137,
          "end_line": 137,
          "text": " Save data"
        }
      ],
      "updateMaps": [
        "  short_conn_map",
        " short_conn_map",
        "  short_dest_map"
      ],
      "readMaps": [
        " short_conn_map",
        " short_dest_map"
      ],
      "input": [
        "struct bpf_sock_ops *skops"
      ],
      "output": "int",
      "helper": [
        "bpf_sock_ops_cb_flags_set",
        "bpf_map_delete_elem",
        "bpf_map_update_elem",
        "bpf_map_lookup_elem",
        "bpf_ktime_get_ns"
      ],
      "compatibleHookpoints": [
        "sock_ops"
      ],
      "source": [
        "int handle_sockop (struct bpf_sock_ops *skops)\n",
        "{\n",
        "    struct dst_infos *dst_infos;\n",
        "    struct flow_infos *flow_info;\n",
        "    struct flow_tuple flow_id;\n",
        "    int op;\n",
        "    int rv = 0;\n",
        "    __u64 cur_time;\n",
        "    cur_time = bpf_ktime_get_ns ();\n",
        "    op = (int) skops->op;\n",
        "    if (skops->family != AF_INET6) {\n",
        "        skops->reply = -1;\n",
        "        return 0;\n",
        "    }\n",
        "    get_flow_id_from_sock (&flow_id, skops);\n",
        "    flow_info = (void *) bpf_map_lookup_elem (&short_conn_map, &flow_id);\n",
        "    if (!flow_info) {\n",
        "        if (create_new_flow_infos (&short_dest_map, &short_conn_map, &flow_id, cur_time, skops)) {\n",
        "            return 1;\n",
        "        }\n",
        "        flow_info = (void *) bpf_map_lookup_elem (&short_conn_map, &flow_id);\n",
        "        if (flow_info) {\n",
        "            dst_infos = (void *) bpf_map_lookup_elem (&short_dest_map, flow_id.remote_addr);\n",
        "            if (dst_infos) {\n",
        "                bpf_sock_ops_cb_flags_set (skops, (BPF_SOCK_OPS_RETRANS_CB_FLAG | BPF_SOCK_OPS_RTO_CB_FLAG | BPF_SOCK_OPS_RTT_CB_FLAG | BPF_SOCK_OPS_STATE_CB_FLAG));\n",
        "                skops->reply = rv;\n",
        "                return 0;\n",
        "            }\n",
        "        }\n",
        "        return 1;\n",
        "    }\n",
        "    switch (op) {\n",
        "    case BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB :\n",
        "        bpf_debug (\"passive established\\n\");\n",
        "        flow_info->srh_id = exp3_next_path (&short_dest_map, flow_info, flow_id.remote_addr);\n",
        "        dst_infos = (void *) bpf_map_lookup_elem (&short_dest_map, flow_id.remote_addr);\n",
        "        if (dst_infos) {\n",
        "            move_path (dst_infos, flow_info->srh_id, skops);\n",
        "            flow_info->exp3_start_snd_nxt = skops->snd_nxt;\n",
        "            flow_info->established_timestamp = cur_time;\n",
        "            flow_info->rtt_timestamp = cur_time;\n",
        "            if (flow_info->srh_id >= 0 && flow_info->srh_id <= MAX_SRH_BY_DEST - 1)\n",
        "                flow_info->exp3_curr_reward = dst_infos->srhs[flow_info->srh_id].curr_bw;\n",
        "            rv = bpf_map_update_elem (& short_conn_map, & flow_id, flow_info, BPF_ANY);\n",
        "        }\n",
        "        break;\n",
        "    case BPF_SOCK_OPS_RTT_CB :\n",
        "        flow_info->rtt_timestamp = cur_time;\n",
        "        rv = bpf_map_update_elem (& short_conn_map, & flow_id, flow_info, BPF_ANY);\n",
        "        break;\n",
        "    case BPF_SOCK_OPS_STATE_CB :\n",
        "        if (skops->args[1] == BPF_TCP_CLOSE) {\n",
        "            bpf_debug (\"close: %d\\n\", skops->args[1]);\n",
        "            dst_infos = (void *) bpf_map_lookup_elem (&short_dest_map, flow_id.remote_addr);\n",
        "            if (dst_infos) {\n",
        "                if (USE_EXP3)\n",
        "                    exp3_reward_path (flow_info, dst_infos, skops);\n",
        "                bpf_map_delete_elem (&short_conn_map, &flow_id);\n",
        "                rv = bpf_map_update_elem (& short_dest_map, flow_id.remote_addr, dst_infos, BPF_ANY);\n",
        "                if (rv)\n",
        "                    return 1;\n",
        "                take_snapshot (&short_stat_map, dst_infos, flow_info);\n",
        "            }\n",
        "        }\n",
        "        break;\n",
        "    }\n",
        "    skops->reply = rv;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "move_path",
        "create_new_flow_infos",
        "inner_loop",
        "exp3_next_path",
        "get_flow_id_from_sock",
        "traceroute",
        "take_snapshot",
        "exp3_reward_path"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ],
  "traceroute": [
    {
      "capabilities": [
        {
          "capability": "read_sys_info",
          "read_sys_info": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Emulate a call to getsockopt() on the socket associated to <[ bpf_socket ]>(IP: 0) , which must be a full socket. The <[ level ]>(IP: 1) at which the option resides and the name <[ optname ]>(IP: 2) of the option must be specified , see getsockopt(2) for more information. The retrieved value is stored in the structure pointed by opval and of length optlen. This helper actually implements a subset of getsockopt(). It supports the following levels: \u00b7 IPPROTO_TCP , which supports <[ optname ]>(IP: 2) TCP_CONGESTION. \u00b7 IPPROTO_IP , which supports <[ optname ]>(IP: 2) IP_TOS. \u00b7 IPPROTO_IPV6 , which supports <[ optname ]>(IP: 2) IPV6_TCLASS. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_getsockopt",
              "Input Params": [
                "{Type: struct bpf_sock_ops ,Var: *bpf_socket}",
                "{Type:  int ,Var: level}",
                "{Type:  int ,Var: optname}",
                "{Type:  char ,Var: *optval}",
                "{Type:  int ,Var: optlen}"
              ],
              "compatible_hookpoints": [
                "sock_ops"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            }
          ]
        },
        {
          "capability": "update_pkt",
          "update_pkt": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Emulate a call to setsockopt() on the socket associated to <[ bpf_socket ]>(IP: 0) , which must be a full socket. The <[ level ]>(IP: 1) at which the option resides and the name <[ optname ]>(IP: 2) of the option must be specified , see setsockopt(2) for more information. The option value of length <[ optlen ]>(IP: 4) is pointed by optval. This helper actually implements a subset of setsockopt(). It supports the following levels: \u00b7 SOL_SOCKET , which supports the following optnames: SO_RCVBUF , SO_SNDBUF , SO_MAX_PACING_RATE , SO_PRIORITY , SO_RCVLOWAT , SO_MARK. \u00b7 IPPROTO_TCP , which supports the following optnames: TCP_CONGESTION , TCP_BPF_IW , TCP_BPF_SNDCWND_CLAMP. \u00b7 IPPROTO_IP , which supports <[ optname ]>(IP: 2) IP_TOS. \u00b7 IPPROTO_IPV6 , which supports <[ optname ]>(IP: 2) IPV6_TCLASS. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_setsockopt",
              "Input Params": [
                "{Type: struct bpf_sock_ops ,Var: *bpf_socket}",
                "{Type:  int ,Var: level}",
                "{Type:  int ,Var: optname}",
                "{Type:  char ,Var: *optval}",
                "{Type:  int ,Var: optlen}"
              ],
              "compatible_hookpoints": [
                "sock_ops"
              ],
              "capabilities": [
                "update_pkt"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 21,
      "endLine": 57,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/tpc-ebpf/original_source/ebpf_traceroute.c",
      "funcName": "traceroute",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 5,
          "text": "  * This program is free software; you can redistribute it and/or * modify it under the terms of version 2 of the GNU General Public * License as published by the Free Software Foundation. "
        },
        {
          "start_line": 13,
          "end_line": 13,
          "text": " Always prints"
        },
        {
          "start_line": 16,
          "end_line": 16,
          "text": " This value with the increment_hops cannot exceed 255: the maximum opcode to start the eBPF program"
        },
        {
          "start_line": 24,
          "end_line": 24,
          "text": " Get current Hop Limit"
        },
        {
          "start_line": 32,
          "end_line": 32,
          "text": " Change Hop Limit for probe"
        },
        {
          "start_line": 39,
          "end_line": 39,
          "text": " Send ack probe that should trigger "
        },
        {
          "start_line": 46,
          "end_line": 46,
          "text": " Reset Hop Limit"
        },
        {
          "start_line": 51,
          "end_line": 51,
          "text": " Start timer"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct bpf_sock_ops *skops",
        " int increment_hops"
      ],
      "output": "staticint",
      "helper": [
        "bpf_getsockopt",
        "bpf_setsockopt"
      ],
      "compatibleHookpoints": [
        "sock_ops"
      ],
      "source": [
        "static int traceroute (struct bpf_sock_ops *skops, int increment_hops)\n",
        "{\n",
        "    int rv = 0;\n",
        "    int old_hops = 0;\n",
        "    rv = bpf_getsockopt (skops, SOL_IPV6, IPV6_UNICAST_HOPS, & old_hops, sizeof (int));\n",
        "    if (rv) {\n",
        "        bpf_debug (\"Cannot get Hop Limit: %d\\n\", rv);\n",
        "        return rv;\n",
        "    }\n",
        "    rv = bpf_setsockopt (skops, SOL_IPV6, IPV6_UNICAST_HOPS, & increment_hops, sizeof (int));\n",
        "    if (rv) {\n",
        "        bpf_debug (\"Cannot set Hop Limit to %d: %d\\n\", increment_hops, rv);\n",
        "        return rv;\n",
        "    }\n",
        "    rv = bpf_send_ack (skops);\n",
        "    if (rv) {\n",
        "        bpf_debug (\"Cannot send ack probe: %d\\n\", rv);\n",
        "        return rv;\n",
        "    }\n",
        "    rv = bpf_setsockopt (skops, SOL_IPV6, IPV6_UNICAST_HOPS, & old_hops, sizeof (int));\n",
        "    if (rv)\n",
        "        bpf_debug (\"Cannot reset Hop Limit to %d: %d\\n\", old_hops, rv);\n",
        "    rv = bpf_start_timer (skops, 10, BASE_OP + increment_hops);\n",
        "    if (rv)\n",
        "        bpf_debug (\"Failed to start timer with error: %d\\n\", rv);\n",
        "    return !!rv;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    },
    {
      "capabilities": [
        {
          "capability": "read_sys_info",
          "read_sys_info": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Emulate a call to getsockopt() on the socket associated to <[ bpf_socket ]>(IP: 0) , which must be a full socket. The <[ level ]>(IP: 1) at which the option resides and the name <[ optname ]>(IP: 2) of the option must be specified , see getsockopt(2) for more information. The retrieved value is stored in the structure pointed by opval and of length optlen. This helper actually implements a subset of getsockopt(). It supports the following levels: \u00b7 IPPROTO_TCP , which supports <[ optname ]>(IP: 2) TCP_CONGESTION. \u00b7 IPPROTO_IP , which supports <[ optname ]>(IP: 2) IP_TOS. \u00b7 IPPROTO_IPV6 , which supports <[ optname ]>(IP: 2) IPV6_TCLASS. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_getsockopt",
              "Input Params": [
                "{Type: struct bpf_sock_ops ,Var: *bpf_socket}",
                "{Type:  int ,Var: level}",
                "{Type:  int ,Var: optname}",
                "{Type:  char ,Var: *optval}",
                "{Type:  int ,Var: optlen}"
              ],
              "compatible_hookpoints": [
                "sock_ops"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            }
          ]
        },
        {
          "capability": "update_pkt",
          "update_pkt": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Emulate a call to setsockopt() on the socket associated to <[ bpf_socket ]>(IP: 0) , which must be a full socket. The <[ level ]>(IP: 1) at which the option resides and the name <[ optname ]>(IP: 2) of the option must be specified , see setsockopt(2) for more information. The option value of length <[ optlen ]>(IP: 4) is pointed by optval. This helper actually implements a subset of setsockopt(). It supports the following levels: \u00b7 SOL_SOCKET , which supports the following optnames: SO_RCVBUF , SO_SNDBUF , SO_MAX_PACING_RATE , SO_PRIORITY , SO_RCVLOWAT , SO_MARK. \u00b7 IPPROTO_TCP , which supports the following optnames: TCP_CONGESTION , TCP_BPF_IW , TCP_BPF_SNDCWND_CLAMP. \u00b7 IPPROTO_IP , which supports <[ optname ]>(IP: 2) IP_TOS. \u00b7 IPPROTO_IPV6 , which supports <[ optname ]>(IP: 2) IPV6_TCLASS. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_setsockopt",
              "Input Params": [
                "{Type: struct bpf_sock_ops ,Var: *bpf_socket}",
                "{Type:  int ,Var: level}",
                "{Type:  int ,Var: optname}",
                "{Type:  char ,Var: *optval}",
                "{Type:  int ,Var: optlen}"
              ],
              "compatible_hookpoints": [
                "sock_ops"
              ],
              "capabilities": [
                "update_pkt"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 21,
      "endLine": 57,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/tpc-ebpf/original_source/ebpf_traceroute_parallel.c",
      "funcName": "traceroute",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 5,
          "text": "  * This program is free software; you can redistribute it and/or * modify it under the terms of version 2 of the GNU General Public * License as published by the Free Software Foundation. "
        },
        {
          "start_line": 13,
          "end_line": 13,
          "text": " Always prints"
        },
        {
          "start_line": 16,
          "end_line": 16,
          "text": " This value with the increment_hops cannot exceed 255: the maximum opcode to start the eBPF program"
        },
        {
          "start_line": 24,
          "end_line": 24,
          "text": " Get current Hop Limit"
        },
        {
          "start_line": 32,
          "end_line": 32,
          "text": " Change Hop Limit for probe"
        },
        {
          "start_line": 39,
          "end_line": 39,
          "text": " Send ack probe that should trigger "
        },
        {
          "start_line": 46,
          "end_line": 46,
          "text": " Reset Hop Limit"
        },
        {
          "start_line": 51,
          "end_line": 51,
          "text": " Start timer"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct bpf_sock_ops *skops",
        " int increment_hops"
      ],
      "output": "staticint",
      "helper": [
        "bpf_getsockopt",
        "bpf_setsockopt"
      ],
      "compatibleHookpoints": [
        "sock_ops"
      ],
      "source": [
        "static int traceroute (struct bpf_sock_ops *skops, int increment_hops)\n",
        "{\n",
        "    int rv = 0;\n",
        "    int old_hops = 0;\n",
        "    rv = bpf_getsockopt (skops, SOL_IPV6, IPV6_UNICAST_HOPS, & old_hops, sizeof (int));\n",
        "    if (rv) {\n",
        "        bpf_debug (\"Cannot get Hop Limit: %d\\n\", rv);\n",
        "        return rv;\n",
        "    }\n",
        "    rv = bpf_setsockopt (skops, SOL_IPV6, IPV6_UNICAST_HOPS, & increment_hops, sizeof (int));\n",
        "    if (rv) {\n",
        "        bpf_debug (\"Cannot set Hop Limit to %d: %d\\n\", increment_hops, rv);\n",
        "        return rv;\n",
        "    }\n",
        "    rv = bpf_send_ack (skops);\n",
        "    if (rv) {\n",
        "        bpf_debug (\"Cannot send ack probe: %d\\n\", rv);\n",
        "        return rv;\n",
        "    }\n",
        "    rv = bpf_setsockopt (skops, SOL_IPV6, IPV6_UNICAST_HOPS, & old_hops, sizeof (int));\n",
        "    if (rv)\n",
        "        bpf_debug (\"Cannot reset Hop Limit to %d: %d\\n\", old_hops, rv);\n",
        "    rv = bpf_start_timer (skops, 10, BASE_OP + increment_hops);\n",
        "    if (rv)\n",
        "        bpf_debug (\"Failed to start timer with error: %d\\n\", rv);\n",
        "    return !!rv;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "take_snapshot": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        },
        {
          "capability": "read_sys_info",
          "read_sys_info": [
            {
              "Project": "bcc",
              "FunctionName": "bpf_ktime_get_ns",
              "Return Type": "u64",
              "Description": "u64 bpf_ktime_get_ns(void) Return: u64 number of nanoseconds. Starts at system boot time but stops during suspend. Examples in situ: \"https://github.com/iovisor/bcc/search?q=bpf_ktime_get_ns+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=bpf_ktime_get_ns+path%3Atools&type=Code search /tools ",
              "Return": "u64 number of nanoseconds",
              "Input Prameters": [],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 53,
      "endLine": 96,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/tpc-ebpf/original_source/ebpf_exp3_lowest_delay.h",
      "funcName": "take_snapshot",
      "developer_inline_comments": [
        {
          "start_line": 8,
          "end_line": 8,
          "text": " Count the number of RTT in the connection, this is useful to know if congestion signals are consecutive or not"
        },
        {
          "start_line": 9,
          "end_line": 9,
          "text": " Count the number of consecutive CWR sent (either from ECN or other causes)"
        },
        {
          "start_line": 10,
          "end_line": 10,
          "text": " The index of the last RTT were we sent an CWR"
        },
        {
          "start_line": 13,
          "end_line": 13,
          "text": " The reward is computed with the number of bytes exchanged during an amount of time"
        },
        {
          "start_line": 15,
          "end_line": 15,
          "text": " boolean"
        },
        {
          "start_line": 27,
          "end_line": 27,
          "text": " 0 if never used -> we change the lowest sequence id"
        },
        {
          "start_line": 70,
          "end_line": 70,
          "text": "#pragma clang loop unroll(full)"
        }
      ],
      "updateMaps": [
        " st_map"
      ],
      "readMaps": [
        " st_map"
      ],
      "input": [
        "struct bpf_elf_map *st_map",
        " struct dst_infos *dst_info",
        " struct flow_infos *flow_info"
      ],
      "output": "staticvoid",
      "helper": [
        "bpf_map_update_elem",
        "bpf_map_lookup_elem",
        "bpf_ktime_get_ns"
      ],
      "compatibleHookpoints": [
        "kprobe",
        "sk_reuseport",
        "sched_cls",
        "sk_skb",
        "sched_act",
        "tracepoint",
        "socket_filter",
        "xdp",
        "cgroup_sock_addr",
        "flow_dissector",
        "raw_tracepoint_writable",
        "perf_event",
        "sock_ops",
        "cgroup_skb",
        "lwt_seg6local",
        "sk_msg",
        "cgroup_sock",
        "lwt_in",
        "raw_tracepoint",
        "lwt_out",
        "lwt_xmit"
      ],
      "source": [
        "static void take_snapshot (struct bpf_elf_map *st_map, struct dst_infos *dst_info, struct flow_infos *flow_info)\n",
        "{\n",
        "    struct flow_snapshot *curr_snapshot = NULL;\n",
        "    struct snapshot_arg arg = {\n",
        "        .new_snapshot = NULL,\n",
        "        .oldest_seq = 0,\n",
        "        .best_idx = 0,\n",
        "        .max_seq = 0}\n",
        "    ;\n",
        "    curr_snapshot = (void *) bpf_map_lookup_elem (st_map, &arg.best_idx);\n",
        "    if (curr_snapshot) {\n",
        "        arg.new_snapshot = curr_snapshot;\n",
        "        arg.oldest_seq = curr_snapshot->sequence;\n",
        "        arg.max_seq = curr_snapshot->sequence;\n",
        "    }\n",
        "    for (int i = 0; i <= MAX_SNAPSHOTS - 1; i++) {\n",
        "        int xxx = i;\n",
        "        curr_snapshot = (void *) bpf_map_lookup_elem (st_map, &xxx);\n",
        "        if (curr_snapshot) {\n",
        "            if (arg.max_seq < curr_snapshot->sequence) {\n",
        "                arg.max_seq = curr_snapshot->sequence;\n",
        "            }\n",
        "            if (arg.oldest_seq > curr_snapshot->sequence) {\n",
        "                arg.oldest_seq = curr_snapshot->sequence;\n",
        "                arg.new_snapshot = curr_snapshot;\n",
        "                arg.best_idx = xxx;\n",
        "            }\n",
        "        }\n",
        "    }\n",
        "    if (arg.new_snapshot) {\n",
        "        memcpy (&arg.new_snapshot->dest, &dst_info->dest, sizeof (struct ip6_addr_t));\n",
        "        memcpy (arg.new_snapshot->exp3_weight, dst_info->exp3_weight, sizeof (floating) * MAX_SRH_BY_DEST);\n",
        "        arg.new_snapshot->sequence = arg.max_seq + 1;\n",
        "        arg.new_snapshot->time = bpf_ktime_get_ns ();\n",
        "        arg.new_snapshot->srh_id = flow_info->srh_id;\n",
        "        arg.new_snapshot->reward = flow_info->exp3_curr_reward;\n",
        "        bpf_map_update_elem (st_map, &arg.best_idx, arg.new_snapshot, BPF_ANY);\n",
        "    }\n",
        "    else {\n",
        "        bpf_debug (\"HERE STAT FAIL\\n\");\n",
        "    }\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    },
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        },
        {
          "capability": "read_sys_info",
          "read_sys_info": [
            {
              "Project": "bcc",
              "FunctionName": "bpf_ktime_get_ns",
              "Return Type": "u64",
              "Description": "u64 bpf_ktime_get_ns(void) Return: u64 number of nanoseconds. Starts at system boot time but stops during suspend. Examples in situ: \"https://github.com/iovisor/bcc/search?q=bpf_ktime_get_ns+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=bpf_ktime_get_ns+path%3Atools&type=Code search /tools ",
              "Return": "u64 number of nanoseconds",
              "Input Prameters": [],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 53,
      "endLine": 96,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/tpc-ebpf/original_source/ebpf_exp3_lowest_completion.h",
      "funcName": "take_snapshot",
      "developer_inline_comments": [
        {
          "start_line": 8,
          "end_line": 8,
          "text": " Count the number of RTT in the connection, this is useful to know if congestion signals are consecutive or not"
        },
        {
          "start_line": 9,
          "end_line": 9,
          "text": " Count the number of consecutive CWR sent (either from ECN or other causes)"
        },
        {
          "start_line": 10,
          "end_line": 10,
          "text": " The index of the last RTT were we sent an CWR"
        },
        {
          "start_line": 13,
          "end_line": 13,
          "text": " The reward is computed with the number of bytes exchanged during an amount of time"
        },
        {
          "start_line": 27,
          "end_line": 27,
          "text": " 0 if never used -> we change the lowest sequence id"
        },
        {
          "start_line": 70,
          "end_line": 70,
          "text": "#pragma clang loop unroll(full)"
        }
      ],
      "updateMaps": [
        " st_map"
      ],
      "readMaps": [
        " st_map"
      ],
      "input": [
        "struct bpf_elf_map *st_map",
        " struct dst_infos *dst_info",
        " struct flow_infos *flow_info"
      ],
      "output": "staticvoid",
      "helper": [
        "bpf_map_update_elem",
        "bpf_map_lookup_elem",
        "bpf_ktime_get_ns"
      ],
      "compatibleHookpoints": [
        "kprobe",
        "sk_reuseport",
        "sched_cls",
        "sk_skb",
        "sched_act",
        "tracepoint",
        "socket_filter",
        "xdp",
        "cgroup_sock_addr",
        "flow_dissector",
        "raw_tracepoint_writable",
        "perf_event",
        "sock_ops",
        "cgroup_skb",
        "lwt_seg6local",
        "sk_msg",
        "cgroup_sock",
        "lwt_in",
        "raw_tracepoint",
        "lwt_out",
        "lwt_xmit"
      ],
      "source": [
        "static void take_snapshot (struct bpf_elf_map *st_map, struct dst_infos *dst_info, struct flow_infos *flow_info)\n",
        "{\n",
        "    struct flow_snapshot *curr_snapshot = NULL;\n",
        "    struct snapshot_arg arg = {\n",
        "        .new_snapshot = NULL,\n",
        "        .oldest_seq = 0,\n",
        "        .best_idx = 0,\n",
        "        .max_seq = 0}\n",
        "    ;\n",
        "    curr_snapshot = (void *) bpf_map_lookup_elem (st_map, &arg.best_idx);\n",
        "    if (curr_snapshot) {\n",
        "        arg.new_snapshot = curr_snapshot;\n",
        "        arg.oldest_seq = curr_snapshot->sequence;\n",
        "        arg.max_seq = curr_snapshot->sequence;\n",
        "    }\n",
        "    for (int i = 0; i <= MAX_SNAPSHOTS - 1; i++) {\n",
        "        int xxx = i;\n",
        "        curr_snapshot = (void *) bpf_map_lookup_elem (st_map, &xxx);\n",
        "        if (curr_snapshot) {\n",
        "            if (arg.max_seq < curr_snapshot->sequence) {\n",
        "                arg.max_seq = curr_snapshot->sequence;\n",
        "            }\n",
        "            if (arg.oldest_seq > curr_snapshot->sequence) {\n",
        "                arg.oldest_seq = curr_snapshot->sequence;\n",
        "                arg.new_snapshot = curr_snapshot;\n",
        "                arg.best_idx = xxx;\n",
        "            }\n",
        "        }\n",
        "    }\n",
        "    if (arg.new_snapshot) {\n",
        "        memcpy (&arg.new_snapshot->dest, &dst_info->dest, sizeof (struct ip6_addr_t));\n",
        "        memcpy (arg.new_snapshot->exp3_weight, dst_info->exp3_weight, sizeof (floating) * MAX_SRH_BY_DEST);\n",
        "        arg.new_snapshot->sequence = arg.max_seq + 1;\n",
        "        arg.new_snapshot->time = bpf_ktime_get_ns ();\n",
        "        arg.new_snapshot->srh_id = flow_info->srh_id;\n",
        "        arg.new_snapshot->reward = flow_info->exp3_curr_reward;\n",
        "        bpf_map_update_elem (st_map, &arg.best_idx, arg.new_snapshot, BPF_ANY);\n",
        "    }\n",
        "    else {\n",
        "        bpf_debug (\"HERE STAT FAIL\\n\");\n",
        "    }\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    },
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        },
        {
          "capability": "read_sys_info",
          "read_sys_info": [
            {
              "Project": "bcc",
              "FunctionName": "bpf_ktime_get_ns",
              "Return Type": "u64",
              "Description": "u64 bpf_ktime_get_ns(void) Return: u64 number of nanoseconds. Starts at system boot time but stops during suspend. Examples in situ: \"https://github.com/iovisor/bcc/search?q=bpf_ktime_get_ns+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=bpf_ktime_get_ns+path%3Atools&type=Code search /tools ",
              "Return": "u64 number of nanoseconds",
              "Input Prameters": [],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 30,
      "endLine": 71,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/tpc-ebpf/original_source/ebpf_reverse_srh.h",
      "funcName": "take_snapshot",
      "developer_inline_comments": [
        {
          "start_line": 7,
          "end_line": 7,
          "text": " 0 if never used -> we change the lowest sequence id"
        },
        {
          "start_line": 47,
          "end_line": 47,
          "text": "#pragma clang loop unroll(full)"
        }
      ],
      "updateMaps": [
        " st_map"
      ],
      "readMaps": [
        " st_map"
      ],
      "input": [
        "struct bpf_elf_map *st_map",
        " struct ip6_srh_t *srh"
      ],
      "output": "staticvoid",
      "helper": [
        "bpf_map_update_elem",
        "bpf_map_lookup_elem",
        "bpf_ktime_get_ns"
      ],
      "compatibleHookpoints": [
        "kprobe",
        "sk_reuseport",
        "sched_cls",
        "sk_skb",
        "sched_act",
        "tracepoint",
        "socket_filter",
        "xdp",
        "cgroup_sock_addr",
        "flow_dissector",
        "raw_tracepoint_writable",
        "perf_event",
        "sock_ops",
        "cgroup_skb",
        "lwt_seg6local",
        "sk_msg",
        "cgroup_sock",
        "lwt_in",
        "raw_tracepoint",
        "lwt_out",
        "lwt_xmit"
      ],
      "source": [
        "static void take_snapshot (struct bpf_elf_map *st_map, struct ip6_srh_t *srh)\n",
        "{\n",
        "    struct flow_snapshot *curr_snapshot = NULL;\n",
        "    struct snapshot_arg arg = {\n",
        "        .new_snapshot = NULL,\n",
        "        .oldest_seq = 0,\n",
        "        .best_idx = 0,\n",
        "        .max_seq = 0}\n",
        "    ;\n",
        "    curr_snapshot = (void *) bpf_map_lookup_elem (st_map, &arg.best_idx);\n",
        "    if (curr_snapshot) {\n",
        "        arg.new_snapshot = curr_snapshot;\n",
        "        arg.oldest_seq = curr_snapshot->sequence;\n",
        "        arg.max_seq = curr_snapshot->sequence;\n",
        "    }\n",
        "    for (int i = 0; i <= MAX_SNAPSHOTS - 1; i++) {\n",
        "        int xxx = i;\n",
        "        curr_snapshot = (void *) bpf_map_lookup_elem (st_map, &xxx);\n",
        "        if (curr_snapshot) {\n",
        "            if (arg.max_seq < curr_snapshot->sequence) {\n",
        "                arg.max_seq = curr_snapshot->sequence;\n",
        "            }\n",
        "            if (arg.oldest_seq > curr_snapshot->sequence) {\n",
        "                arg.oldest_seq = curr_snapshot->sequence;\n",
        "                arg.new_snapshot = curr_snapshot;\n",
        "                arg.best_idx = xxx;\n",
        "            }\n",
        "        }\n",
        "    }\n",
        "    if (arg.new_snapshot) {\n",
        "        if (srh)\n",
        "            memcpy (&(arg.new_snapshot->srh), srh, sizeof (*srh));\n",
        "        arg.new_snapshot->sequence = arg.max_seq + 1;\n",
        "        arg.new_snapshot->time = bpf_ktime_get_ns ();\n",
        "        bpf_map_update_elem (st_map, &arg.best_idx, arg.new_snapshot, BPF_ANY);\n",
        "    }\n",
        "    else {\n",
        "        bpf_debug (\"HERE STAT FAIL\\n\");\n",
        "    }\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    },
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        },
        {
          "capability": "read_sys_info",
          "read_sys_info": [
            {
              "Project": "bcc",
              "FunctionName": "bpf_ktime_get_ns",
              "Return Type": "u64",
              "Description": "u64 bpf_ktime_get_ns(void) Return: u64 number of nanoseconds. Starts at system boot time but stops during suspend. Examples in situ: \"https://github.com/iovisor/bcc/search?q=bpf_ktime_get_ns+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=bpf_ktime_get_ns+path%3Atools&type=Code search /tools ",
              "Return": "u64 number of nanoseconds",
              "Input Prameters": [],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 47,
      "endLine": 88,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/tpc-ebpf/original_source/ebpf_n_rto_changer.h",
      "funcName": "take_snapshot",
      "developer_inline_comments": [
        {
          "start_line": 16,
          "end_line": 16,
          "text": " 0 if never used -> we change the lowest sequence id"
        },
        {
          "start_line": 64,
          "end_line": 64,
          "text": "#pragma clang loop unroll(full)"
        },
        {
          "start_line": 79,
          "end_line": 79,
          "text": "bpf_debug(\"SNAP at index %u - %u -> %u\\n\", arg.best_idx, flow_id->local_port, flow_id->remote_port);"
        }
      ],
      "updateMaps": [
        " st_map"
      ],
      "readMaps": [
        " st_map"
      ],
      "input": [
        "struct bpf_elf_map *st_map",
        " struct flow_infos *flow_info",
        " struct flow_tuple *flow_id",
        " __u32 op"
      ],
      "output": "staticvoid",
      "helper": [
        "bpf_map_update_elem",
        "bpf_map_lookup_elem",
        "bpf_ktime_get_ns"
      ],
      "compatibleHookpoints": [
        "kprobe",
        "sk_reuseport",
        "sched_cls",
        "sk_skb",
        "sched_act",
        "tracepoint",
        "socket_filter",
        "xdp",
        "cgroup_sock_addr",
        "flow_dissector",
        "raw_tracepoint_writable",
        "perf_event",
        "sock_ops",
        "cgroup_skb",
        "lwt_seg6local",
        "sk_msg",
        "cgroup_sock",
        "lwt_in",
        "raw_tracepoint",
        "lwt_out",
        "lwt_xmit"
      ],
      "source": [
        "static void take_snapshot (struct bpf_elf_map *st_map, struct flow_infos *flow_info, struct flow_tuple *flow_id, __u32 op)\n",
        "{\n",
        "    struct flow_snapshot *curr_snapshot = NULL;\n",
        "    struct snapshot_arg arg = {\n",
        "        .new_snapshot = NULL,\n",
        "        .oldest_seq = 0,\n",
        "        .best_idx = 0,\n",
        "        .max_seq = 0}\n",
        "    ;\n",
        "    curr_snapshot = (void *) bpf_map_lookup_elem (st_map, &arg.best_idx);\n",
        "    if (curr_snapshot) {\n",
        "        arg.new_snapshot = curr_snapshot;\n",
        "        arg.oldest_seq = curr_snapshot->sequence;\n",
        "        arg.max_seq = curr_snapshot->sequence;\n",
        "    }\n",
        "    for (int i = 0; i <= MAX_SNAPSHOTS - 1; i++) {\n",
        "        int xxx = i;\n",
        "        curr_snapshot = (void *) bpf_map_lookup_elem (st_map, &xxx);\n",
        "        if (curr_snapshot) {\n",
        "            if (arg.max_seq < curr_snapshot->sequence) {\n",
        "                arg.max_seq = curr_snapshot->sequence;\n",
        "            }\n",
        "            if (arg.oldest_seq > curr_snapshot->sequence) {\n",
        "                arg.oldest_seq = curr_snapshot->sequence;\n",
        "                arg.new_snapshot = curr_snapshot;\n",
        "                arg.best_idx = xxx;\n",
        "            }\n",
        "        }\n",
        "    }\n",
        "    if (arg.new_snapshot) {\n",
        "        memcpy (&arg.new_snapshot->flow, flow_info, sizeof (struct flow_infos));\n",
        "        memcpy (&arg.new_snapshot->flow_id, flow_id, sizeof (struct flow_tuple));\n",
        "        arg.new_snapshot->sequence = arg.max_seq + 1;\n",
        "        arg.new_snapshot->time = bpf_ktime_get_ns ();\n",
        "        arg.new_snapshot->reason = op;\n",
        "        bpf_map_update_elem (st_map, &arg.best_idx, arg.new_snapshot, BPF_ANY);\n",
        "    }\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    },
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        },
        {
          "capability": "read_sys_info",
          "read_sys_info": [
            {
              "Project": "bcc",
              "FunctionName": "bpf_ktime_get_ns",
              "Return Type": "u64",
              "Description": "u64 bpf_ktime_get_ns(void) Return: u64 number of nanoseconds. Starts at system boot time but stops during suspend. Examples in situ: \"https://github.com/iovisor/bcc/search?q=bpf_ktime_get_ns+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=bpf_ktime_get_ns+path%3Atools&type=Code search /tools ",
              "Return": "u64 number of nanoseconds",
              "Input Prameters": [],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 49,
      "endLine": 89,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/tpc-ebpf/original_source/ebpf_timeout_changer.h",
      "funcName": "take_snapshot",
      "developer_inline_comments": [
        {
          "start_line": 6,
          "end_line": 6,
          "text": " ns -> 700ms"
        },
        {
          "start_line": 10,
          "end_line": 10,
          "text": " == min(time of last RTT, time of last path change)"
        },
        {
          "start_line": 18,
          "end_line": 18,
          "text": " 0 if never used -> we change the lowest sequence id"
        },
        {
          "start_line": 66,
          "end_line": 66,
          "text": "#pragma clang loop unroll(full)"
        }
      ],
      "updateMaps": [
        " st_map"
      ],
      "readMaps": [
        " st_map"
      ],
      "input": [
        "struct bpf_elf_map *st_map",
        " struct flow_infos *flow_info",
        " struct flow_tuple *flow_id",
        " __u32 op"
      ],
      "output": "staticvoid",
      "helper": [
        "bpf_map_update_elem",
        "bpf_map_lookup_elem",
        "bpf_ktime_get_ns"
      ],
      "compatibleHookpoints": [
        "kprobe",
        "sk_reuseport",
        "sched_cls",
        "sk_skb",
        "sched_act",
        "tracepoint",
        "socket_filter",
        "xdp",
        "cgroup_sock_addr",
        "flow_dissector",
        "raw_tracepoint_writable",
        "perf_event",
        "sock_ops",
        "cgroup_skb",
        "lwt_seg6local",
        "sk_msg",
        "cgroup_sock",
        "lwt_in",
        "raw_tracepoint",
        "lwt_out",
        "lwt_xmit"
      ],
      "source": [
        "static void take_snapshot (struct bpf_elf_map *st_map, struct flow_infos *flow_info, struct flow_tuple *flow_id, __u32 op)\n",
        "{\n",
        "    struct flow_snapshot *curr_snapshot = NULL;\n",
        "    struct snapshot_arg arg = {\n",
        "        .new_snapshot = NULL,\n",
        "        .oldest_seq = 0,\n",
        "        .best_idx = 0,\n",
        "        .max_seq = 0}\n",
        "    ;\n",
        "    curr_snapshot = (void *) bpf_map_lookup_elem (st_map, &arg.best_idx);\n",
        "    if (curr_snapshot) {\n",
        "        arg.new_snapshot = curr_snapshot;\n",
        "        arg.oldest_seq = curr_snapshot->sequence;\n",
        "        arg.max_seq = curr_snapshot->sequence;\n",
        "    }\n",
        "    for (int i = 0; i <= MAX_SNAPSHOTS - 1; i++) {\n",
        "        int xxx = i;\n",
        "        curr_snapshot = (void *) bpf_map_lookup_elem (st_map, &xxx);\n",
        "        if (curr_snapshot) {\n",
        "            if (arg.max_seq < curr_snapshot->sequence) {\n",
        "                arg.max_seq = curr_snapshot->sequence;\n",
        "            }\n",
        "            if (arg.oldest_seq > curr_snapshot->sequence) {\n",
        "                arg.oldest_seq = curr_snapshot->sequence;\n",
        "                arg.new_snapshot = curr_snapshot;\n",
        "                arg.best_idx = xxx;\n",
        "            }\n",
        "        }\n",
        "    }\n",
        "    if (arg.new_snapshot) {\n",
        "        memcpy (&arg.new_snapshot->flow, flow_info, sizeof (struct flow_infos));\n",
        "        memcpy (&arg.new_snapshot->flow_id, flow_id, sizeof (struct flow_tuple));\n",
        "        arg.new_snapshot->sequence = arg.max_seq + 1;\n",
        "        arg.new_snapshot->time = bpf_ktime_get_ns ();\n",
        "        arg.new_snapshot->reason = op;\n",
        "        bpf_map_update_elem (st_map, &arg.best_idx, arg.new_snapshot, BPF_ANY);\n",
        "    }\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "exp3_reward_path": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 98,
      "endLine": 255,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/tpc-ebpf/original_source/ebpf_exp3_lowest_delay.h",
      "funcName": "exp3_reward_path",
      "developer_inline_comments": [
        {
          "start_line": 100,
          "end_line": 103,
          "text": "\ttheReward = reward(choice, t)\tweights[choice] *= math.exp(theReward / (probabilityDistribution[choice] * gamma_rev * numActions)) # important that we use estimated reward here!\t"
        },
        {
          "start_line": 118,
          "end_line": 118,
          "text": " Compute max reward (in ms)"
        },
        {
          "start_line": 119,
          "end_line": 119,
          "text": " TODO Hardcoded factor"
        },
        {
          "start_line": 123,
          "end_line": 123,
          "text": " Compute new reward (in ms)"
        },
        {
          "start_line": 125,
          "end_line": 125,
          "text": " TODO Hardcoded mean delay (should be a moving average)"
        },
        {
          "start_line": 126,
          "end_line": 126,
          "text": " TODO Hardcoded mean delay (should be a moving average)"
        },
        {
          "start_line": 129,
          "end_line": 129,
          "text": " TODO Hardcoded mean delay (should be a moving average)"
        },
        {
          "start_line": 133,
          "end_line": 133,
          "text": " TODO Remove"
        },
        {
          "start_line": 139,
          "end_line": 139,
          "text": " reward should be in [0, 1]"
        },
        {
          "start_line": 140,
          "end_line": 140,
          "text": " TODO Remove"
        },
        {
          "start_line": 141,
          "end_line": 141,
          "text": " TODO Remove"
        },
        {
          "start_line": 143,
          "end_line": 143,
          "text": " Compute new weight"
        },
        {
          "start_line": 145,
          "end_line": 145,
          "text": " TODO Remove"
        },
        {
          "start_line": 146,
          "end_line": 146,
          "text": " TODO Remove"
        },
        {
          "start_line": 148,
          "end_line": 148,
          "text": " TODO Remove"
        },
        {
          "start_line": 149,
          "end_line": 149,
          "text": " TODO Remove"
        },
        {
          "start_line": 151,
          "end_line": 151,
          "text": " TODO Remove"
        },
        {
          "start_line": 152,
          "end_line": 152,
          "text": " TODO Remove"
        },
        {
          "start_line": 157,
          "end_line": 157,
          "text": " TODO Remove"
        },
        {
          "start_line": 158,
          "end_line": 158,
          "text": " TODO Remove"
        },
        {
          "start_line": 163,
          "end_line": 163,
          "text": " TODO Remove"
        },
        {
          "start_line": 164,
          "end_line": 164,
          "text": " TODO Remove"
        },
        {
          "start_line": 167,
          "end_line": 167,
          "text": " TODO Remove"
        },
        {
          "start_line": 168,
          "end_line": 168,
          "text": " TODO Remove"
        },
        {
          "start_line": 171,
          "end_line": 171,
          "text": " Always true but this is for eBPF loader"
        },
        {
          "start_line": 173,
          "end_line": 173,
          "text": " TODO Remove"
        },
        {
          "start_line": 174,
          "end_line": 174,
          "text": " TODO Remove"
        },
        {
          "start_line": 177,
          "end_line": 177,
          "text": " If negative reward, divide because of a negative exponent ^^"
        },
        {
          "start_line": 183,
          "end_line": 183,
          "text": " TODO Remove"
        },
        {
          "start_line": 184,
          "end_line": 184,
          "text": " TODO Remove"
        },
        {
          "start_line": 185,
          "end_line": 185,
          "text": " TODO Remove"
        },
        {
          "start_line": 189,
          "end_line": 189,
          "text": " TODO Reset weights"
        },
        {
          "start_line": 195,
          "end_line": 195,
          "text": " Compiler cannot unroll otherwise"
        },
        {
          "start_line": 198,
          "end_line": 198,
          "text": " Wrong SRH ID -> might be inconsistent state, so skip"
        },
        {
          "start_line": 199,
          "end_line": 199,
          "text": " Not a valid SRH for the destination"
        },
        {
          "start_line": 200,
          "end_line": 200,
          "text": " Same SRH"
        },
        {
          "start_line": 201,
          "end_line": 201,
          "text": " 1"
        },
        {
          "start_line": 202,
          "end_line": 202,
          "text": "bpf_debug(\"Cannot find the SRH entry indexed at %d at a dest entry\\n\", i);"
        },
        {
          "start_line": 206,
          "end_line": 206,
          "text": " 1"
        },
        {
          "start_line": 207,
          "end_line": 207,
          "text": "bpf_debug(\"SRH entry indexed at %d by the dest entry is invalid\\n\", i);"
        },
        {
          "start_line": 208,
          "end_line": 208,
          "text": " Not a valid SRH for the destination"
        },
        {
          "start_line": 213,
          "end_line": 213,
          "text": " bpf_debug(\"HERE %llu %u\\n\", operands[1].mantissa, operands[1].exponent);  TODO Remove"
        },
        {
          "start_line": 214,
          "end_line": 214,
          "text": " TODO Remove"
        },
        {
          "start_line": 215,
          "end_line": 215,
          "text": " TODO Remove"
        },
        {
          "start_line": 224,
          "end_line": 224,
          "text": " Compiler cannot unroll otherwise"
        },
        {
          "start_line": 227,
          "end_line": 227,
          "text": " Wrong SRH ID -> might be inconsistent state, so skip"
        },
        {
          "start_line": 228,
          "end_line": 228,
          "text": " Not a valid SRH for the destination"
        },
        {
          "start_line": 229,
          "end_line": 229,
          "text": " Same SRH"
        },
        {
          "start_line": 230,
          "end_line": 230,
          "text": " 1"
        },
        {
          "start_line": 231,
          "end_line": 231,
          "text": "bpf_debug(\"Cannot find the SRH entry indexed at %d at a dest entry\\n\", i);"
        },
        {
          "start_line": 235,
          "end_line": 235,
          "text": " 1"
        },
        {
          "start_line": 236,
          "end_line": 236,
          "text": "bpf_debug(\"SRH entry indexed at %d by the dest entry is invalid\\n\", i);"
        },
        {
          "start_line": 237,
          "end_line": 237,
          "text": " Not a valid SRH for the destination"
        },
        {
          "start_line": 248,
          "end_line": 248,
          "text": " Minimum 1 for weights"
        },
        {
          "start_line": 252,
          "end_line": 252,
          "text": " TODO Remove"
        },
        {
          "start_line": 253,
          "end_line": 253,
          "text": " TODO Remove"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct flow_infos *flow_info",
        " struct dst_infos *dst_infos",
        " struct bpf_sock_ops *skops"
      ],
      "output": "staticvoid",
      "helper": [],
      "compatibleHookpoints": [
        "kprobe",
        "sk_reuseport",
        "sched_cls",
        "sk_skb",
        "sched_act",
        "cgroup_sysctl",
        "socket_filter",
        "tracepoint",
        "xdp",
        "cgroup_sock_addr",
        "flow_dissector",
        "raw_tracepoint_writable",
        "perf_event",
        "sock_ops",
        "cgroup_skb",
        "lwt_seg6local",
        "cgroup_device",
        "sk_msg",
        "cgroup_sock",
        "lwt_in",
        "raw_tracepoint",
        "lwt_out",
        "lwt_xmit"
      ],
      "source": [
        "static void exp3_reward_path (struct flow_infos *flow_info, struct dst_infos *dst_infos, struct bpf_sock_ops *skops)\n",
        "{\n",
        "    floating gamma_rev;\n",
        "    floating reward;\n",
        "    floating exponent_den_factor;\n",
        "    floating exponent_den;\n",
        "    floating nbr_actions;\n",
        "    floating exponent;\n",
        "    floating weight_factor;\n",
        "    floating float_tmp, float_tmp2;\n",
        "    floating operands [2];\n",
        "    __u32 decimal [2];\n",
        "    __u32 srtt;\n",
        "    floating max_reward;\n",
        "    bpf_to_floating (MAX_REWARD_FACTOR, 0, 1, &max_reward, sizeof (floating));\n",
        "    GAMMA_REV (gamma_rev);\n",
        "    srtt = (skops->srtt_us >> 3) / 1000;\n",
        "    if (srtt <= 23) {\n",
        "        flow_info->exp3_curr_reward = 23 - srtt;\n",
        "        flow_info->negative_reward = 0;\n",
        "    }\n",
        "    else {\n",
        "        flow_info->exp3_curr_reward = srtt - 23;\n",
        "        flow_info->negative_reward = 1;\n",
        "    }\n",
        "    bpf_debug (\"HERE reward %u for path %u - negative ? %d\\n\", flow_info->exp3_curr_reward, flow_info->srh_id, flow_info->negative_reward);\n",
        "    bpf_to_floating (flow_info->exp3_curr_reward, 0, 1, &reward, sizeof (floating));\n",
        "    bpf_to_floating (flow_info->exp3_last_number_actions, 1, 0, &nbr_actions, sizeof (floating));\n",
        "    set_floating (operands[0], reward);\n",
        "    set_floating (operands[1], max_reward);\n",
        "    bpf_floating_divide (operands, sizeof (floating) * 2, &reward, sizeof (floating));\n",
        "    bpf_floating_to_u32s (&reward, sizeof (floating), (__u64 *) decimal, sizeof (decimal));\n",
        "    bpf_debug (\"HERE-norm-reward %llu.%llu\\n\", decimal[0], decimal[1]);\n",
        "    set_floating (operands[0], flow_info->exp3_last_probability);\n",
        "    bpf_floating_to_u32s (&flow_info->exp3_last_probability, sizeof (floating), (__u64 *) decimal, sizeof (decimal));\n",
        "    bpf_debug (\"HERE-exponent_den_factor %llu.%llu\\n\", decimal[0], decimal[1]);\n",
        "    set_floating (operands[1], gamma_rev);\n",
        "    bpf_floating_to_u32s (&gamma_rev, sizeof (floating), (__u64 *) decimal, sizeof (decimal));\n",
        "    bpf_debug (\"HERE-exponent_den_factor %llu.%llu\\n\", decimal[0], decimal[1]);\n",
        "    bpf_floating_multiply (operands, sizeof (floating) * 2, &exponent_den_factor, sizeof (floating));\n",
        "    bpf_floating_to_u32s (&exponent_den_factor, sizeof (floating), (__u64 *) decimal, sizeof (decimal));\n",
        "    bpf_debug (\"HERE-exponent_den_factor %llu.%llu\\n\", decimal[0], decimal[1]);\n",
        "    set_floating (operands[0], exponent_den_factor);\n",
        "    set_floating (operands[1], nbr_actions);\n",
        "    bpf_floating_multiply (operands, sizeof (floating) * 2, &exponent_den, sizeof (floating));\n",
        "    bpf_floating_to_u32s (&exponent_den, sizeof (floating), (__u64 *) decimal, sizeof (decimal));\n",
        "    bpf_debug (\"HERE-exponent_den %llu.%llu\\n\", decimal[0], decimal[1]);\n",
        "    set_floating (operands[0], reward);\n",
        "    set_floating (operands[1], exponent_den);\n",
        "    bpf_floating_divide (operands, sizeof (floating) * 2, &exponent, sizeof (floating));\n",
        "    bpf_floating_to_u32s (&exponent, sizeof (floating), (__u64 *) decimal, sizeof (decimal));\n",
        "    bpf_debug (\"HERE-exponent %llu.%llu\\n\", decimal[0], decimal[1]);\n",
        "    bpf_floating_e_power_a (&exponent, sizeof (floating), &weight_factor, sizeof (floating));\n",
        "    bpf_floating_to_u32s (&weight_factor, sizeof (floating), (__u64 *) decimal, sizeof (decimal));\n",
        "    bpf_debug (\"HERE-factor %llu.%llu\\n\", decimal[0], decimal[1]);\n",
        "    __u32 idx = flow_info->srh_id;\n",
        "    if (idx >= 0 && idx <= MAX_SRH_BY_DEST - 1) {\n",
        "        exp3_weight_get (dst_infos, idx, float_tmp);\n",
        "        bpf_floating_to_u32s (&float_tmp, sizeof (floating), (__u64 *) decimal, sizeof (decimal));\n",
        "        bpf_debug (\"HERE-old-weight %llu.%llu\\n\", decimal[0], decimal[1]);\n",
        "        set_floating (operands[0], float_tmp);\n",
        "        set_floating (operands[1], weight_factor);\n",
        "        if (flow_info->negative_reward) {\n",
        "            bpf_floating_divide (operands, sizeof (floating) * 2, &float_tmp2, sizeof (floating));\n",
        "        }\n",
        "        else {\n",
        "            bpf_floating_multiply (operands, sizeof (floating) * 2, &float_tmp2, sizeof (floating));\n",
        "        }\n",
        "        bpf_debug (\"HERE-new-weight %llu %u\\n\", float_tmp2.mantissa, float_tmp2.exponent);\n",
        "        bpf_floating_to_u32s (&float_tmp2, sizeof (floating), (__u64 *) decimal, sizeof (decimal));\n",
        "        bpf_debug (\"HERE-new-weight %llu.%llu\\n\", decimal[0], decimal[1]);\n",
        "        exp3_weight_set (dst_infos, idx, float_tmp2);\n",
        "    }\n",
        "    floating sum;\n",
        "    bpf_to_floating (0, 0, 1, &sum, sizeof (floating));\n",
        "    struct srh_record_t *srh_record = NULL;\n",
        "\n",
        "#pragma clang loop unroll(full)\n",
        "    for (__u32 i = 0; i <= MAX_SRH_BY_DEST - 1; i++) {\n",
        "        int xxx = i;\n",
        "        srh_record = &dst_infos->srhs[i];\n",
        "        if (!srh_record || !srh_record->srh.type) {\n",
        "            continue;\n",
        "        }\n",
        "        if (!srh_record->is_valid) {\n",
        "            continue;\n",
        "        }\n",
        "        set_floating (operands[0], sum);\n",
        "        exp3_weight_get (dst_infos, xxx, operands[1]);\n",
        "        bpf_floating_to_u32s (&operands[1], sizeof (floating), (__u64 *) decimal, sizeof (decimal));\n",
        "        bpf_debug (\"BEFORE-1 %llu.%llu\\n\", decimal[0], decimal[1]);\n",
        "        bpf_floating_add (operands, sizeof (floating) * 2, &sum, sizeof (floating));\n",
        "    }\n",
        "    floating nbr_tokens;\n",
        "    bpf_to_floating (NBR_TOKENS, 0, 1, &nbr_tokens, sizeof (floating));\n",
        "\n",
        "#pragma clang loop unroll(full)\n",
        "    for (__u32 i = 0; i <= MAX_SRH_BY_DEST - 1; i++) {\n",
        "        int xxx = i;\n",
        "        srh_record = &dst_infos->srhs[i];\n",
        "        if (!srh_record || !srh_record->srh.type) {\n",
        "            continue;\n",
        "        }\n",
        "        if (!srh_record->is_valid) {\n",
        "            continue;\n",
        "        }\n",
        "        exp3_weight_get (dst_infos, xxx, operands[0]);\n",
        "        set_floating (operands[1], nbr_tokens);\n",
        "        bpf_floating_multiply (operands, sizeof (floating) * 2, &float_tmp, sizeof (floating));\n",
        "        set_floating (operands[0], float_tmp);\n",
        "        set_floating (operands[1], sum);\n",
        "        bpf_floating_divide (operands, sizeof (floating) * 2, &float_tmp, sizeof (floating));\n",
        "        if (float_tmp.exponent >= BIAS) {\n",
        "            exp3_weight_set (dst_infos, xxx, float_tmp);\n",
        "        }\n",
        "        else {\n",
        "            exp3_weight_reset (dst_infos, xxx);\n",
        "        }\n",
        "        exp3_weight_get (dst_infos, xxx, float_tmp);\n",
        "        bpf_floating_to_u32s (&float_tmp, sizeof (floating), (__u64 *) decimal, sizeof (decimal));\n",
        "        bpf_debug (\"AFTER-1 %llu.%llu\\n\", decimal[0], decimal[1]);\n",
        "    }\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 98,
      "endLine": 170,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/tpc-ebpf/original_source/ebpf_exp3_lowest_completion.h",
      "funcName": "exp3_reward_path",
      "developer_inline_comments": [
        {
          "start_line": 100,
          "end_line": 103,
          "text": "\ttheReward = reward(choice, t)\tweights[choice] *= math.exp(theReward / (probabilityDistribution[choice] * gamma_rev * numActions)) # important that we use estimated reward here!\t"
        },
        {
          "start_line": 118,
          "end_line": 118,
          "text": " TODO Compute max reward (in ms)"
        },
        {
          "start_line": 123,
          "end_line": 123,
          "text": " Reward in ms"
        },
        {
          "start_line": 130,
          "end_line": 130,
          "text": " TODO Remove"
        },
        {
          "start_line": 136,
          "end_line": 136,
          "text": " reward should be in [0, 1]"
        },
        {
          "start_line": 137,
          "end_line": 137,
          "text": " TODO Remove"
        },
        {
          "start_line": 138,
          "end_line": 138,
          "text": " TODO Remove"
        },
        {
          "start_line": 140,
          "end_line": 140,
          "text": " Compute new weight"
        },
        {
          "start_line": 154,
          "end_line": 154,
          "text": " TODO Remove"
        },
        {
          "start_line": 155,
          "end_line": 155,
          "text": " TODO Remove"
        },
        {
          "start_line": 158,
          "end_line": 158,
          "text": " Always true but this is for eBPF loader"
        },
        {
          "start_line": 160,
          "end_line": 160,
          "text": " TODO Remove"
        },
        {
          "start_line": 161,
          "end_line": 161,
          "text": " TODO Remove"
        },
        {
          "start_line": 165,
          "end_line": 165,
          "text": " TODO Remove"
        },
        {
          "start_line": 166,
          "end_line": 166,
          "text": " TODO Remove"
        },
        {
          "start_line": 167,
          "end_line": 167,
          "text": " TODO Remove"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct flow_infos *flow_info",
        " struct dst_infos *dst_infos",
        " struct bpf_sock_ops *skops"
      ],
      "output": "staticvoid",
      "helper": [],
      "compatibleHookpoints": [
        "kprobe",
        "sk_reuseport",
        "sched_cls",
        "sk_skb",
        "sched_act",
        "cgroup_sysctl",
        "socket_filter",
        "tracepoint",
        "xdp",
        "cgroup_sock_addr",
        "flow_dissector",
        "raw_tracepoint_writable",
        "perf_event",
        "sock_ops",
        "cgroup_skb",
        "lwt_seg6local",
        "cgroup_device",
        "sk_msg",
        "cgroup_sock",
        "lwt_in",
        "raw_tracepoint",
        "lwt_out",
        "lwt_xmit"
      ],
      "source": [
        "static void exp3_reward_path (struct flow_infos *flow_info, struct dst_infos *dst_infos, struct bpf_sock_ops *skops)\n",
        "{\n",
        "    floating gamma_rev;\n",
        "    floating reward;\n",
        "    floating exponent_den_factor;\n",
        "    floating exponent_den;\n",
        "    floating nbr_actions;\n",
        "    floating exponent;\n",
        "    floating weight_factor;\n",
        "    floating float_tmp, float_tmp2;\n",
        "    floating operands [2];\n",
        "    __u32 decimal [2];\n",
        "    __u32 tmp;\n",
        "    floating max_reward;\n",
        "    bpf_to_floating ((((__u64) 2000) / MAX_REWARD_FACTOR) + 1, 0, 1, &max_reward, sizeof (floating));\n",
        "    GAMMA_REV (gamma_rev);\n",
        "    flow_info->exp3_curr_reward = (__u32) ((flow_info->rtt_timestamp - flow_info->established_timestamp) / ((__u64) 1000000));\n",
        "    if (flow_info->exp3_curr_reward < 2000)\n",
        "        flow_info->exp3_curr_reward = 2000 - flow_info->exp3_curr_reward;\n",
        "    else\n",
        "        flow_info->exp3_curr_reward = 1;\n",
        "    bpf_debug (\"HERE reward %u for path %u\\n\", flow_info->exp3_curr_reward, flow_info->srh_id);\n",
        "    bpf_to_floating (flow_info->exp3_curr_reward, 0, 1, &reward, sizeof (floating));\n",
        "    bpf_to_floating (flow_info->exp3_last_number_actions, 1, 0, &nbr_actions, sizeof (floating));\n",
        "    set_floating (operands[0], reward);\n",
        "    set_floating (operands[1], max_reward);\n",
        "    bpf_floating_divide (operands, sizeof (floating) * 2, &reward, sizeof (floating));\n",
        "    bpf_floating_to_u32s (&reward, sizeof (floating), (__u64 *) decimal, sizeof (decimal));\n",
        "    bpf_debug (\"HERE-norm-reward %llu.%llu\\n\", decimal[0], decimal[1]);\n",
        "    set_floating (operands[0], flow_info->exp3_last_probability);\n",
        "    set_floating (operands[1], gamma_rev);\n",
        "    bpf_floating_multiply (operands, sizeof (floating) * 2, &exponent_den_factor, sizeof (floating));\n",
        "    set_floating (operands[0], exponent_den_factor);\n",
        "    set_floating (operands[1], nbr_actions);\n",
        "    bpf_floating_multiply (operands, sizeof (floating) * 2, &exponent_den, sizeof (floating));\n",
        "    set_floating (operands[0], reward);\n",
        "    set_floating (operands[1], exponent_den);\n",
        "    bpf_floating_divide (operands, sizeof (floating) * 2, &exponent, sizeof (floating));\n",
        "    bpf_floating_e_power_a (&exponent, sizeof (floating), &weight_factor, sizeof (floating));\n",
        "    bpf_floating_to_u32s (&weight_factor, sizeof (floating), (__u64 *) decimal, sizeof (decimal));\n",
        "    bpf_debug (\"HERE-factor %llu.%llu\\n\", decimal[0], decimal[1]);\n",
        "    __u32 idx = flow_info->srh_id;\n",
        "    if (idx >= 0 && idx <= MAX_SRH_BY_DEST - 1) {\n",
        "        exp3_weight_get (dst_infos, idx, float_tmp);\n",
        "        bpf_floating_to_u32s (&float_tmp, sizeof (floating), (__u64 *) decimal, sizeof (decimal));\n",
        "        bpf_debug (\"HERE-old-weight %llu.%llu\\n\", decimal[0], decimal[1]);\n",
        "        set_floating (operands[0], float_tmp);\n",
        "        set_floating (operands[1], weight_factor);\n",
        "        bpf_floating_multiply (operands, sizeof (floating) * 2, &float_tmp2, sizeof (floating));\n",
        "        bpf_debug (\"HERE-new-weight %llu %u\\n\", float_tmp2.mantissa, float_tmp2.exponent);\n",
        "        bpf_floating_to_u32s (&float_tmp2, sizeof (floating), (__u64 *) decimal, sizeof (decimal));\n",
        "        bpf_debug (\"HERE-new-weight %llu.%llu\\n\", decimal[0], decimal[1]);\n",
        "        exp3_weight_set (dst_infos, idx, float_tmp2);\n",
        "    }\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "exp3_next_path": [
    {
      "capabilities": [
        {
          "capability": "read_sys_info",
          "read_sys_info": [
            {
              "Project": "bcc",
              "FunctionName": "bpf_get_prandom_u32",
              "Return Type": "u32",
              "Description": "u32 bpf_get_prandom_u32 Returns a pseudo-random u32. Example in situ: \"https://github.com/iovisor/bcc/search?q=bpf_get_prandom_u32+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=bpf_get_prandom_u32+path%3Atools&type=Code search /tools ",
              "Return": "Returns a pseudo-random u32",
              "Input Prameters": [],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            }
          ]
        },
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 257,
      "endLine": 394,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/tpc-ebpf/original_source/ebpf_exp3_lowest_delay.h",
      "funcName": "exp3_next_path",
      "developer_inline_comments": [
        {
          "start_line": 259,
          "end_line": 278,
          "text": "\tdef distr(weights, gamma=0.0):\t\ttheSum = float(sum(weights))\t\treturn tuple((1.0 - gamma) * (w / theSum) + (gamma / len(weights)) for w in weights)\tdef exp3(numActions, reward, gamma):\t\tweights = [1.0] * numActions\t\tt = 0\t\twhile True:\t\t\tprobabilityDistribution = distr(weights, gamma)\t\t\tchoice = draw(probabilityDistribution)\t\t\ttheReward = reward(choice, t)\t\t\testimatedReward = theReward / probabilityDistribution[choice]\t\t\tweights[choice] *= math.exp(estimatedReward * gamma / numActions) # important that we use estimated reward here!\t\t\tyield choice, theReward, estimatedReward, weights\t\t\tt = t + 1\t"
        },
        {
          "start_line": 293,
          "end_line": 293,
          "text": "bpf_debug(\"Cannot find the destination entry => Cannot find another SRH\\n\");"
        },
        {
          "start_line": 297,
          "end_line": 297,
          "text": " Compute the sum of weights"
        },
        {
          "start_line": 303,
          "end_line": 303,
          "text": " Compiler cannot unroll otherwise"
        },
        {
          "start_line": 306,
          "end_line": 306,
          "text": " Wrong SRH ID -> might be inconsistent state, so skip"
        },
        {
          "start_line": 307,
          "end_line": 307,
          "text": " Not a valid SRH for the destination"
        },
        {
          "start_line": 308,
          "end_line": 308,
          "text": " Same SRH"
        },
        {
          "start_line": 309,
          "end_line": 309,
          "text": " 1"
        },
        {
          "start_line": 310,
          "end_line": 310,
          "text": "bpf_debug(\"Cannot find the SRH entry indexed at %d at a dest entry\\n\", i);"
        },
        {
          "start_line": 314,
          "end_line": 314,
          "text": " 1"
        },
        {
          "start_line": 315,
          "end_line": 315,
          "text": "bpf_debug(\"SRH entry indexed at %d by the dest entry is invalid\\n\", i);"
        },
        {
          "start_line": 316,
          "end_line": 316,
          "text": " Not a valid SRH for the destination"
        },
        {
          "start_line": 321,
          "end_line": 321,
          "text": "bpf_debug(\"HERE %llu %u\\n\", operands[1].mantissa, operands[1].exponent);  TODO Remove"
        },
        {
          "start_line": 322,
          "end_line": 322,
          "text": " TODO Remove"
        },
        {
          "start_line": 323,
          "end_line": 323,
          "text": " TODO Remove"
        },
        {
          "start_line": 328,
          "end_line": 328,
          "text": " TODO Remove"
        },
        {
          "start_line": 329,
          "end_line": 329,
          "text": " TODO Remove"
        },
        {
          "start_line": 330,
          "end_line": 330,
          "text": " TODO Remove"
        },
        {
          "start_line": 332,
          "end_line": 332,
          "text": " Compute the probabilities"
        },
        {
          "start_line": 346,
          "end_line": 346,
          "text": " No problem if FLOAT_MULT < UIN32T_MAX"
        },
        {
          "start_line": 351,
          "end_line": 351,
          "text": " Compiler cannot unroll otherwise"
        },
        {
          "start_line": 354,
          "end_line": 354,
          "text": " Wrong SRH ID -> might be inconsistent state, so skip"
        },
        {
          "start_line": 355,
          "end_line": 355,
          "text": " Not a valid SRH for the destination"
        },
        {
          "start_line": 356,
          "end_line": 356,
          "text": " Same SRH"
        },
        {
          "start_line": 357,
          "end_line": 357,
          "text": " 2"
        },
        {
          "start_line": 358,
          "end_line": 358,
          "text": "bpf_debug(\"Cannot find the SRH entry indexed at %d at a dest entry\\n\", i);"
        },
        {
          "start_line": 362,
          "end_line": 362,
          "text": " 2"
        },
        {
          "start_line": 363,
          "end_line": 363,
          "text": " Not a valid SRH for the destination"
        },
        {
          "start_line": 366,
          "end_line": 366,
          "text": " prob[i] = (1.0 - gamma) * (w[i] / theSum) + (gamma / len(weights))"
        },
        {
          "start_line": 371,
          "end_line": 371,
          "text": "exp3_weight_get(dst_infos, yyy, operands[0]);"
        },
        {
          "start_line": 381,
          "end_line": 381,
          "text": " No need to take the integer part since these are numbers in [0, 1["
        },
        {
          "start_line": 382,
          "end_line": 382,
          "text": " TODO Remove"
        },
        {
          "start_line": 384,
          "end_line": 384,
          "text": " TODO Remove"
        },
        {
          "start_line": 385,
          "end_line": 385,
          "text": " We found the chosen one"
        }
      ],
      "updateMaps": [],
      "readMaps": [
        " dt_map"
      ],
      "input": [
        "struct bpf_elf_map *dt_map",
        " struct flow_infos *flow_info",
        " __u32 *dst_addr"
      ],
      "output": "static__u32",
      "helper": [
        "bpf_get_prandom_u32",
        "bpf_map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "kprobe",
        "sk_reuseport",
        "sched_cls",
        "sk_skb",
        "sched_act",
        "tracepoint",
        "socket_filter",
        "xdp",
        "cgroup_sock_addr",
        "flow_dissector",
        "raw_tracepoint_writable",
        "perf_event",
        "sock_ops",
        "cgroup_skb",
        "lwt_seg6local",
        "sk_msg",
        "cgroup_sock",
        "lwt_in",
        "raw_tracepoint",
        "lwt_out",
        "lwt_xmit"
      ],
      "source": [
        "static __u32 exp3_next_path (struct bpf_elf_map *dt_map, struct flow_infos *flow_info, __u32 *dst_addr)\n",
        "{\n",
        "    floating operands [2];\n",
        "    floating gamma;\n",
        "    GAMMA (gamma);\n",
        "    __u32 decimal [2];\n",
        "    decimal[0] = 0;\n",
        "    decimal[1] = 0;\n",
        "    __u32 chosen_id = 0, current_delay = 0;\n",
        "    struct srh_record_t *srh_record = NULL;\n",
        "    struct dst_infos *dst_infos = NULL;\n",
        "    dst_infos = (void *) bpf_map_lookup_elem (dt_map, dst_addr);\n",
        "    if (!dst_infos) {\n",
        "        return chosen_id;\n",
        "    }\n",
        "    floating sum;\n",
        "    bpf_to_floating (0, 0, 1, &sum, sizeof (floating));\n",
        "    __u32 nbr_valid_paths = 0;\n",
        "\n",
        "#pragma clang loop unroll(full)\n",
        "    for (__u32 i = 0; i <= MAX_SRH_BY_DEST - 1; i++) {\n",
        "        int xxx = i;\n",
        "        srh_record = &dst_infos->srhs[i];\n",
        "        if (!srh_record || !srh_record->srh.type) {\n",
        "            continue;\n",
        "        }\n",
        "        if (!srh_record->is_valid) {\n",
        "            continue;\n",
        "        }\n",
        "        set_floating (operands[0], sum);\n",
        "        exp3_weight_get (dst_infos, xxx, operands[1]);\n",
        "        bpf_floating_to_u32s (&operands[1], sizeof (floating), (__u64 *) decimal, sizeof (decimal));\n",
        "        bpf_debug (\"HERE-2 %llu.%llu\\n\", decimal[0], decimal[1]);\n",
        "        bpf_floating_add (operands, sizeof (floating) * 2, &sum, sizeof (floating));\n",
        "        nbr_valid_paths += 1;\n",
        "    }\n",
        "    bpf_floating_to_u32s (&sum, sizeof (floating), (__u64 *) decimal, sizeof (decimal));\n",
        "    bpf_debug (\"HERE-sum %llu.%llu\\n\", decimal[0], decimal[1]);\n",
        "    bpf_debug (\"HERE-nbr-valid-paths %u\\n\", nbr_valid_paths);\n",
        "    floating probability;\n",
        "    floating one_minus_gamma;\n",
        "    ONE_MINUS_GAMMA (one_minus_gamma);\n",
        "    floating weight_times_gama;\n",
        "    floating term1;\n",
        "    floating valid_paths;\n",
        "    bpf_to_floating (nbr_valid_paths, 0, 1, &valid_paths, sizeof (floating));\n",
        "    floating term2;\n",
        "    set_floating (operands[0], gamma);\n",
        "    set_floating (operands[1], valid_paths);\n",
        "    bpf_floating_divide (operands, sizeof (floating) * 2, &term2, sizeof (floating));\n",
        "    __u64 pick = ((__u64) bpf_get_prandom_u32 ()) % FLOAT_MULT;\n",
        "    __u64 accumulator = 0;\n",
        "\n",
        "#pragma clang loop unroll(full)\n",
        "    for (__u32 i = 0; i <= MAX_SRH_BY_DEST - 1; i++) {\n",
        "        int yyy = i;\n",
        "        srh_record = &dst_infos->srhs[i];\n",
        "        if (!srh_record || !srh_record->srh.type) {\n",
        "            continue;\n",
        "        }\n",
        "        if (!srh_record->is_valid) {\n",
        "            continue;\n",
        "        }\n",
        "        set_floating (operands[0], one_minus_gamma);\n",
        "        exp3_weight_get (dst_infos, yyy, operands[1]);\n",
        "        bpf_floating_multiply (operands, sizeof (floating) * 2, &weight_times_gama, sizeof (floating));\n",
        "        set_floating (operands[0], weight_times_gama);\n",
        "        set_floating (operands[1], sum);\n",
        "        bpf_floating_divide (operands, sizeof (floating) * 2, &term1, sizeof (floating));\n",
        "        set_floating (operands[0], term1);\n",
        "        set_floating (operands[1], term2);\n",
        "        bpf_floating_add (operands, sizeof (floating) * 2, &probability, sizeof (floating));\n",
        "        bpf_floating_to_u32s (&probability, sizeof (floating), (__u64 *) decimal, sizeof (decimal));\n",
        "        accumulator += decimal[1];\n",
        "        bpf_debug (\"HERE-probability %llu.%llu\\n\", decimal[0], decimal[1]);\n",
        "        if (pick < accumulator) {\n",
        "            bpf_debug (\"Chosen %llu\\n\", accumulator);\n",
        "            chosen_id = i;\n",
        "            set_floating (flow_info->exp3_last_probability, probability);\n",
        "            break;\n",
        "        }\n",
        "    }\n",
        "    flow_info->exp3_last_number_actions = nbr_valid_paths;\n",
        "    return chosen_id;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    },
    {
      "capabilities": [
        {
          "capability": "read_sys_info",
          "read_sys_info": [
            {
              "Project": "bcc",
              "FunctionName": "bpf_get_prandom_u32",
              "Return Type": "u32",
              "Description": "u32 bpf_get_prandom_u32 Returns a pseudo-random u32. Example in situ: \"https://github.com/iovisor/bcc/search?q=bpf_get_prandom_u32+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=bpf_get_prandom_u32+path%3Atools&type=Code search /tools ",
              "Return": "Returns a pseudo-random u32",
              "Input Prameters": [],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            }
          ]
        },
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 172,
      "endLine": 303,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/tpc-ebpf/original_source/ebpf_exp3_lowest_completion.h",
      "funcName": "exp3_next_path",
      "developer_inline_comments": [
        {
          "start_line": 174,
          "end_line": 193,
          "text": "\tdef distr(weights, gamma=0.0):\t\ttheSum = float(sum(weights))\t\treturn tuple((1.0 - gamma) * (w / theSum) + (gamma / len(weights)) for w in weights)\tdef exp3(numActions, reward, gamma):\t\tweights = [1.0] * numActions\t\tt = 0\t\twhile True:\t\t\tprobabilityDistribution = distr(weights, gamma)\t\t\tchoice = draw(probabilityDistribution)\t\t\ttheReward = reward(choice, t)\t\t\testimatedReward = theReward / probabilityDistribution[choice]\t\t\tweights[choice] *= math.exp(estimatedReward * gamma / numActions) # important that we use estimated reward here!\t\t\tyield choice, theReward, estimatedReward, weights\t\t\tt = t + 1\t"
        },
        {
          "start_line": 208,
          "end_line": 208,
          "text": "bpf_debug(\"Cannot find the destination entry => Cannot find another SRH\\n\");"
        },
        {
          "start_line": 212,
          "end_line": 212,
          "text": " Compute the sum of weights"
        },
        {
          "start_line": 218,
          "end_line": 218,
          "text": " Compiler cannot unroll otherwise"
        },
        {
          "start_line": 221,
          "end_line": 221,
          "text": " Wrong SRH ID -> might be inconsistent state, so skip"
        },
        {
          "start_line": 222,
          "end_line": 222,
          "text": " Not a valid SRH for the destination"
        },
        {
          "start_line": 223,
          "end_line": 223,
          "text": " Same SRH"
        },
        {
          "start_line": 224,
          "end_line": 224,
          "text": " 1"
        },
        {
          "start_line": 225,
          "end_line": 225,
          "text": "bpf_debug(\"Cannot find the SRH entry indexed at %d at a dest entry\\n\", i);"
        },
        {
          "start_line": 229,
          "end_line": 229,
          "text": " 1"
        },
        {
          "start_line": 230,
          "end_line": 230,
          "text": "bpf_debug(\"SRH entry indexed at %d by the dest entry is invalid\\n\", i);"
        },
        {
          "start_line": 231,
          "end_line": 231,
          "text": " Not a valid SRH for the destination"
        },
        {
          "start_line": 236,
          "end_line": 236,
          "text": "bpf_debug(\"HERE %llu %u\\n\", operands[1].mantissa, operands[1].exponent);  TODO Remove"
        },
        {
          "start_line": 237,
          "end_line": 237,
          "text": " TODO Remove"
        },
        {
          "start_line": 238,
          "end_line": 238,
          "text": " TODO Remove"
        },
        {
          "start_line": 243,
          "end_line": 243,
          "text": " Compute the probabilities"
        },
        {
          "start_line": 257,
          "end_line": 257,
          "text": " No problem if FLOAT_MULT < UIN32T_MAX"
        },
        {
          "start_line": 262,
          "end_line": 262,
          "text": " Compiler cannot unroll otherwise"
        },
        {
          "start_line": 265,
          "end_line": 265,
          "text": " Wrong SRH ID -> might be inconsistent state, so skip"
        },
        {
          "start_line": 266,
          "end_line": 266,
          "text": " Not a valid SRH for the destination"
        },
        {
          "start_line": 267,
          "end_line": 267,
          "text": " Same SRH"
        },
        {
          "start_line": 268,
          "end_line": 268,
          "text": " 2"
        },
        {
          "start_line": 269,
          "end_line": 269,
          "text": "bpf_debug(\"Cannot find the SRH entry indexed at %d at a dest entry\\n\", i);"
        },
        {
          "start_line": 273,
          "end_line": 273,
          "text": " 2"
        },
        {
          "start_line": 274,
          "end_line": 274,
          "text": " Not a valid SRH for the destination"
        },
        {
          "start_line": 277,
          "end_line": 277,
          "text": " prob[i] = (1.0 - gamma) * (w[i] / theSum) + (gamma / len(weights))"
        },
        {
          "start_line": 278,
          "end_line": 278,
          "text": "set_floating(operands[0], one_minus_gamma);"
        },
        {
          "start_line": 279,
          "end_line": 279,
          "text": "exp3_weight_get(dst_infos, yyy, operands[1]);"
        },
        {
          "start_line": 280,
          "end_line": 280,
          "text": "bpf_floating_multiply(operands, sizeof(floating) * 2, &weight_times_gama, sizeof(floating));"
        },
        {
          "start_line": 286,
          "end_line": 286,
          "text": "set_floating(operands[0], term1);"
        },
        {
          "start_line": 287,
          "end_line": 287,
          "text": "set_floating(operands[1], term2);"
        },
        {
          "start_line": 288,
          "end_line": 288,
          "text": "bpf_floating_add(operands, sizeof(floating) * 2, &probability, sizeof(floating));"
        },
        {
          "start_line": 291,
          "end_line": 291,
          "text": " No need to take the integer part since these are numbers in [0, 1["
        },
        {
          "start_line": 292,
          "end_line": 292,
          "text": " TODO Remove"
        },
        {
          "start_line": 294,
          "end_line": 294,
          "text": " We found the chosen one"
        }
      ],
      "updateMaps": [],
      "readMaps": [
        " dt_map"
      ],
      "input": [
        "struct bpf_elf_map *dt_map",
        " struct flow_infos *flow_info",
        " __u32 *dst_addr"
      ],
      "output": "static__u32",
      "helper": [
        "bpf_get_prandom_u32",
        "bpf_map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "kprobe",
        "sk_reuseport",
        "sched_cls",
        "sk_skb",
        "sched_act",
        "tracepoint",
        "socket_filter",
        "xdp",
        "cgroup_sock_addr",
        "flow_dissector",
        "raw_tracepoint_writable",
        "perf_event",
        "sock_ops",
        "cgroup_skb",
        "lwt_seg6local",
        "sk_msg",
        "cgroup_sock",
        "lwt_in",
        "raw_tracepoint",
        "lwt_out",
        "lwt_xmit"
      ],
      "source": [
        "static __u32 exp3_next_path (struct bpf_elf_map *dt_map, struct flow_infos *flow_info, __u32 *dst_addr)\n",
        "{\n",
        "    floating operands [2];\n",
        "    floating gamma;\n",
        "    GAMMA (gamma);\n",
        "    __u32 decimal [2];\n",
        "    decimal[0] = 0;\n",
        "    decimal[1] = 0;\n",
        "    __u32 chosen_id = 0, current_delay = 0;\n",
        "    struct srh_record_t *srh_record = NULL;\n",
        "    struct dst_infos *dst_infos = NULL;\n",
        "    dst_infos = (void *) bpf_map_lookup_elem (dt_map, dst_addr);\n",
        "    if (!dst_infos) {\n",
        "        return chosen_id;\n",
        "    }\n",
        "    floating sum;\n",
        "    bpf_to_floating (0, 0, 1, &sum, sizeof (floating));\n",
        "    __u32 nbr_valid_paths = 0;\n",
        "\n",
        "#pragma clang loop unroll(full)\n",
        "    for (__u32 i = 0; i <= MAX_SRH_BY_DEST - 1; i++) {\n",
        "        int xxx = i;\n",
        "        srh_record = &dst_infos->srhs[i];\n",
        "        if (!srh_record || !srh_record->srh.type) {\n",
        "            continue;\n",
        "        }\n",
        "        if (!srh_record->is_valid) {\n",
        "            continue;\n",
        "        }\n",
        "        set_floating (operands[0], sum);\n",
        "        exp3_weight_get (dst_infos, xxx, operands[1]);\n",
        "        bpf_floating_to_u32s (&operands[1], sizeof (floating), (__u64 *) decimal, sizeof (decimal));\n",
        "        bpf_debug (\"HERE-2 %llu.%llu\\n\", decimal[0], decimal[1]);\n",
        "        bpf_floating_add (operands, sizeof (floating) * 2, &sum, sizeof (floating));\n",
        "        nbr_valid_paths += 1;\n",
        "    }\n",
        "    floating probability;\n",
        "    floating one_minus_gamma;\n",
        "    ONE_MINUS_GAMMA (one_minus_gamma);\n",
        "    floating weight_times_gama;\n",
        "    floating term1;\n",
        "    floating valid_paths;\n",
        "    bpf_to_floating (nbr_valid_paths, 0, 1, &valid_paths, sizeof (floating));\n",
        "    floating term2;\n",
        "    set_floating (operands[0], gamma);\n",
        "    set_floating (operands[1], valid_paths);\n",
        "    bpf_floating_divide (operands, sizeof (floating) * 2, &term2, sizeof (floating));\n",
        "    __u64 pick = ((__u64) bpf_get_prandom_u32 ()) % FLOAT_MULT;\n",
        "    __u64 accumulator = 0;\n",
        "\n",
        "#pragma clang loop unroll(full)\n",
        "    for (__u32 i = 0; i <= MAX_SRH_BY_DEST - 1; i++) {\n",
        "        int yyy = i;\n",
        "        srh_record = &dst_infos->srhs[i];\n",
        "        if (!srh_record || !srh_record->srh.type) {\n",
        "            continue;\n",
        "        }\n",
        "        if (!srh_record->is_valid) {\n",
        "            continue;\n",
        "        }\n",
        "        exp3_weight_get (dst_infos, yyy, operands[0]);\n",
        "        set_floating (operands[1], sum);\n",
        "        bpf_floating_divide (operands, sizeof (floating) * 2, &probability, sizeof (floating));\n",
        "        bpf_floating_to_u32s (&probability, sizeof (floating), (__u64 *) decimal, sizeof (decimal));\n",
        "        accumulator += decimal[1];\n",
        "        bpf_debug (\"HERE-probability %llu.%llu\\n\", decimal[0], decimal[1]);\n",
        "        if (pick < accumulator) {\n",
        "            chosen_id = i;\n",
        "            set_floating (flow_info->exp3_last_probability, probability);\n",
        "            break;\n",
        "        }\n",
        "    }\n",
        "    flow_info->exp3_last_number_actions = nbr_valid_paths;\n",
        "    return chosen_id;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "floating_test_to_floating": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 10,
      "endLine": 63,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/tpc-ebpf/original_source/floating_point_test.h",
      "funcName": "floating_test_to_floating",
      "developer_inline_comments": [
        {
          "start_line": 8,
          "end_line": 8,
          "text": " Tests "
        },
        {
          "start_line": 13,
          "end_line": 13,
          "text": "to_floating(0, 1, 1, &float_1);"
        },
        {
          "start_line": 14,
          "end_line": 14,
          "text": "bpf_printk(\"[conv] 0.1 == mantisse %llu - exponent %d\\n\", float_1.mantissa, float_1.exponent - BIAS);  0x%llx outside eBPF"
        },
        {
          "start_line": 15,
          "end_line": 15,
          "text": "floating_to_u32s(float_1, &integer_1, &decimal_1);"
        },
        {
          "start_line": 16,
          "end_line": 16,
          "text": "bpf_printk(\"[conv] 0.1 == %u.0*%u\\n\", integer_1, decimal_1);"
        },
        {
          "start_line": 18,
          "end_line": 18,
          "text": " 0x%llx outside eBPF"
        },
        {
          "start_line": 23,
          "end_line": 23,
          "text": "to_floating(5, 0, 1, &float_5);"
        },
        {
          "start_line": 24,
          "end_line": 24,
          "text": "bpf_printk(\"[conv] 5 == mantisse %llu - exponent %d\\n\", float_5.mantissa, float_5.exponent - BIAS);"
        },
        {
          "start_line": 25,
          "end_line": 25,
          "text": "floating_to_u32s(float_5, &integer_5, &decimal_5);"
        },
        {
          "start_line": 26,
          "end_line": 26,
          "text": "bpf_printk(\"[conv] 5 == %u.0*%u\\n\", integer_5, decimal_5);"
        },
        {
          "start_line": 32,
          "end_line": 62,
          "text": "floating float_05;    bpf_to_floating(0, 5, 1, &float_05, sizeof(floating));\tbpf_printk(\"[conv-kern] 0.5 == mantisse %llu - exponent %d\\n\", float_05.mantissa, float_05.exponent - BIAS);\t__u32 integer_05 = 0;\t__u32 decimal_05 = 0;\tfloating_to_u32s(float_05, &integer_05, &decimal_05);\tbpf_printk(\"[conv] 0.5 == %u.0*%u\\n\", integer_05, decimal_05);\tfloating float_55;    bpf_to_floating(5, 5, 1, &float_55, sizeof(floating));\tbpf_printk(\"[conv-kern] 5.5 == mantisse %llu - exponent %d\\n\", float_55.mantissa, float_55.exponent - BIAS);\t__u32 integer_55 = 0;\t__u32 decimal_55 = 0;\tfloating_to_u32s(float_55, &integer_55, &decimal_55);\tbpf_printk(\"[conv] 5.5 == %u.0*%u\\n\", integer_55, decimal_55);\tfloating float_005;    bpf_to_floating(0, 5, 2, &float_005, sizeof(floating));\tbpf_printk(\"[conv-kern] 0.05 == mantisse %llu - exponent %d\\n\", float_005.mantissa, float_005.exponent - BIAS);\t__u32 integer_005 = 0;\t__u32 decimal_005 = 0;\tfloating_to_u32s(float_005, &integer_005, &decimal_005);\tbpf_printk(\"[conv] 0.05 == %u.0*%u\\n\", integer_005, decimal_005);\tfloating float_10;    bpf_to_floating(10, 0, 1, &float_10, sizeof(floating));\tbpf_printk(\"[conv-kern] 10.0 == mantisse %llu - exponent %d\\n\", float_10.mantissa, float_10.exponent - BIAS);\t__u32 integer_10 = 0;\t__u32 decimal_10 = 0;\tfloating_to_u32s(float_10, &integer_10, &decimal_10);\tbpf_printk(\"[conv] 10.0 == %u.0*%u\\n\", integer_10, decimal_10);"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "NA"
      ],
      "output": "staticvoid",
      "helper": [],
      "compatibleHookpoints": [
        "kprobe",
        "sk_reuseport",
        "sched_cls",
        "sk_skb",
        "sched_act",
        "cgroup_sysctl",
        "socket_filter",
        "tracepoint",
        "xdp",
        "cgroup_sock_addr",
        "flow_dissector",
        "raw_tracepoint_writable",
        "perf_event",
        "sock_ops",
        "cgroup_skb",
        "lwt_seg6local",
        "cgroup_device",
        "sk_msg",
        "cgroup_sock",
        "lwt_in",
        "raw_tracepoint",
        "lwt_out",
        "lwt_xmit"
      ],
      "source": [
        "static void floating_test_to_floating ()\n",
        "{\n",
        "    floating float_1;\n",
        "    __u32 number [2] = {0, 0};\n",
        "    bpf_to_floating (0, 1, 1, &float_1, sizeof (floating));\n",
        "    bpf_printk (\"[conv-kern] 0.1 == mantisse %llu - exponent %d\\n\", float_1.mantissa, float_1.exponent - BIAS);\n",
        "    bpf_floating_to_u32s (&float_1, sizeof (floating), (__u64 *) number, sizeof (number));\n",
        "    bpf_printk (\"[conv-kern] 0.1 == %u.0*%u\\n\", number[0], number[1]);\n",
        "    floating float_5;\n",
        "    bpf_to_floating (5, 0, 1, &float_5, sizeof (floating));\n",
        "    bpf_printk (\"[conv-kern] 5 == mantisse %llu - exponent %d\\n\", float_5.mantissa, float_5.exponent - BIAS);\n",
        "    bpf_floating_to_u32s (&float_5, sizeof (floating), (__u64 *) number, sizeof (number));\n",
        "    bpf_printk (\"[conv-kern] 5 == %u.0*%u\\n\", number[0], number[1]);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "floating_test_add": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 65,
      "endLine": 93,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/tpc-ebpf/original_source/floating_point_test.h",
      "funcName": "floating_test_add",
      "developer_inline_comments": [
        {
          "start_line": 71,
          "end_line": 71,
          "text": "bpf_printk(\"[add] 5 == mantisse 0x%llx - exponent %d\\n\", float_5.mantissa, float_5.exponent - BIAS);"
        },
        {
          "start_line": 75,
          "end_line": 75,
          "text": "bpf_printk(\"[add] 0.5 == mantisse 0x%llx - exponent %d\\n\", float_05.mantissa, float_05.exponent - BIAS);"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "NA"
      ],
      "output": "staticvoid",
      "helper": [],
      "compatibleHookpoints": [
        "kprobe",
        "sk_reuseport",
        "sched_cls",
        "sk_skb",
        "sched_act",
        "cgroup_sysctl",
        "socket_filter",
        "tracepoint",
        "xdp",
        "cgroup_sock_addr",
        "flow_dissector",
        "raw_tracepoint_writable",
        "perf_event",
        "sock_ops",
        "cgroup_skb",
        "lwt_seg6local",
        "cgroup_device",
        "sk_msg",
        "cgroup_sock",
        "lwt_in",
        "raw_tracepoint",
        "lwt_out",
        "lwt_xmit"
      ],
      "source": [
        "static void floating_test_add ()\n",
        "{\n",
        "    __u32 add_dec [2] = {0, 0};\n",
        "    floating terms [2];\n",
        "    floating float_5;\n",
        "    bpf_to_floating (5, 0, 1, &float_5, sizeof (floating));\n",
        "    floating float_05;\n",
        "    bpf_to_floating (0, 5, 1, &float_05, sizeof (floating));\n",
        "    floating add;\n",
        "    terms[0].mantissa = float_5.mantissa;\n",
        "    terms[0].exponent = float_5.exponent;\n",
        "    terms[1].mantissa = float_05.mantissa;\n",
        "    terms[1].exponent = float_05.exponent;\n",
        "    bpf_floating_add (terms, sizeof (floating) * 2, &add, sizeof (floating));\n",
        "    bpf_floating_to_u32s (&add, sizeof (floating), (__u64 *) add_dec, sizeof (add_dec));\n",
        "    bpf_printk (\"[add] 5 + 0.5 == 5.5 == %u.%u\\n\", add_dec[0], add_dec[1]);\n",
        "    terms[1].mantissa = float_5.mantissa;\n",
        "    terms[1].exponent = float_5.exponent;\n",
        "    terms[0].mantissa = float_05.mantissa;\n",
        "    terms[0].exponent = float_05.exponent;\n",
        "    bpf_floating_add (terms, sizeof (floating) * 2, &add, sizeof (floating));\n",
        "    bpf_floating_to_u32s (&add, sizeof (floating), (__u64 *) add_dec, sizeof (add_dec));\n",
        "    bpf_printk (\"[add] 0.5 + 5 == 5.5 == %u.%u\\n\", add_dec[0], add_dec[1]);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "floating_test_multiply": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 95,
      "endLine": 115,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/tpc-ebpf/original_source/floating_point_test.h",
      "funcName": "floating_test_multiply",
      "developer_inline_comments": [
        {
          "start_line": 101,
          "end_line": 101,
          "text": "bpf_printk(\"[mult] 5 == mantisse 0x%llx - exponent %d\\n\", float_5.mantissa, float_5.exponent - BIAS);"
        },
        {
          "start_line": 105,
          "end_line": 105,
          "text": "bpf_printk(\"[mult] 0.5 == mantisse 0x%llx - exponent %d\\n\", float_05.mantissa, float_05.exponent - BIAS);"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "NA"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "kprobe",
        "sk_reuseport",
        "sched_cls",
        "sk_skb",
        "sched_act",
        "cgroup_sysctl",
        "socket_filter",
        "tracepoint",
        "xdp",
        "cgroup_sock_addr",
        "flow_dissector",
        "raw_tracepoint_writable",
        "perf_event",
        "sock_ops",
        "cgroup_skb",
        "lwt_seg6local",
        "cgroup_device",
        "sk_msg",
        "cgroup_sock",
        "lwt_in",
        "raw_tracepoint",
        "lwt_out",
        "lwt_xmit"
      ],
      "source": [
        "static __always_inline void floating_test_multiply ()\n",
        "{\n",
        "    __u32 mult_dec [2] = {0, 0};\n",
        "    floating factors [2];\n",
        "    floating float_5;\n",
        "    bpf_to_floating (5, 0, 1, &float_5, sizeof (floating));\n",
        "    floating float_05;\n",
        "    bpf_to_floating (0, 5, 1, &float_05, sizeof (floating));\n",
        "    floating mult;\n",
        "    factors[0].mantissa = float_5.mantissa;\n",
        "    factors[0].exponent = float_5.exponent;\n",
        "    factors[1].mantissa = float_05.mantissa;\n",
        "    factors[1].exponent = float_05.exponent;\n",
        "    bpf_floating_multiply (factors, sizeof (floating) * 2, &mult, sizeof (floating));\n",
        "    bpf_floating_to_u32s (&mult, sizeof (floating), (__u64 *) mult_dec, sizeof (mult_dec));\n",
        "    bpf_printk (\"[mult] 5 * 0.5 == 2.5 == %u.%u\\n\", mult_dec[0], mult_dec[1]);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "floating_test_divide": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 117,
      "endLine": 144,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/tpc-ebpf/original_source/floating_point_test.h",
      "funcName": "floating_test_divide",
      "developer_inline_comments": [
        {
          "start_line": 122,
          "end_line": 122,
          "text": "bpf_printk(\"[div] 5 == mantisse 0x%llx - exponent %d\\n\", float_5.mantissa, float_5.exponent - BIAS);"
        },
        {
          "start_line": 126,
          "end_line": 126,
          "text": "bpf_printk(\"[div] 0.5 == mantisse 0x%llx - exponent %d\\n\", float_05.mantissa, float_05.exponent - BIAS);"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "NA"
      ],
      "output": "staticvoid",
      "helper": [],
      "compatibleHookpoints": [
        "kprobe",
        "sk_reuseport",
        "sched_cls",
        "sk_skb",
        "sched_act",
        "cgroup_sysctl",
        "socket_filter",
        "tracepoint",
        "xdp",
        "cgroup_sock_addr",
        "flow_dissector",
        "raw_tracepoint_writable",
        "perf_event",
        "sock_ops",
        "cgroup_skb",
        "lwt_seg6local",
        "cgroup_device",
        "sk_msg",
        "cgroup_sock",
        "lwt_in",
        "raw_tracepoint",
        "lwt_out",
        "lwt_xmit"
      ],
      "source": [
        "static void floating_test_divide ()\n",
        "{\n",
        "    __u32 div_dec [2] = {0, 0};\n",
        "    floating operands [2];\n",
        "    floating float_5;\n",
        "    bpf_to_floating (5, 0, 1, &float_5, sizeof (floating));\n",
        "    floating float_05;\n",
        "    bpf_to_floating (0, 5, 1, &float_05, sizeof (floating));\n",
        "    floating div;\n",
        "    operands[0].mantissa = float_5.mantissa;\n",
        "    operands[0].exponent = float_5.exponent;\n",
        "    operands[1].mantissa = float_05.mantissa;\n",
        "    operands[1].exponent = float_05.exponent;\n",
        "    bpf_floating_divide (operands, sizeof (floating) * 2, &div, sizeof (floating));\n",
        "    bpf_floating_to_u32s (&div, sizeof (floating), (__u64 *) div_dec, sizeof (div_dec));\n",
        "    bpf_printk (\"[div] 0.5 / 5 == 0.1 == %u.%u\\n\", div_dec[0], div_dec[1]);\n",
        "    operands[1].mantissa = float_5.mantissa;\n",
        "    operands[1].exponent = float_5.exponent;\n",
        "    operands[0].mantissa = float_05.mantissa;\n",
        "    operands[0].exponent = float_05.exponent;\n",
        "    bpf_floating_divide (operands, sizeof (floating) * 2, &div, sizeof (floating));\n",
        "    bpf_floating_to_u32s (&div, sizeof (floating), (__u64 *) div_dec, sizeof (div_dec));\n",
        "    bpf_printk (\"[div] 5 / 0.5 == 10 == %u.%u\\n\", div_dec[0], div_dec[1]);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "floating_test_exp": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 146,
      "endLine": 165,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/tpc-ebpf/original_source/floating_point_test.h",
      "funcName": "floating_test_exp",
      "developer_inline_comments": [
        {
          "start_line": 152,
          "end_line": 152,
          "text": "bpf_printk(\"[exp] 5 == mantisse 0x%llx - exponent %d\\n\", float_5.mantissa, float_5.exponent - BIAS);"
        },
        {
          "start_line": 156,
          "end_line": 156,
          "text": "bpf_printk(\"[exp] 0.5 == mantisse 0x%llx - exponent %d\\n\", float_05.mantissa, float_05.exponent - BIAS);"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "NA"
      ],
      "output": "staticvoid",
      "helper": [],
      "compatibleHookpoints": [
        "kprobe",
        "sk_reuseport",
        "sched_cls",
        "sk_skb",
        "sched_act",
        "cgroup_sysctl",
        "socket_filter",
        "tracepoint",
        "xdp",
        "cgroup_sock_addr",
        "flow_dissector",
        "raw_tracepoint_writable",
        "perf_event",
        "sock_ops",
        "cgroup_skb",
        "lwt_seg6local",
        "cgroup_device",
        "sk_msg",
        "cgroup_sock",
        "lwt_in",
        "raw_tracepoint",
        "lwt_out",
        "lwt_xmit"
      ],
      "source": [
        "static void floating_test_exp ()\n",
        "{\n",
        "    __u32 exp_dec [2] = {0, 0};\n",
        "    floating result;\n",
        "    floating float_5;\n",
        "    bpf_to_floating (5, 0, 1, &float_5, sizeof (floating));\n",
        "    floating float_05;\n",
        "    bpf_to_floating (0, 5, 1, &float_05, sizeof (floating));\n",
        "    bpf_floating_e_power_a (&float_5, sizeof (floating), &result, sizeof (floating));\n",
        "    bpf_floating_to_u32s (&result, sizeof (floating), (__u64 *) exp_dec, sizeof (exp_dec));\n",
        "    bpf_printk (\"[exp] e^5 == 148.413159102 == %u.%u\\n\", exp_dec[0], exp_dec[1]);\n",
        "    bpf_floating_e_power_a (&float_05, sizeof (floating), &result, sizeof (floating));\n",
        "    bpf_floating_to_u32s (&result, sizeof (floating), (__u64 *) exp_dec, sizeof (exp_dec));\n",
        "    bpf_printk (\"[exp] e^0.5 == 1.648721270 == %u.%u\\n\", exp_dec[0], exp_dec[1]);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "floating_test_all": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 167,
      "endLine": 180,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/tpc-ebpf/original_source/floating_point_test.h",
      "funcName": "floating_test_all",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "NA"
      ],
      "output": "staticint",
      "helper": [],
      "compatibleHookpoints": [
        "kprobe",
        "sk_reuseport",
        "sched_cls",
        "sk_skb",
        "sched_act",
        "cgroup_sysctl",
        "socket_filter",
        "tracepoint",
        "xdp",
        "cgroup_sock_addr",
        "flow_dissector",
        "raw_tracepoint_writable",
        "perf_event",
        "sock_ops",
        "cgroup_skb",
        "lwt_seg6local",
        "cgroup_device",
        "sk_msg",
        "cgroup_sock",
        "lwt_in",
        "raw_tracepoint",
        "lwt_out",
        "lwt_xmit"
      ],
      "source": [
        "static int floating_test_all ()\n",
        "{\n",
        "    bpf_printk (\"[main] Before to floating\\n\");\n",
        "    floating_test_to_floating ();\n",
        "    bpf_printk (\"[main] Before divide\\n\");\n",
        "    floating_test_divide ();\n",
        "    bpf_printk (\"[main] Before multiply\\n\");\n",
        "    floating_test_multiply ();\n",
        "    bpf_printk (\"[main] Before add\\n\");\n",
        "    floating_test_add ();\n",
        "    bpf_printk (\"[main] Before exp\\n\");\n",
        "    floating_test_exp ();\n",
        "    bpf_printk (\"[main] All tests performed\\n\");\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "floating_test_divide",
        "floating_test_to_floating",
        "floating_test_exp",
        "floating_test_add",
        "floating_test_multiply"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ],
  "get_flow_id_from_sock": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 132,
      "endLine": 145,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/tpc-ebpf/original_source/utils.h",
      "funcName": "get_flow_id_from_sock",
      "developer_inline_comments": [
        {
          "start_line": 8,
          "end_line": 8,
          "text": " Defining constant values "
        },
        {
          "start_line": 10,
          "end_line": 10,
          "text": " TCP protocol in HDR "
        },
        {
          "start_line": 11,
          "end_line": 11,
          "text": " IPv6 HDR "
        },
        {
          "start_line": 12,
          "end_line": 12,
          "text": " IPv6 Sockopt "
        },
        {
          "start_line": 13,
          "end_line": 13,
          "text": " Socket Sockopt "
        },
        {
          "start_line": 14,
          "end_line": 14,
          "text": " TCP Sockopt "
        },
        {
          "start_line": 15,
          "end_line": 15,
          "text": " Max pacing rate for setsockopt "
        },
        {
          "start_line": 16,
          "end_line": 16,
          "text": " SRv6 Option for sockopt "
        },
        {
          "start_line": 17,
          "end_line": 17,
          "text": " Ethernet hdr length "
        },
        {
          "start_line": 18,
          "end_line": 18,
          "text": " Limit/Retrieve MSS "
        },
        {
          "start_line": 19,
          "end_line": 19,
          "text": " Change congestion control "
        },
        {
          "start_line": 20,
          "end_line": 20,
          "text": " Notify TCP that kernel changed "
        },
        {
          "start_line": 21,
          "end_line": 21,
          "text": " Trigger the save of the SRH "
        },
        {
          "start_line": 22,
          "end_line": 22,
          "text": " Routing header. "
        },
        {
          "start_line": 23,
          "end_line": 23,
          "text": " Hop limit "
        },
        {
          "start_line": 24,
          "end_line": 24,
          "text": " ICMPv6 Time Exceeded "
        },
        {
          "start_line": 25,
          "end_line": 25,
          "text": " #define DEBUG \t\t\t1"
        },
        {
          "start_line": 32,
          "end_line": 32,
          "text": " one expert telling 100% on a single path + one expert changing randomly + one random expert + one expert always stable"
        },
        {
          "start_line": 34,
          "end_line": 34,
          "text": " Multiply by two the waiting time whenever a path change is made"
        },
        {
          "start_line": 36,
          "end_line": 36,
          "text": " Stats"
        },
        {
          "start_line": 37,
          "end_line": 37,
          "text": " TODO Fix - The max number fo snapshot to keep"
        },
        {
          "start_line": 39,
          "end_line": 39,
          "text": " eBPF definitions "
        },
        {
          "start_line": 48,
          "end_line": 50,
          "text": " Only use this for debug output. Notice output from bpf_trace_printk() *  * end-up in /sys/kernel/debug/tracing/trace_pipe *   "
        },
        {
          "start_line": 66,
          "end_line": 66,
          "text": " IPv6 address "
        },
        {
          "start_line": 72,
          "end_line": 72,
          "text": " SRH definition "
        },
        {
          "start_line": 88,
          "end_line": 88,
          "text": " Mbps"
        },
        {
          "start_line": 89,
          "end_line": 89,
          "text": " ms"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct flow_tuple *flow_id",
        " struct bpf_sock_ops *skops"
      ],
      "output": "staticvoid",
      "helper": [],
      "compatibleHookpoints": [
        "kprobe",
        "sk_reuseport",
        "sched_cls",
        "sk_skb",
        "sched_act",
        "cgroup_sysctl",
        "socket_filter",
        "tracepoint",
        "xdp",
        "cgroup_sock_addr",
        "flow_dissector",
        "raw_tracepoint_writable",
        "perf_event",
        "sock_ops",
        "cgroup_skb",
        "lwt_seg6local",
        "cgroup_device",
        "sk_msg",
        "cgroup_sock",
        "lwt_in",
        "raw_tracepoint",
        "lwt_out",
        "lwt_xmit"
      ],
      "source": [
        "static void get_flow_id_from_sock (struct flow_tuple *flow_id, struct bpf_sock_ops *skops)\n",
        "{\n",
        "    flow_id->family = skops->family;\n",
        "    flow_id->local_addr[0] = skops->local_ip6[0];\n",
        "    flow_id->local_addr[1] = skops->local_ip6[1];\n",
        "    flow_id->local_addr[2] = skops->local_ip6[2];\n",
        "    flow_id->local_addr[3] = skops->local_ip6[3];\n",
        "    flow_id->remote_addr[0] = skops->remote_ip6[0];\n",
        "    flow_id->remote_addr[1] = skops->remote_ip6[1];\n",
        "    flow_id->remote_addr[2] = skops->remote_ip6[2];\n",
        "    flow_id->remote_addr[3] = skops->remote_ip6[3];\n",
        "    flow_id->local_port = skops->local_port;\n",
        "    flow_id->remote_port = bpf_ntohl (skops->remote_port);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ]
}