{
  "swap_src_dst_mac": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 26,
      "endLine": 40,
      "File": "/home/sayandes/ebpf-projects-annotations/examples/hxdp_xdp_progs/xdp_csum_kern.c",
      "funcName": "swap_src_dst_mac",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 6,
          "text": "/* Copyright (c) 2016 PLUMgrid\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of version 2 of the GNU General Public\n * License as published by the Free Software Foundation.\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *data"
      ],
      "output": "staticvoid",
      "helper": [],
      "compatibleHookpoints": [
        "sock_ops",
        "lwt_xmit",
        "raw_tracepoint_writable",
        "socket_filter",
        "sk_reuseport",
        "tracepoint",
        "lwt_seg6local",
        "xdp",
        "cgroup_sock_addr",
        "perf_event",
        "raw_tracepoint",
        "cgroup_sysctl",
        "sk_skb",
        "lwt_in",
        "sk_msg",
        "sched_act",
        "cgroup_device",
        "kprobe",
        "flow_dissector",
        "lwt_out",
        "cgroup_skb",
        "cgroup_sock",
        "sched_cls"
      ],
      "source": [
        "static void swap_src_dst_mac (void *data)\n",
        "{\n",
        "    unsigned short *p = data;\n",
        "    unsigned short dst [3];\n",
        "    dst[0] = p[0];\n",
        "    dst[1] = p[1];\n",
        "    dst[2] = p[2];\n",
        "    p[0] = p[3];\n",
        "    p[1] = p[4];\n",
        "    p[2] = p[5];\n",
        "    p[3] = dst[0];\n",
        "    p[4] = dst[1];\n",
        "    p[5] = dst[2];\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {}
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 24,
      "endLine": 38,
      "File": "/home/sayandes/ebpf-projects-annotations/examples/hxdp_xdp_progs/xdp_map_access_kern.c",
      "funcName": "swap_src_dst_mac",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 6,
          "text": "/* Copyright (c) 2016 PLUMgrid\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of version 2 of the GNU General Public\n * License as published by the Free Software Foundation.\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *data"
      ],
      "output": "staticvoid",
      "helper": [],
      "compatibleHookpoints": [
        "sock_ops",
        "lwt_xmit",
        "raw_tracepoint_writable",
        "socket_filter",
        "sk_reuseport",
        "tracepoint",
        "lwt_seg6local",
        "xdp",
        "cgroup_sock_addr",
        "perf_event",
        "raw_tracepoint",
        "cgroup_sysctl",
        "sk_skb",
        "lwt_in",
        "sk_msg",
        "sched_act",
        "cgroup_device",
        "kprobe",
        "flow_dissector",
        "lwt_out",
        "cgroup_skb",
        "cgroup_sock",
        "sched_cls"
      ],
      "source": [
        "static void swap_src_dst_mac (void *data)\n",
        "{\n",
        "    unsigned short *p = data;\n",
        "    unsigned short dst [3];\n",
        "    dst[0] = p[0];\n",
        "    dst[1] = p[1];\n",
        "    dst[2] = p[2];\n",
        "    p[0] = p[3];\n",
        "    p[1] = p[4];\n",
        "    p[2] = p[5];\n",
        "    p[3] = dst[0];\n",
        "    p[4] = dst[1];\n",
        "    p[5] = dst[2];\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {}
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ],
  "csum_fold_helper": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 42,
      "endLine": 45,
      "File": "/home/sayandes/ebpf-projects-annotations/examples/hxdp_xdp_progs/xdp_csum_kern.c",
      "funcName": "csum_fold_helper",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "__u32 csum"
      ],
      "output": "static__always_inline__u16",
      "helper": [],
      "compatibleHookpoints": [
        "sock_ops",
        "lwt_xmit",
        "raw_tracepoint_writable",
        "socket_filter",
        "sk_reuseport",
        "tracepoint",
        "lwt_seg6local",
        "xdp",
        "cgroup_sock_addr",
        "perf_event",
        "raw_tracepoint",
        "cgroup_sysctl",
        "sk_skb",
        "lwt_in",
        "sk_msg",
        "sched_act",
        "cgroup_device",
        "kprobe",
        "flow_dissector",
        "lwt_out",
        "cgroup_skb",
        "cgroup_sock",
        "sched_cls"
      ],
      "source": [
        "static __always_inline __u16 csum_fold_helper (__u32 csum)\n",
        "{\n",
        "    return ~((csum & 0xffff) + (csum >> 16));\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {}
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "ipv4_csum": [
    {
      "capabilities": [
        {
          "capability": "read_skb",
          "read_skb": [
            {
              "Project": "libbpf",
              "Return Type": "s64",
              "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with bpf_l3_csum_replace() and bpf_l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with bpf_csum_diff(). ",
              "Return": " The checksum result, or a negative error code in case of failure.",
              "Function Name": "bpf_csum_diff",
              "Input Params": [
                "{Type: __be32 ,Var: *from}",
                "{Type:  u32 ,Var: from_size}",
                "{Type:  __be32 ,Var: *to}",
                "{Type:  u32 ,Var: to_size}",
                "{Type:  __wsum ,Var: seed}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "xdp",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "lwt_seg6local"
              ],
              "capabilities": [
                "read_skb"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 47,
      "endLine": 52,
      "File": "/home/sayandes/ebpf-projects-annotations/examples/hxdp_xdp_progs/xdp_csum_kern.c",
      "funcName": "ipv4_csum",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *data_start",
        " int data_size",
        " __u32 *csum"
      ],
      "output": "static__always_inlinevoid",
      "helper": [
        "bpf_csum_diff"
      ],
      "compatibleHookpoints": [
        "lwt_out",
        "lwt_xmit",
        "sched_cls",
        "lwt_seg6local",
        "lwt_in",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline void ipv4_csum (void *data_start, int data_size, __u32 *csum)\n",
        "{\n",
        "    *csum = bpf_csum_diff (0, 0, data_start, data_size, *csum);\n",
        "    *csum = csum_fold_helper (*csum);\n",
        "}\n"
      ],
      "called_function_list": [
        "csum_fold_helper"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {}
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "xdp_prog1": [
    {
      "capabilities": [
        {
          "capability": "pkt_stop_processing_drop_packet",
          "pkt_stop_processing_drop_packet": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "XDP_DROP",
              "Return": 1,
              "Description": "will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general.",
              "compatible_hookpoints": [
                "xdp"
              ],
              "capabilities": [
                "pkt_stop_processing_drop_packet"
              ]
            }
          ]
        },
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 55,
      "endLine": 99,
      "File": "/home/sayandes/ebpf-projects-annotations/examples/hxdp_xdp_progs/xdp_csum_kern.c",
      "funcName": "xdp_prog1",
      "developer_inline_comments": [
        {
          "start_line": 84,
          "end_line": 84,
          "text": "//\tswap_src_dst_mac(data);"
        },
        {
          "start_line": 85,
          "end_line": 85,
          "text": "//\trc = XDP_TX;"
        }
      ],
      "updateMaps": [],
      "readMaps": [
        "  rxcnt"
      ],
      "input": [
        "struct xdp_md *ctx"
      ],
      "output": "int",
      "helper": [
        "XDP_DROP",
        "bpf_map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "xdp"
      ],
      "source": [
        "int xdp_prog1 (struct xdp_md *ctx)\n",
        "{\n",
        "    void *data_end = (void *) (long) ctx->data_end;\n",
        "    void *data = (void *) (long) ctx->data;\n",
        "    struct ethhdr *eth = data;\n",
        "    struct iphdr *iph;\n",
        "    int rc = XDP_DROP;\n",
        "    long *value;\n",
        "    u16 h_proto;\n",
        "    u64 nh_off;\n",
        "    u32 dummy_int = 23;\n",
        "    __u32 csum = 0;\n",
        "    int i = 0;\n",
        "    nh_off = sizeof (*eth);\n",
        "    if (data + nh_off > data_end)\n",
        "        return rc;\n",
        "    h_proto = eth->h_proto;\n",
        "    if (h_proto != htons (ETH_P_IP))\n",
        "        return rc;\n",
        "    iph = data + nh_off;\n",
        "    nh_off += sizeof (*iph);\n",
        "    if (data + nh_off > data_end)\n",
        "        return rc;\n",
        "    for (i = 0; i < LOOP_LEN; i++) {\n",
        "        ipv4_csum (iph, sizeof (struct iphdr), &csum);\n",
        "        iph->check = csum;\n",
        "        value = bpf_map_lookup_elem (& rxcnt, & dummy_int);\n",
        "    }\n",
        "    value = bpf_map_lookup_elem (& rxcnt, & dummy_int);\n",
        "    if (value)\n",
        "        *value += 1;\n",
        "    return rc;\n",
        "}\n"
      ],
      "called_function_list": [
        "ipv4_csum"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        {}
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    },
    {
      "capabilities": [
        {
          "capability": "pkt_stop_processing_drop_packet",
          "pkt_stop_processing_drop_packet": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "XDP_DROP",
              "Return": 1,
              "Description": "will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general.",
              "compatible_hookpoints": [
                "xdp"
              ],
              "capabilities": [
                "pkt_stop_processing_drop_packet"
              ]
            }
          ]
        },
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 41,
      "endLine": 70,
      "File": "/home/sayandes/ebpf-projects-annotations/examples/hxdp_xdp_progs/xdp_map_access_kern.c",
      "funcName": "xdp_prog1",
      "developer_inline_comments": [
        {
          "start_line": 57,
          "end_line": 57,
          "text": "//\tswap_src_dst_mac(data);"
        },
        {
          "start_line": 58,
          "end_line": 58,
          "text": "//\trc = XDP_TX;"
        }
      ],
      "updateMaps": [
        " rxcnt"
      ],
      "readMaps": [
        "  rxcnt"
      ],
      "input": [
        "struct xdp_md *ctx"
      ],
      "output": "int",
      "helper": [
        "XDP_DROP",
        "bpf_map_lookup_elem",
        "bpf_map_update_elem"
      ],
      "compatibleHookpoints": [
        "xdp"
      ],
      "source": [
        "int xdp_prog1 (struct xdp_md *ctx)\n",
        "{\n",
        "    void *data_end = (void *) (long) ctx->data_end;\n",
        "    void *data = (void *) (long) ctx->data;\n",
        "    struct ethhdr *eth = data;\n",
        "    struct dummy_key key = {0}\n",
        "    ;\n",
        "    int rc = XDP_DROP;\n",
        "    long *value;\n",
        "    u16 h_proto;\n",
        "    u64 nh_off;\n",
        "    long dummy_value = 1;\n",
        "    nh_off = sizeof (*eth);\n",
        "    if (data + nh_off > data_end)\n",
        "        return rc;\n",
        "    h_proto = eth->h_proto;\n",
        "    key.key = 23;\n",
        "    value = bpf_map_lookup_elem (& rxcnt, & key);\n",
        "    if (value) {\n",
        "        *value += 1;\n",
        "    }\n",
        "    else {\n",
        "        bpf_map_update_elem (&rxcnt, &key, &dummy_value, BPF_ANY);\n",
        "    }\n",
        "    return rc;\n",
        "}\n"
      ],
      "called_function_list": [
        "ipv4_csum"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        {}
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ],
  "biflow": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 27,
      "endLine": 41,
      "File": "/home/sayandes/ebpf-projects-annotations/examples/hxdp_xdp_progs/xdp_fw_kern.c",
      "funcName": "biflow",
      "developer_inline_comments": [
        {
          "start_line": 14,
          "end_line": 14,
          "text": "//#define DEBUG 1"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct flow_ctx_table_key *flow_key"
      ],
      "output": "staticinlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "sock_ops",
        "lwt_xmit",
        "raw_tracepoint_writable",
        "socket_filter",
        "sk_reuseport",
        "tracepoint",
        "lwt_seg6local",
        "xdp",
        "cgroup_sock_addr",
        "perf_event",
        "raw_tracepoint",
        "cgroup_sysctl",
        "sk_skb",
        "lwt_in",
        "sk_msg",
        "sched_act",
        "cgroup_device",
        "kprobe",
        "flow_dissector",
        "lwt_out",
        "cgroup_skb",
        "cgroup_sock",
        "sched_cls"
      ],
      "source": [
        "static inline void biflow (struct flow_ctx_table_key *flow_key)\n",
        "{\n",
        "    u32 swap;\n",
        "    if (flow_key->ip_src > flow_key->ip_dst) {\n",
        "        swap = flow_key->ip_src;\n",
        "        flow_key->ip_src = flow_key->ip_dst;\n",
        "        flow_key->ip_dst = swap;\n",
        "    }\n",
        "    if (flow_key->l4_src > flow_key->l4_dst) {\n",
        "        swap = flow_key->l4_src;\n",
        "        flow_key->l4_src = flow_key->l4_dst;\n",
        "        flow_key->l4_dst = swap;\n",
        "    }\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {}
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "xdp_fw_prog": [
    {
      "capabilities": [
        {
          "capability": "pkt_stop_processing_drop_packet",
          "pkt_stop_processing_drop_packet": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "XDP_DROP",
              "Return": 1,
              "Description": "will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general.",
              "compatible_hookpoints": [
                "xdp"
              ],
              "capabilities": [
                "pkt_stop_processing_drop_packet"
              ]
            }
          ]
        },
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "XDP_PASS",
              "Return": 2,
              "Description": "The XDP_PASS return code means that the packet is allowed to be passed up to the kernel\u2019s networking stack. Meaning, the current CPU that was processing this packet now allocates a skb, populates it, and passes it onwards into the GRO engine. This would be equivalent to the default packet handling behavior without XDP.",
              "compatible_hookpoints": [
                "xdp"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        },
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 59,
      "endLine": 162,
      "File": "/home/sayandes/ebpf-projects-annotations/examples/hxdp_xdp_progs/xdp_fw_kern.c",
      "funcName": "xdp_fw_prog",
      "developer_inline_comments": [
        {
          "start_line": 79,
          "end_line": 81,
          "text": "/*  remember, to see printk \n\t * sudo cat /sys/kernel/debug/tracing/trace_pipe\n\t */"
        },
        {
          "start_line": 92,
          "end_line": 92,
          "text": "//\tif (!ntohs(ethernet->h_proto))"
        },
        {
          "start_line": 93,
          "end_line": 93,
          "text": "//\t\tgoto EOP;"
        },
        {
          "start_line": 126,
          "end_line": 126,
          "text": "/* flow key */"
        },
        {
          "start_line": 151,
          "end_line": 151,
          "text": "//ctx->ingress_ifindex ;"
        }
      ],
      "updateMaps": [
        " flow_ctx_table"
      ],
      "readMaps": [
        "  flow_ctx_table"
      ],
      "input": [
        "struct xdp_md *ctx"
      ],
      "output": "int",
      "helper": [
        "XDP_DROP",
        "bpf_map_update_elem",
        "bpf_redirect",
        "bpf_redirect_map",
        "XDP_PASS",
        "bpf_map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "xdp"
      ],
      "source": [
        "int xdp_fw_prog (struct xdp_md *ctx)\n",
        "{\n",
        "    void *data_end = (void *) (long) ctx->data_end;\n",
        "    void *data = (void *) (long) ctx->data;\n",
        "    struct flow_ctx_table_leaf new_flow = {0}\n",
        "    ;\n",
        "    struct flow_ctx_table_key flow_key = {0}\n",
        "    ;\n",
        "    struct flow_ctx_table_leaf *flow_leaf;\n",
        "    struct ethhdr *ethernet;\n",
        "    struct iphdr *ip;\n",
        "    struct udphdr *l4;\n",
        "    int ingress_ifindex;\n",
        "    uint64_t nh_off = 0;\n",
        "    u8 port_redirect = 0;\n",
        "    int ret = XDP_PASS;\n",
        "    u8 is_new_flow = 0;\n",
        "    int vport = 0;\n",
        "    bpf_debug (\"I'm in the pipeline\\n\");\n",
        "ethernet :\n",
        "    {\n",
        "        ethernet = data;\n",
        "        nh_off = sizeof (*ethernet);\n",
        "        if (data + nh_off > data_end)\n",
        "            goto EOP;\n",
        "        ingress_ifindex = ctx->ingress_ifindex;\n",
        "        bpf_debug (\"I'm eth\\n\");\n",
        "        switch (ntohs (ethernet->h_proto)) {\n",
        "        case ETH_P_IP :\n",
        "            goto ip;\n",
        "        default :\n",
        "            goto EOP;\n",
        "        }\n",
        "    }\n",
        "ip :\n",
        "    {\n",
        "        bpf_debug (\"I'm ip\\n\");\n",
        "        ip = data + nh_off;\n",
        "        nh_off += sizeof (*ip);\n",
        "        if (data + nh_off > data_end)\n",
        "            goto EOP;\n",
        "        switch (ip->protocol) {\n",
        "        case IPPROTO_TCP :\n",
        "            goto l4;\n",
        "        case IPPROTO_UDP :\n",
        "            goto l4;\n",
        "        default :\n",
        "            goto EOP;\n",
        "        }\n",
        "    }\n",
        "l4 :\n",
        "    {\n",
        "        bpf_debug (\"I'm l4\\n\");\n",
        "        l4 = data + nh_off;\n",
        "        nh_off += sizeof (*l4);\n",
        "        if (data + nh_off > data_end)\n",
        "            goto EOP;\n",
        "    }\n",
        "    bpf_debug (\"extracting flow key ... \\n\");\n",
        "    flow_key.ip_proto = ip->protocol;\n",
        "    flow_key.ip_src = ip->saddr;\n",
        "    flow_key.ip_dst = ip->daddr;\n",
        "    flow_key.l4_src = l4->source;\n",
        "    flow_key.l4_dst = l4->dest;\n",
        "    biflow (&flow_key);\n",
        "    if (ingress_ifindex == B_PORT) {\n",
        "        flow_leaf = bpf_map_lookup_elem (& flow_ctx_table, & flow_key);\n",
        "        if (flow_leaf)\n",
        "            return bpf_redirect_map (&tx_port, flow_leaf->out_port, 0);\n",
        "        else\n",
        "            return XDP_DROP;\n",
        "    }\n",
        "    else {\n",
        "        flow_leaf = bpf_map_lookup_elem (& flow_ctx_table, & flow_key);\n",
        "        if (!flow_leaf) {\n",
        "            new_flow.in_port = B_PORT;\n",
        "            new_flow.out_port = A_PORT;\n",
        "            bpf_map_update_elem (&flow_ctx_table, &flow_key, &new_flow, BPF_ANY);\n",
        "        }\n",
        "        return bpf_redirect_map (&tx_port, B_PORT, 0);\n",
        "    }\n",
        "EOP :\n",
        "    return XDP_DROP;\n",
        "}\n"
      ],
      "called_function_list": [
        "biflow"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {}
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ],
  "int_exit": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 25,
      "endLine": 40,
      "File": "/home/sayandes/ebpf-projects-annotations/examples/hxdp_xdp_progs/xdp_csum_user.c",
      "funcName": "int_exit",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "// SPDX-License-Identifier: GPL-2.0-only"
        },
        {
          "start_line": 2,
          "end_line": 3,
          "text": "/* Copyright (c) 2016 PLUMgrid\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "int sig"
      ],
      "output": "staticvoid",
      "helper": [],
      "compatibleHookpoints": [
        "sock_ops",
        "lwt_xmit",
        "raw_tracepoint_writable",
        "socket_filter",
        "sk_reuseport",
        "tracepoint",
        "lwt_seg6local",
        "xdp",
        "cgroup_sock_addr",
        "perf_event",
        "raw_tracepoint",
        "cgroup_sysctl",
        "sk_skb",
        "lwt_in",
        "sk_msg",
        "sched_act",
        "cgroup_device",
        "kprobe",
        "flow_dissector",
        "lwt_out",
        "cgroup_skb",
        "cgroup_sock",
        "sched_cls"
      ],
      "source": [
        "static void int_exit (int sig)\n",
        "{\n",
        "    __u32 curr_prog_id = 0;\n",
        "    if (bpf_get_link_xdp_id (ifindex, &curr_prog_id, xdp_flags)) {\n",
        "        printf (\"bpf_get_link_xdp_id failed\\n\");\n",
        "        exit (1);\n",
        "    }\n",
        "    if (prog_id == curr_prog_id)\n",
        "        bpf_set_link_xdp_fd (ifindex, -1, xdp_flags);\n",
        "    else if (!curr_prog_id)\n",
        "        printf (\"couldn't find a prog id on a given interface\\n\");\n",
        "    else\n",
        "        printf (\"program on interface changed, not removing\\n\");\n",
        "    exit (0);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {}
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 27,
      "endLine": 42,
      "File": "/home/sayandes/ebpf-projects-annotations/examples/hxdp_xdp_progs/xdp_map_access_user.c",
      "funcName": "int_exit",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "// SPDX-License-Identifier: GPL-2.0-only"
        },
        {
          "start_line": 2,
          "end_line": 3,
          "text": "/* Copyright (c) 2016 PLUMgrid\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "int sig"
      ],
      "output": "staticvoid",
      "helper": [],
      "compatibleHookpoints": [
        "sock_ops",
        "lwt_xmit",
        "raw_tracepoint_writable",
        "socket_filter",
        "sk_reuseport",
        "tracepoint",
        "lwt_seg6local",
        "xdp",
        "cgroup_sock_addr",
        "perf_event",
        "raw_tracepoint",
        "cgroup_sysctl",
        "sk_skb",
        "lwt_in",
        "sk_msg",
        "sched_act",
        "cgroup_device",
        "kprobe",
        "flow_dissector",
        "lwt_out",
        "cgroup_skb",
        "cgroup_sock",
        "sched_cls"
      ],
      "source": [
        "static void int_exit (int sig)\n",
        "{\n",
        "    __u32 curr_prog_id = 0;\n",
        "    if (bpf_get_link_xdp_id (ifindex, &curr_prog_id, xdp_flags)) {\n",
        "        printf (\"bpf_get_link_xdp_id failed\\n\");\n",
        "        exit (1);\n",
        "    }\n",
        "    if (prog_id == curr_prog_id)\n",
        "        bpf_set_link_xdp_fd (ifindex, -1, xdp_flags);\n",
        "    else if (!curr_prog_id)\n",
        "        printf (\"couldn't find a prog id on a given interface\\n\");\n",
        "    else\n",
        "        printf (\"program on interface changed, not removing\\n\");\n",
        "    exit (0);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {}
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 29,
      "endLine": 34,
      "File": "/home/sayandes/ebpf-projects-annotations/examples/hxdp_xdp_progs/xdp_fw_user.c",
      "funcName": "int_exit",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "int sig"
      ],
      "output": "staticvoid",
      "helper": [],
      "compatibleHookpoints": [
        "sock_ops",
        "lwt_xmit",
        "raw_tracepoint_writable",
        "socket_filter",
        "sk_reuseport",
        "tracepoint",
        "lwt_seg6local",
        "xdp",
        "cgroup_sock_addr",
        "perf_event",
        "raw_tracepoint",
        "cgroup_sysctl",
        "sk_skb",
        "lwt_in",
        "sk_msg",
        "sched_act",
        "cgroup_device",
        "kprobe",
        "flow_dissector",
        "lwt_out",
        "cgroup_skb",
        "cgroup_sock",
        "sched_cls"
      ],
      "source": [
        "static void int_exit (int sig)\n",
        "{\n",
        "    bpf_set_link_xdp_fd (ifindex_out, -1, xdp_flags);\n",
        "    bpf_set_link_xdp_fd (ifindex_in, -1, xdp_flags);\n",
        "    exit (0);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {}
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ],
  "poll_stats": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 44,
      "endLine": 67,
      "File": "/home/sayandes/ebpf-projects-annotations/examples/hxdp_xdp_progs/xdp_csum_user.c",
      "funcName": "poll_stats",
      "developer_inline_comments": [
        {
          "start_line": 42,
          "end_line": 43,
          "text": "/* simple per-protocol drop counter\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [
        " map_fd"
      ],
      "input": [
        "int map_fd",
        " int interval"
      ],
      "output": "staticvoid",
      "helper": [],
      "compatibleHookpoints": [
        "sock_ops",
        "lwt_xmit",
        "raw_tracepoint_writable",
        "socket_filter",
        "sk_reuseport",
        "tracepoint",
        "lwt_seg6local",
        "xdp",
        "cgroup_sock_addr",
        "perf_event",
        "raw_tracepoint",
        "cgroup_sysctl",
        "sk_skb",
        "lwt_in",
        "sk_msg",
        "sched_act",
        "cgroup_device",
        "kprobe",
        "flow_dissector",
        "lwt_out",
        "cgroup_skb",
        "cgroup_sock",
        "sched_cls"
      ],
      "source": [
        "static void poll_stats (int map_fd, int interval)\n",
        "{\n",
        "    unsigned int nr_cpus = bpf_num_possible_cpus ();\n",
        "    __u64 values [nr_cpus], prev [UINT8_MAX] = {0};\n",
        "    int i;\n",
        "    while (1) {\n",
        "        __u32 key = UINT32_MAX;\n",
        "        sleep (interval);\n",
        "        while (bpf_map_get_next_key (map_fd, &key, &key) != -1) {\n",
        "            __u64 sum = 0;\n",
        "            assert (bpf_map_lookup_elem (map_fd, &key, values) == 0);\n",
        "            for (i = 0; i < nr_cpus; i++)\n",
        "                sum += values[i];\n",
        "            if (sum > prev[key])\n",
        "                printf (\"key %u: %10llu pkt/s\\n\", key, (sum - prev[key]) / interval);\n",
        "            prev[key] = sum;\n",
        "        }\n",
        "    }\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {}
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 46,
      "endLine": 71,
      "File": "/home/sayandes/ebpf-projects-annotations/examples/hxdp_xdp_progs/xdp_map_access_user.c",
      "funcName": "poll_stats",
      "developer_inline_comments": [
        {
          "start_line": 44,
          "end_line": 45,
          "text": "/* simple per-protocol drop counter\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [
        " map_fd"
      ],
      "input": [
        "int map_fd",
        " int interval"
      ],
      "output": "staticvoid",
      "helper": [],
      "compatibleHookpoints": [
        "sock_ops",
        "lwt_xmit",
        "raw_tracepoint_writable",
        "socket_filter",
        "sk_reuseport",
        "tracepoint",
        "lwt_seg6local",
        "xdp",
        "cgroup_sock_addr",
        "perf_event",
        "raw_tracepoint",
        "cgroup_sysctl",
        "sk_skb",
        "lwt_in",
        "sk_msg",
        "sched_act",
        "cgroup_device",
        "kprobe",
        "flow_dissector",
        "lwt_out",
        "cgroup_skb",
        "cgroup_sock",
        "sched_cls"
      ],
      "source": [
        "static void poll_stats (int map_fd, int interval)\n",
        "{\n",
        "    unsigned int nr_cpus = bpf_num_possible_cpus ();\n",
        "    __u64 values [nr_cpus], prev [UINT8_MAX] = {0};\n",
        "    int i;\n",
        "    while (1) {\n",
        "        struct dummy_key key = {0}\n",
        "        ;\n",
        "        struct dummy_key next_key = {0}\n",
        "        ;\n",
        "        sleep (interval);\n",
        "        while (bpf_map_get_next_key (map_fd, &key, &next_key) != -1) {\n",
        "            __u64 sum = 0;\n",
        "            assert (bpf_map_lookup_elem (map_fd, &next_key, values) == 0);\n",
        "            for (i = 0; i < nr_cpus; i++)\n",
        "                sum += values[i];\n",
        "            if (sum > prev[next_key.key])\n",
        "                printf (\"proto %u: %10llu pkt/s\\n\", next_key.key, (sum - prev[next_key.key]) / interval);\n",
        "            prev[next_key.key] = sum;\n",
        "            key = next_key;\n",
        "        }\n",
        "    }\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {}
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 36,
      "endLine": 54,
      "File": "/home/sayandes/ebpf-projects-annotations/examples/hxdp_xdp_progs/xdp_fw_user.c",
      "funcName": "poll_stats",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [
        " flow_map_fd"
      ],
      "input": [
        "int interval"
      ],
      "output": "staticvoid",
      "helper": [
        "bpf_map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "sock_ops",
        "lwt_xmit",
        "raw_tracepoint_writable",
        "socket_filter",
        "sk_reuseport",
        "tracepoint",
        "lwt_seg6local",
        "xdp",
        "cgroup_sock_addr",
        "perf_event",
        "raw_tracepoint",
        "cgroup_sysctl",
        "sk_skb",
        "lwt_in",
        "sk_msg",
        "sched_act",
        "cgroup_device",
        "kprobe",
        "flow_dissector",
        "lwt_out",
        "cgroup_skb",
        "cgroup_sock",
        "sched_cls"
      ],
      "source": [
        "static void poll_stats (int interval)\n",
        "{\n",
        "    while (1) {\n",
        "        struct flow_ctx_table_key flow_key = {0}\n",
        "        ;\n",
        "        struct flow_ctx_table_key next_flow_key = {0}\n",
        "        ;\n",
        "        struct flow_ctx_table_leaf flow_leaf = {0}\n",
        "        ;\n",
        "        printf (\"\\n\");\n",
        "        while (bpf_map_get_next_key (flow_map_fd, &flow_key, &next_flow_key) == 0) {\n",
        "            bpf_map_lookup_elem (flow_map_fd, &next_flow_key, &flow_leaf);\n",
        "            printf (\"Flow table: [ ip_proto %d | ip s %x  d %x | l4 s %x d %x | in %d out %d]\\n\", next_flow_key.ip_proto, next_flow_key.ip_src, next_flow_key.ip_dst, next_flow_key.l4_src, next_flow_key.l4_dst, flow_leaf.in_port, flow_leaf.out_port);\n",
        "            flow_key = next_flow_key;\n",
        "        }\n",
        "        sleep (interval);\n",
        "    }\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {}
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "usage": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 69,
      "endLine": 78,
      "File": "/home/sayandes/ebpf-projects-annotations/examples/hxdp_xdp_progs/xdp_csum_user.c",
      "funcName": "usage",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const char *prog"
      ],
      "output": "staticvoid",
      "helper": [],
      "compatibleHookpoints": [
        "sock_ops",
        "lwt_xmit",
        "raw_tracepoint_writable",
        "socket_filter",
        "sk_reuseport",
        "tracepoint",
        "lwt_seg6local",
        "xdp",
        "cgroup_sock_addr",
        "perf_event",
        "raw_tracepoint",
        "cgroup_sysctl",
        "sk_skb",
        "lwt_in",
        "sk_msg",
        "sched_act",
        "cgroup_device",
        "kprobe",
        "flow_dissector",
        "lwt_out",
        "cgroup_skb",
        "cgroup_sock",
        "sched_cls"
      ],
      "source": [
        "static void usage (const char *prog)\n",
        "{\n",
        "    fprintf (stderr, \"usage: %s [OPTS] IFACE\\n\\n\" \"OPTS:\\n\" \"    -S    use skb-mode\\n\" \"    -N    enforce native mode\\n\" \"    -F    force loading prog\\n\", prog);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {}
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 73,
      "endLine": 82,
      "File": "/home/sayandes/ebpf-projects-annotations/examples/hxdp_xdp_progs/xdp_map_access_user.c",
      "funcName": "usage",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const char *prog"
      ],
      "output": "staticvoid",
      "helper": [],
      "compatibleHookpoints": [
        "sock_ops",
        "lwt_xmit",
        "raw_tracepoint_writable",
        "socket_filter",
        "sk_reuseport",
        "tracepoint",
        "lwt_seg6local",
        "xdp",
        "cgroup_sock_addr",
        "perf_event",
        "raw_tracepoint",
        "cgroup_sysctl",
        "sk_skb",
        "lwt_in",
        "sk_msg",
        "sched_act",
        "cgroup_device",
        "kprobe",
        "flow_dissector",
        "lwt_out",
        "cgroup_skb",
        "cgroup_sock",
        "sched_cls"
      ],
      "source": [
        "static void usage (const char *prog)\n",
        "{\n",
        "    fprintf (stderr, \"usage: %s [OPTS] IFACE\\n\\n\" \"OPTS:\\n\" \"    -S    use skb-mode\\n\" \"    -N    enforce native mode\\n\" \"    -F    force loading prog\\n\", prog);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {}
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "main": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 80,
      "endLine": 167,
      "File": "/home/sayandes/ebpf-projects-annotations/examples/hxdp_xdp_progs/xdp_csum_user.c",
      "funcName": "main",
      "developer_inline_comments": [
        {
          "start_line": 101,
          "end_line": 101,
          "text": "/* default, set below */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "int argc",
        " char **argv"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "sock_ops",
        "lwt_xmit",
        "raw_tracepoint_writable",
        "socket_filter",
        "sk_reuseport",
        "tracepoint",
        "lwt_seg6local",
        "xdp",
        "cgroup_sock_addr",
        "perf_event",
        "raw_tracepoint",
        "cgroup_sysctl",
        "sk_skb",
        "lwt_in",
        "sk_msg",
        "sched_act",
        "cgroup_device",
        "kprobe",
        "flow_dissector",
        "lwt_out",
        "cgroup_skb",
        "cgroup_sock",
        "sched_cls"
      ],
      "source": [
        "int main (int argc, char **argv)\n",
        "{\n",
        "    struct rlimit r = {RLIM_INFINITY, RLIM_INFINITY}\n",
        "    ;\n",
        "    struct bpf_prog_load_attr prog_load_attr = {\n",
        "        .prog_type = BPF_PROG_TYPE_XDP,}\n",
        "    ;\n",
        "    struct bpf_prog_info info = {}\n",
        "    ;\n",
        "    __u32 info_len = sizeof (info);\n",
        "    const char *optstr = \"FSN\";\n",
        "    int prog_fd, map_fd, opt;\n",
        "    struct bpf_object *obj;\n",
        "    struct bpf_map *map;\n",
        "    char filename [256];\n",
        "    int err;\n",
        "    while ((opt = getopt (argc, argv, optstr)) != -1) {\n",
        "        switch (opt) {\n",
        "        case 'S' :\n",
        "            xdp_flags |= XDP_FLAGS_SKB_MODE;\n",
        "            break;\n",
        "        case 'N' :\n",
        "            break;\n",
        "        case 'F' :\n",
        "            xdp_flags &= ~XDP_FLAGS_UPDATE_IF_NOEXIST;\n",
        "            break;\n",
        "        default :\n",
        "            usage (basename (argv[0]));\n",
        "            return 1;\n",
        "        }\n",
        "    }\n",
        "    if (!(xdp_flags & XDP_FLAGS_SKB_MODE))\n",
        "        xdp_flags |= XDP_FLAGS_DRV_MODE;\n",
        "    if (optind == argc) {\n",
        "        usage (basename (argv[0]));\n",
        "        return 1;\n",
        "    }\n",
        "    if (setrlimit (RLIMIT_MEMLOCK, &r)) {\n",
        "        perror (\"setrlimit(RLIMIT_MEMLOCK)\");\n",
        "        return 1;\n",
        "    }\n",
        "    ifindex = if_nametoindex (argv [optind]);\n",
        "    if (!ifindex) {\n",
        "        perror (\"if_nametoindex\");\n",
        "        return 1;\n",
        "    }\n",
        "    snprintf (filename, sizeof (filename), \"%s_kern.o\", argv[0]);\n",
        "    prog_load_attr.file = filename;\n",
        "    if (bpf_prog_load_xattr (&prog_load_attr, &obj, &prog_fd))\n",
        "        return 1;\n",
        "    map = bpf_map__next (NULL, obj);\n",
        "    if (!map) {\n",
        "        printf (\"finding a map in obj file failed\\n\");\n",
        "        return 1;\n",
        "    }\n",
        "    map_fd = bpf_map__fd (map);\n",
        "    if (!prog_fd) {\n",
        "        printf (\"bpf_prog_load_xattr: %s\\n\", strerror (errno));\n",
        "        return 1;\n",
        "    }\n",
        "    signal (SIGINT, int_exit);\n",
        "    signal (SIGTERM, int_exit);\n",
        "    if (bpf_set_link_xdp_fd (ifindex, prog_fd, xdp_flags) < 0) {\n",
        "        printf (\"link set xdp fd failed\\n\");\n",
        "        return 1;\n",
        "    }\n",
        "    err = bpf_obj_get_info_by_fd (prog_fd, & info, & info_len);\n",
        "    if (err) {\n",
        "        printf (\"can't get prog info - %s\\n\", strerror (errno));\n",
        "        return err;\n",
        "    }\n",
        "    prog_id = info.id;\n",
        "    poll_stats (map_fd, 2);\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "poll_stats",
        "usage"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {}
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 84,
      "endLine": 171,
      "File": "/home/sayandes/ebpf-projects-annotations/examples/hxdp_xdp_progs/xdp_map_access_user.c",
      "funcName": "main",
      "developer_inline_comments": [
        {
          "start_line": 105,
          "end_line": 105,
          "text": "/* default, set below */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "int argc",
        " char **argv"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "sock_ops",
        "lwt_xmit",
        "raw_tracepoint_writable",
        "socket_filter",
        "sk_reuseport",
        "tracepoint",
        "lwt_seg6local",
        "xdp",
        "cgroup_sock_addr",
        "perf_event",
        "raw_tracepoint",
        "cgroup_sysctl",
        "sk_skb",
        "lwt_in",
        "sk_msg",
        "sched_act",
        "cgroup_device",
        "kprobe",
        "flow_dissector",
        "lwt_out",
        "cgroup_skb",
        "cgroup_sock",
        "sched_cls"
      ],
      "source": [
        "int main (int argc, char **argv)\n",
        "{\n",
        "    struct rlimit r = {RLIM_INFINITY, RLIM_INFINITY}\n",
        "    ;\n",
        "    struct bpf_prog_load_attr prog_load_attr = {\n",
        "        .prog_type = BPF_PROG_TYPE_XDP,}\n",
        "    ;\n",
        "    struct bpf_prog_info info = {}\n",
        "    ;\n",
        "    __u32 info_len = sizeof (info);\n",
        "    const char *optstr = \"FSN\";\n",
        "    int prog_fd, map_fd, opt;\n",
        "    struct bpf_object *obj;\n",
        "    struct bpf_map *map;\n",
        "    char filename [256];\n",
        "    int err;\n",
        "    while ((opt = getopt (argc, argv, optstr)) != -1) {\n",
        "        switch (opt) {\n",
        "        case 'S' :\n",
        "            xdp_flags |= XDP_FLAGS_SKB_MODE;\n",
        "            break;\n",
        "        case 'N' :\n",
        "            break;\n",
        "        case 'F' :\n",
        "            xdp_flags &= ~XDP_FLAGS_UPDATE_IF_NOEXIST;\n",
        "            break;\n",
        "        default :\n",
        "            usage (basename (argv[0]));\n",
        "            return 1;\n",
        "        }\n",
        "    }\n",
        "    if (!(xdp_flags & XDP_FLAGS_SKB_MODE))\n",
        "        xdp_flags |= XDP_FLAGS_DRV_MODE;\n",
        "    if (optind == argc) {\n",
        "        usage (basename (argv[0]));\n",
        "        return 1;\n",
        "    }\n",
        "    if (setrlimit (RLIMIT_MEMLOCK, &r)) {\n",
        "        perror (\"setrlimit(RLIMIT_MEMLOCK)\");\n",
        "        return 1;\n",
        "    }\n",
        "    ifindex = if_nametoindex (argv [optind]);\n",
        "    if (!ifindex) {\n",
        "        perror (\"if_nametoindex\");\n",
        "        return 1;\n",
        "    }\n",
        "    snprintf (filename, sizeof (filename), \"%s_kern.o\", argv[0]);\n",
        "    prog_load_attr.file = filename;\n",
        "    if (bpf_prog_load_xattr (&prog_load_attr, &obj, &prog_fd))\n",
        "        return 1;\n",
        "    map = bpf_map__next (NULL, obj);\n",
        "    if (!map) {\n",
        "        printf (\"finding a map in obj file failed\\n\");\n",
        "        return 1;\n",
        "    }\n",
        "    map_fd = bpf_map__fd (map);\n",
        "    if (!prog_fd) {\n",
        "        printf (\"bpf_prog_load_xattr: %s\\n\", strerror (errno));\n",
        "        return 1;\n",
        "    }\n",
        "    signal (SIGINT, int_exit);\n",
        "    signal (SIGTERM, int_exit);\n",
        "    if (bpf_set_link_xdp_fd (ifindex, prog_fd, xdp_flags) < 0) {\n",
        "        printf (\"link set xdp fd failed\\n\");\n",
        "        return 1;\n",
        "    }\n",
        "    err = bpf_obj_get_info_by_fd (prog_fd, & info, & info_len);\n",
        "    if (err) {\n",
        "        printf (\"can't get prog info - %s\\n\", strerror (errno));\n",
        "        return err;\n",
        "    }\n",
        "    prog_id = info.id;\n",
        "    poll_stats (map_fd, 2);\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "poll_stats",
        "usage"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {}
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    },
    {
      "capabilities": [
        {
          "capability": "map_update",
          "map_update": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_map_update_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}",
                "{Type:  const void ,Var: *value}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_update"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 56,
      "endLine": 129,
      "File": "/home/sayandes/ebpf-projects-annotations/examples/hxdp_xdp_progs/xdp_fw_user.c",
      "funcName": "main",
      "developer_inline_comments": [],
      "updateMaps": [
        " tx_port_map_fd"
      ],
      "readMaps": [],
      "input": [
        "int argc",
        " char **argv"
      ],
      "output": "int",
      "helper": [
        "bpf_map_update_elem"
      ],
      "compatibleHookpoints": [
        "sock_ops",
        "lwt_xmit",
        "raw_tracepoint_writable",
        "socket_filter",
        "sk_reuseport",
        "tracepoint",
        "lwt_seg6local",
        "xdp",
        "cgroup_sock_addr",
        "perf_event",
        "raw_tracepoint",
        "cgroup_sysctl",
        "sk_skb",
        "lwt_in",
        "sk_msg",
        "sched_act",
        "cgroup_device",
        "kprobe",
        "flow_dissector",
        "lwt_out",
        "cgroup_skb",
        "cgroup_sock",
        "sched_cls"
      ],
      "source": [
        "int main (int argc, char **argv)\n",
        "{\n",
        "    struct rlimit r = {RLIM_INFINITY, RLIM_INFINITY}\n",
        "    ;\n",
        "    struct bpf_prog_load_attr prog_load_attr = {\n",
        "        .prog_type = BPF_PROG_TYPE_XDP,}\n",
        "    ;\n",
        "    struct bpf_prog_info info = {}\n",
        "    ;\n",
        "    __u32 info_len = sizeof (info);\n",
        "    int prog_fd;\n",
        "    struct bpf_object *obj;\n",
        "    int ret, key = 0;\n",
        "    char filename [256];\n",
        "    int tx_port_map_fd;\n",
        "    if (setrlimit (RLIMIT_MEMLOCK, &r)) {\n",
        "        perror (\"setrlimit(RLIMIT_MEMLOCK)\");\n",
        "        return 1;\n",
        "    }\n",
        "    snprintf (filename, sizeof (filename), \"%s_kern.o\", argv[0]);\n",
        "    prog_load_attr.file = filename;\n",
        "    if (bpf_prog_load_xattr (&prog_load_attr, &obj, &prog_fd))\n",
        "        return 1;\n",
        "    tx_port_map_fd = bpf_object__find_map_fd_by_name (obj, \"tx_port\");\n",
        "    if (tx_port_map_fd < 0) {\n",
        "        printf (\"bpf_object__find_map_fd_by_name failed\\n\");\n",
        "        return 1;\n",
        "    }\n",
        "    flow_map_fd = bpf_object__find_map_fd_by_name (obj, \"flow_ctx_table\");\n",
        "    if (flow_map_fd < 0) {\n",
        "        printf (\"bpf_object__find_map_fd_by_name failed\\n\");\n",
        "        return 1;\n",
        "    }\n",
        "    if (bpf_set_link_xdp_fd (ifindex_in, prog_fd, xdp_flags) < 0) {\n",
        "        printf (\"ERROR: link set xdp fd failed on %d\\n\", ifindex_in);\n",
        "        return 1;\n",
        "    }\n",
        "    if (bpf_set_link_xdp_fd (ifindex_out, prog_fd, xdp_flags) < 0) {\n",
        "        printf (\"ERROR: link set xdp fd failed on %d\\n\", ifindex_in);\n",
        "        return 1;\n",
        "    }\n",
        "    ret = bpf_obj_get_info_by_fd (prog_fd, & info, & info_len);\n",
        "    if (ret) {\n",
        "        printf (\"can't get prog info - %s\\n\", strerror (errno));\n",
        "        return ret;\n",
        "    }\n",
        "    prog_id = info.id;\n",
        "    signal (SIGINT, int_exit);\n",
        "    signal (SIGTERM, int_exit);\n",
        "    key = B_PORT;\n",
        "    ifindex_out = B_PORT;\n",
        "    ret = bpf_map_update_elem (tx_port_map_fd, & key, & ifindex_out, 0);\n",
        "    if (ret) {\n",
        "        perror (\"bpf_update_elem\");\n",
        "        goto out;\n",
        "    }\n",
        "    poll_stats (10);\n",
        "out :\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "poll_stats",
        "usage"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {}
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ]
}