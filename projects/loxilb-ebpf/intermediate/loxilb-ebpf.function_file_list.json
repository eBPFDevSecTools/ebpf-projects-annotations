{
  "xdp_link_attach": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 20,
      "endLine": 62,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/common/common_user_bpf_xdp.c",
      "funcName": "xdp_link_attach",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": " bpf_get_link_xdp_id + bpf_set_link_xdp_id "
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": " strerror "
        },
        {
          "start_line": 3,
          "end_line": 3,
          "text": " IF_NAMESIZE "
        },
        {
          "start_line": 4,
          "end_line": 4,
          "text": " exit(3) "
        },
        {
          "start_line": 9,
          "end_line": 9,
          "text": " Need XDP flags "
        },
        {
          "start_line": 24,
          "end_line": 24,
          "text": " libbpf provide the XDP net_device link-level hook attach helper "
        },
        {
          "start_line": 27,
          "end_line": 30,
          "text": " Force mode didn't work, probably because a program of the\t\t * opposite type is loaded. Let's unload that and try loading\t\t * again.\t\t "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "int ifindex",
        " __u32 xdp_flags",
        " int prog_fd"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "int xdp_link_attach (int ifindex, __u32 xdp_flags, int prog_fd)\n",
        "{\n",
        "    int err;\n",
        "    err = bpf_set_link_xdp_fd (ifindex, prog_fd, xdp_flags);\n",
        "    if (err == -EEXIST && !(xdp_flags & XDP_FLAGS_UPDATE_IF_NOEXIST)) {\n",
        "        __u32 old_flags = xdp_flags;\n",
        "        xdp_flags &= ~XDP_FLAGS_MODES;\n",
        "        xdp_flags |= (old_flags & XDP_FLAGS_SKB_MODE) ? XDP_FLAGS_DRV_MODE : XDP_FLAGS_SKB_MODE;\n",
        "        err = bpf_set_link_xdp_fd (ifindex, - 1, xdp_flags);\n",
        "        if (!err)\n",
        "            err = bpf_set_link_xdp_fd (ifindex, prog_fd, old_flags);\n",
        "    }\n",
        "    if (err < 0) {\n",
        "        fprintf (stderr, \"ERR: \" \"ifindex(%d) link set xdp fd failed (%d): %s\\n\", ifindex, -err, strerror (-err));\n",
        "        switch (-err) {\n",
        "        case EBUSY :\n",
        "        case EEXIST :\n",
        "            fprintf (stderr, \"Hint: XDP already loaded on device\" \" use --force to swap/replace\\n\");\n",
        "            break;\n",
        "        case EOPNOTSUPP :\n",
        "            fprintf (stderr, \"Hint: Native-XDP not supported\" \" use --skb-mode or --auto-mode\\n\");\n",
        "            break;\n",
        "        default :\n",
        "            break;\n",
        "        }\n",
        "        return EXIT_FAIL_XDP;\n",
        "    }\n",
        "    return EXIT_OK;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "xdp_link_detach": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 64,
      "endLine": 101,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/common/common_user_bpf_xdp.c",
      "funcName": "xdp_link_detach",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "int ifindex",
        " __u32 xdp_flags",
        " __u32 expected_prog_id"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "int xdp_link_detach (int ifindex, __u32 xdp_flags, __u32 expected_prog_id)\n",
        "{\n",
        "    __u32 curr_prog_id;\n",
        "    int err;\n",
        "    err = bpf_get_link_xdp_id (ifindex, & curr_prog_id, xdp_flags);\n",
        "    if (err) {\n",
        "        fprintf (stderr, \"ERR: get link xdp id failed (err=%d): %s\\n\", -err, strerror (-err));\n",
        "        return EXIT_FAIL_XDP;\n",
        "    }\n",
        "    if (!curr_prog_id) {\n",
        "        if (verbose)\n",
        "            printf (\"INFO: %s() no curr XDP prog on ifindex:%d\\n\", __func__, ifindex);\n",
        "        return EXIT_OK;\n",
        "    }\n",
        "    if (expected_prog_id && curr_prog_id != expected_prog_id) {\n",
        "        fprintf (stderr, \"ERR: %s() \" \"expected prog ID(%d) no match(%d), not removing\\n\", __func__, expected_prog_id, curr_prog_id);\n",
        "        return EXIT_FAIL;\n",
        "    }\n",
        "    if ((err = bpf_set_link_xdp_fd (ifindex, -1, xdp_flags)) < 0) {\n",
        "        fprintf (stderr, \"ERR: %s() link set xdp failed (err=%d): %s\\n\", __func__, err, strerror (-err));\n",
        "        return EXIT_FAIL_XDP;\n",
        "    }\n",
        "    if (verbose)\n",
        "        printf (\"INFO: %s() removed XDP prog ID:%d on ifindex:%d\\n\", __func__, curr_prog_id, ifindex);\n",
        "    return EXIT_OK;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "load_bpf_object_file": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 103,
      "endLine": 131,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/common/common_user_bpf_xdp.c",
      "funcName": "load_bpf_object_file",
      "developer_inline_comments": [
        {
          "start_line": 109,
          "end_line": 112,
          "text": " This struct allow us to set ifindex, this features is used for\t * hardware offloading XDP programs (note this sets libbpf\t * bpf_program->prog_ifindex and foreach bpf_map->map_ifindex).\t "
        },
        {
          "start_line": 119,
          "end_line": 121,
          "text": " Use libbpf for extracting BPF byte-code from BPF-ELF object, and\t * loading this into the kernel via bpf-syscall\t "
        },
        {
          "start_line": 129,
          "end_line": 129,
          "text": " Notice how a pointer to a libbpf bpf_object is returned "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const char *filename",
        " int ifindex"
      ],
      "output": "structbpf_object",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "struct bpf_object *load_bpf_object_file (const char *filename, int ifindex)\n",
        "{\n",
        "    int first_prog_fd = -1;\n",
        "    struct bpf_object *obj;\n",
        "    int err;\n",
        "    struct bpf_prog_load_attr prog_load_attr = {\n",
        "        .prog_type = BPF_PROG_TYPE_XDP,\n",
        "        .ifindex = ifindex,}\n",
        "    ;\n",
        "    prog_load_attr.file = filename;\n",
        "    err = bpf_prog_load_xattr (& prog_load_attr, & obj, & first_prog_fd);\n",
        "    if (err) {\n",
        "        fprintf (stderr, \"ERR: loading BPF-OBJ file(%s) (%d): %s\\n\", filename, err, strerror (-err));\n",
        "        return NULL;\n",
        "    }\n",
        "    return obj;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "open_bpf_object": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 133,
      "endLine": 171,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/common/common_user_bpf_xdp.c",
      "funcName": "open_bpf_object",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const char *file",
        " int ifindex"
      ],
      "output": "staticstructbpf_object",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static struct bpf_object *open_bpf_object (const char *file, int ifindex)\n",
        "{\n",
        "    int err;\n",
        "    struct bpf_object *obj;\n",
        "    struct bpf_map *map;\n",
        "    struct bpf_program *prog, *first_prog = NULL;\n",
        "    struct bpf_object_open_attr open_attr = {\n",
        "        .file = file,\n",
        "        .prog_type = BPF_PROG_TYPE_XDP,}\n",
        "    ;\n",
        "    obj = bpf_object__open_xattr (& open_attr);\n",
        "    if (IS_ERR_OR_NULL (obj)) {\n",
        "        err = -PTR_ERR(obj);\n",
        "        fprintf (stderr, \"ERR: opening BPF-OBJ file(%s) (%d): %s\\n\", file, err, strerror (-err));\n",
        "        return NULL;\n",
        "    }\n",
        "    bpf_object__for_each_program (prog, obj) {\n",
        "        bpf_program__set_type (prog, BPF_PROG_TYPE_XDP);\n",
        "        bpf_program__set_ifindex (prog, ifindex);\n",
        "        if (!first_prog)\n",
        "            first_prog = prog;\n",
        "    }\n",
        "    bpf_object__for_each_map (map, obj) {\n",
        "        if (!bpf_map__is_offload_neutral (map))\n",
        "            bpf_map__set_ifindex (map, ifindex);\n",
        "    }\n",
        "    if (!first_prog) {\n",
        "        fprintf (stderr, \"ERR: file %s contains no programs\\n\", file);\n",
        "        return NULL;\n",
        "    }\n",
        "    return obj;\n",
        "}\n"
      ],
      "called_function_list": [
        "PTR_ERR",
        "IS_ERR_OR_NULL"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "reuse_maps": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 173,
      "endLine": 205,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/common/common_user_bpf_xdp.c",
      "funcName": "reuse_maps",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct bpf_object *obj",
        " const char *path"
      ],
      "output": "staticint",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int reuse_maps (struct bpf_object *obj, const char *path)\n",
        "{\n",
        "    struct bpf_map *map;\n",
        "    if (!obj)\n",
        "        return -ENOENT;\n",
        "    if (!path)\n",
        "        return -EINVAL;\n",
        "    bpf_object__for_each_map (map, obj) {\n",
        "        int len, err;\n",
        "        int pinned_map_fd;\n",
        "        char buf [PATH_MAX];\n",
        "        len = snprintf (buf, PATH_MAX, \"%s/%s\", path, bpf_map__name (map));\n",
        "        if (len < 0) {\n",
        "            return -EINVAL;\n",
        "        }\n",
        "        else if (len >= PATH_MAX) {\n",
        "            return -ENAMETOOLONG;\n",
        "        }\n",
        "        pinned_map_fd = bpf_obj_get (buf);\n",
        "        if (pinned_map_fd < 0)\n",
        "            return pinned_map_fd;\n",
        "        err = bpf_map__reuse_fd (map, pinned_map_fd);\n",
        "        if (err)\n",
        "            return err;\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "load_bpf_object_file_reuse_maps": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 207,
      "endLine": 235,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/common/common_user_bpf_xdp.c",
      "funcName": "load_bpf_object_file_reuse_maps",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const char *file",
        " int ifindex",
        " const char *pin_dir"
      ],
      "output": "structbpf_object",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "struct bpf_object *load_bpf_object_file_reuse_maps (const char *file, int ifindex, const char *pin_dir)\n",
        "{\n",
        "    int err;\n",
        "    struct bpf_object *obj;\n",
        "    obj = open_bpf_object (file, ifindex);\n",
        "    if (!obj) {\n",
        "        fprintf (stderr, \"ERR: failed to open object %s\\n\", file);\n",
        "        return NULL;\n",
        "    }\n",
        "    err = reuse_maps (obj, pin_dir);\n",
        "    if (err) {\n",
        "        fprintf (stderr, \"ERR: failed to reuse maps for object %s, pin_dir=%s\\n\", file, pin_dir);\n",
        "        return NULL;\n",
        "    }\n",
        "    err = bpf_object__load (obj);\n",
        "    if (err) {\n",
        "        fprintf (stderr, \"ERR: loading BPF-OBJ file(%s) (%d): %s\\n\", file, err, strerror (-err));\n",
        "        return NULL;\n",
        "    }\n",
        "    return obj;\n",
        "}\n"
      ],
      "called_function_list": [
        "reuse_maps",
        "open_bpf_object"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "load_bpf_and_xdp_attach": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 237,
      "endLine": 295,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/common/common_user_bpf_xdp.c",
      "funcName": "load_bpf_and_xdp_attach",
      "developer_inline_comments": [
        {
          "start_line": 245,
          "end_line": 245,
          "text": " If flags indicate hardware offload, supply ifindex "
        },
        {
          "start_line": 249,
          "end_line": 249,
          "text": " Load the BPF-ELF object file and get back libbpf bpf_object "
        },
        {
          "start_line": 260,
          "end_line": 264,
          "text": " At this point: All XDP/BPF programs from the cfg->filename have been\t * loaded into the kernel, and evaluated by the verifier. Only one of\t * these gets attached to XDP hook, the others will get freed once this\t * process exit.\t "
        },
        {
          "start_line": 267,
          "end_line": 267,
          "text": " Find a matching BPF prog section name "
        },
        {
          "start_line": 270,
          "end_line": 270,
          "text": " Find the first program "
        },
        {
          "start_line": 286,
          "end_line": 289,
          "text": " At this point: BPF-progs are (only) loaded by the kernel, and prog_fd\t * is our select file-descriptor handle. Next step is attaching this FD\t * to a kernel hook point, in this case XDP net_device link-level hook.\t "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct config *cfg"
      ],
      "output": "structbpf_object",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "struct bpf_object *load_bpf_and_xdp_attach (struct config *cfg)\n",
        "{\n",
        "    struct bpf_program *bpf_prog;\n",
        "    struct bpf_object *bpf_obj;\n",
        "    int offload_ifindex = 0;\n",
        "    int prog_fd = -1;\n",
        "    int err;\n",
        "    if (cfg->xdp_flags & XDP_FLAGS_HW_MODE)\n",
        "        offload_ifindex = cfg->ifindex;\n",
        "    if (cfg->reuse_maps)\n",
        "        bpf_obj = load_bpf_object_file_reuse_maps (cfg->filename, offload_ifindex, cfg->pin_dir);\n",
        "    else\n",
        "        bpf_obj = load_bpf_object_file (cfg->filename, offload_ifindex);\n",
        "    if (!bpf_obj) {\n",
        "        fprintf (stderr, \"ERR: loading file: %s\\n\", cfg->filename);\n",
        "        exit (EXIT_FAIL_BPF);\n",
        "    }\n",
        "    if (cfg->progsec[0])\n",
        "        bpf_prog = bpf_object__find_program_by_title (bpf_obj, cfg->progsec);\n",
        "    else\n",
        "        bpf_prog = bpf_program__next (NULL, bpf_obj);\n",
        "    if (!bpf_prog) {\n",
        "        fprintf (stderr, \"ERR: couldn't find a program in ELF section '%s'\\n\", cfg->progsec);\n",
        "        exit (EXIT_FAIL_BPF);\n",
        "    }\n",
        "    strncpy (cfg->progsec, bpf_program__section_name (bpf_prog), sizeof (cfg->progsec));\n",
        "    prog_fd = bpf_program__fd (bpf_prog);\n",
        "    if (prog_fd <= 0) {\n",
        "        fprintf (stderr, \"ERR: bpf_program__fd failed\\n\");\n",
        "        exit (EXIT_FAIL_BPF);\n",
        "    }\n",
        "    err = xdp_link_attach (cfg -> ifindex, cfg -> xdp_flags, prog_fd);\n",
        "    if (err)\n",
        "        exit (err);\n",
        "    return bpf_obj;\n",
        "}\n"
      ],
      "called_function_list": [
        "load_bpf_object_file_reuse_maps",
        "load_bpf_object_file",
        "xdp_link_attach"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "action2str": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 311,
      "endLine": 316,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/common/common_user_bpf_xdp.c",
      "funcName": "action2str",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "__u32 action"
      ],
      "output": "constchar",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "const char *action2str (__u32 action)\n",
        "{\n",
        "    if (action < XDP_ACTION_MAX)\n",
        "        return xdp_action_names[action];\n",
        "    return NULL;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ],
  "check_map_fd_info": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 318,
      "endLine": 347,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/common/common_user_bpf_xdp.c",
      "funcName": "check_map_fd_info",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct bpf_map_info *info",
        " const struct bpf_map_info *exp"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "int check_map_fd_info (const struct bpf_map_info *info, const struct bpf_map_info *exp)\n",
        "{\n",
        "    if (exp->key_size && exp->key_size != info->key_size) {\n",
        "        fprintf (stderr, \"ERR: %s() \" \"Map key size(%d) mismatch expected size(%d)\\n\", __func__, info->key_size, exp->key_size);\n",
        "        return EXIT_FAIL;\n",
        "    }\n",
        "    if (exp->value_size && exp->value_size != info->value_size) {\n",
        "        fprintf (stderr, \"ERR: %s() \" \"Map value size(%d) mismatch expected size(%d)\\n\", __func__, info->value_size, exp->value_size);\n",
        "        return EXIT_FAIL;\n",
        "    }\n",
        "    if (exp->max_entries && exp->max_entries != info->max_entries) {\n",
        "        fprintf (stderr, \"ERR: %s() \" \"Map max_entries(%d) mismatch expected size(%d)\\n\", __func__, info->max_entries, exp->max_entries);\n",
        "        return EXIT_FAIL;\n",
        "    }\n",
        "    if (exp->type && exp->type != info->type) {\n",
        "        fprintf (stderr, \"ERR: %s() \" \"Map type(%d) mismatch expected type(%d)\\n\", __func__, info->type, exp->type);\n",
        "        return EXIT_FAIL;\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ],
  "open_bpf_map_file": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 349,
      "endLine": 381,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/common/common_user_bpf_xdp.c",
      "funcName": "open_bpf_map_file",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const char *pin_dir",
        " const char *mapname",
        " struct bpf_map_info *info"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "int open_bpf_map_file (const char *pin_dir, const char *mapname, struct bpf_map_info *info)\n",
        "{\n",
        "    char filename [PATH_MAX];\n",
        "    int err, len, fd;\n",
        "    __u32 info_len = sizeof (*info);\n",
        "    len = snprintf (filename, PATH_MAX, \"%s/%s\", pin_dir, mapname);\n",
        "    if (len < 0) {\n",
        "        fprintf (stderr, \"ERR: constructing full mapname path\\n\");\n",
        "        return -1;\n",
        "    }\n",
        "    fd = bpf_obj_get (filename);\n",
        "    if (fd < 0) {\n",
        "        fprintf (stderr, \"WARN: Failed to open bpf map file:%s err(%d):%s\\n\", filename, errno, strerror (errno));\n",
        "        return fd;\n",
        "    }\n",
        "    if (info) {\n",
        "        err = bpf_obj_get_info_by_fd (fd, info, & info_len);\n",
        "        if (err) {\n",
        "            fprintf (stderr, \"ERR: %s() can't get info - %s\\n\", __func__, strerror (errno));\n",
        "            return EXIT_FAIL_BPF;\n",
        "        }\n",
        "    }\n",
        "    return fd;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ],
  "IS_ERR_OR_NULL": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 14,
      "endLine": 17,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/common/common_libbpf.c",
      "funcName": "IS_ERR_OR_NULL",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": " Common function that with time should be moved to libbpf "
        },
        {
          "start_line": 11,
          "end_line": 11,
          "text": " From: include/linux/err.h "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const void *ptr"
      ],
      "output": "staticinlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static inline bool IS_ERR_OR_NULL (const void *ptr)\n",
        "{\n",
        "    return (!ptr) || IS_ERR_VALUE ((unsigned long) ptr);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 28,
      "endLine": 31,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/headers/linux/err.h",
      "funcName": "IS_ERR_OR_NULL",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const void *ptr"
      ],
      "output": "staticinlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static inline bool IS_ERR_OR_NULL (const void *ptr)\n",
        "{\n",
        "    return (!ptr) || IS_ERR_VALUE ((unsigned long) ptr);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "bpf_prog_load_xattr_maps": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 24,
      "endLine": 162,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/common/common_libbpf.c",
      "funcName": "bpf_prog_load_xattr_maps",
      "developer_inline_comments": [
        {
          "start_line": 21,
          "end_line": 23,
          "text": " As close as possible to libbpf bpf_prog_load_xattr(), with the * difference of handling pinned maps. "
        },
        {
          "start_line": 50,
          "end_line": 53,
          "text": "\t\t * If type is not specified, try to guess it based on\t\t * section name.\t\t "
        },
        {
          "start_line": 55,
          "end_line": 55,
          "text": " Was: prog->prog_ifindex = attr->ifindex;"
        },
        {
          "start_line": 59,
          "end_line": 59,
          "text": " Use internal libbpf variables "
        },
        {
          "start_line": 78,
          "end_line": 78,
          "text": " Reset attr->pinned_maps.map_fd to identify successful file load "
        },
        {
          "start_line": 87,
          "end_line": 87,
          "text": " Was: map->map_ifindex = attr->ifindex; "
        },
        {
          "start_line": 96,
          "end_line": 96,
          "text": " Matched, try opening pinned file "
        },
        {
          "start_line": 99,
          "end_line": 99,
          "text": " Use FD from pinned map as replacement "
        },
        {
          "start_line": 101,
          "end_line": 104,
          "text": " TODO: Might want to set internal map \"name\"\t\t\t\t * if opened pinned map didn't, to allow\t\t\t\t * bpf_object__find_map_fd_by_name() to work.\t\t\t\t "
        },
        {
          "start_line": 108,
          "end_line": 111,
          "text": " Could not open pinned filename map, then this prog\t\t\t * should then pin the map, BUT this can only happen\t\t\t * after bpf_object__load().\t\t\t "
        },
        {
          "start_line": 127,
          "end_line": 127,
          "text": " Pin the maps that were not loaded via pinned filename "
        },
        {
          "start_line": 138,
          "end_line": 138,
          "text": " Matched, check if map is already loaded "
        },
        {
          "start_line": 142,
          "end_line": 142,
          "text": " Needs to be pinned "
        },
        {
          "start_line": 150,
          "end_line": 150,
          "text": " Help user if requested map name that doesn't exist "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct bpf_prog_load_attr_maps *attr",
        " struct bpf_object **pobj",
        " int *prog_fd"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "int bpf_prog_load_xattr_maps (const struct bpf_prog_load_attr_maps *attr, struct bpf_object **pobj, int *prog_fd)\n",
        "{\n",
        "    struct bpf_object_open_attr open_attr = {\n",
        "        .file = attr->file,\n",
        "        .prog_type = attr->prog_type,}\n",
        "    ;\n",
        "    struct bpf_program *prog, *first_prog = NULL;\n",
        "    enum bpf_attach_type expected_attach_type;\n",
        "    enum bpf_prog_type prog_type;\n",
        "    struct bpf_object *obj;\n",
        "    struct bpf_map *map;\n",
        "    int err;\n",
        "    int i;\n",
        "    if (!attr)\n",
        "        return -EINVAL;\n",
        "    if (!attr->file)\n",
        "        return -EINVAL;\n",
        "    obj = bpf_object__open_xattr (& open_attr);\n",
        "    if (IS_ERR_OR_NULL (obj))\n",
        "        return -ENOENT;\n",
        "    bpf_object__for_each_program (prog, obj) {\n",
        "        prog_type = attr->prog_type;\n",
        "        bpf_program__set_ifindex (prog, attr->ifindex);\n",
        "        expected_attach_type = attr->expected_attach_type;\n",
        "\n",
        "#if 0 /* Use internal libbpf variables */\n",
        "        if (prog_type == BPF_PROG_TYPE_UNSPEC) {\n",
        "            err = bpf_program__identify_section (prog, & prog_type, & expected_attach_type);\n",
        "            if (err < 0) {\n",
        "                bpf_object__close (obj);\n",
        "                return -EINVAL;\n",
        "            }\n",
        "        }\n",
        "\n",
        "#endif\n",
        "        bpf_program__set_type (prog, prog_type);\n",
        "        bpf_program__set_expected_attach_type (prog, expected_attach_type);\n",
        "        if (!first_prog)\n",
        "            first_prog = prog;\n",
        "    }\n",
        "    for (i = 0; i < attr->nr_pinned_maps; i++)\n",
        "        attr->pinned_maps[i].map_fd = -1;\n",
        "    bpf_map__for_each (map, obj) {\n",
        "        const char *mapname = bpf_map__name (map);\n",
        "        if (!bpf_map__is_offload_neutral (map))\n",
        "            bpf_map__set_ifindex (map, attr->ifindex);\n",
        "        for (i = 0; i < attr->nr_pinned_maps; i++) {\n",
        "            struct bpf_pinned_map *pin_map = &attr->pinned_maps[i];\n",
        "            int fd;\n",
        "            if (strcmp (mapname, pin_map->name) != 0)\n",
        "                continue;\n",
        "            fd = bpf_obj_get (pin_map -> filename);\n",
        "            if (fd > 0) {\n",
        "                bpf_map__reuse_fd (map, fd);\n",
        "                pin_map->map_fd = fd;\n",
        "                continue;\n",
        "            }\n",
        "        }\n",
        "    }\n",
        "    if (!first_prog) {\n",
        "        pr_warning (\"object file doesn't contain bpf program\\n\");\n",
        "        bpf_object__close (obj);\n",
        "        return -ENOENT;\n",
        "    }\n",
        "    err = bpf_object__load (obj);\n",
        "    if (err) {\n",
        "        bpf_object__close (obj);\n",
        "        return -EINVAL;\n",
        "    }\n",
        "    bpf_map__for_each (map, obj) {\n",
        "        const char *mapname = bpf_map__name (map);\n",
        "        for (i = 0; i < attr->nr_pinned_maps; i++) {\n",
        "            struct bpf_pinned_map *pin_map = &attr->pinned_maps[i];\n",
        "            int err;\n",
        "            if (strcmp (mapname, pin_map->name) != 0)\n",
        "                continue;\n",
        "            if (pin_map->map_fd != -1)\n",
        "                continue;\n",
        "            err = bpf_map__pin (map, pin_map -> filename);\n",
        "            if (err)\n",
        "                continue;\n",
        "            pin_map->map_fd = bpf_map__fd (map);\n",
        "        }\n",
        "    }\n",
        "    for (i = 0; i < attr->nr_pinned_maps; i++) {\n",
        "        struct bpf_pinned_map *pin_map = &attr->pinned_maps[i];\n",
        "        if (pin_map->map_fd < 0)\n",
        "            pr_warning (\"%s() requested mapname:%s not seen\\n\", __func__, pin_map->name);\n",
        "    }\n",
        "    *pobj = obj;\n",
        "    *prog_fd = bpf_program__fd (first_prog);\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "IS_ERR_OR_NULL"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ],
  "calc_csum": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 11,
      "endLine": 33,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/common/common_sum.c",
      "funcName": "calc_csum",
      "developer_inline_comments": [
        {
          "start_line": 20,
          "end_line": 20,
          "text": "if any bytes left, pad the bytes and add"
        },
        {
          "start_line": 25,
          "end_line": 25,
          "text": "Fold sum to 16 bits: add carrier to result"
        },
        {
          "start_line": 30,
          "end_line": 30,
          "text": "one's complement"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "unsigned short *addr",
        " unsigned int count"
      ],
      "output": "staticunsignedshort",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static unsigned short calc_csum (unsigned short *addr, unsigned int count)\n",
        "{\n",
        "    register unsigned long sum = 0;\n",
        "    while (count > 1) {\n",
        "        sum += *addr++;\n",
        "        count -= 2;\n",
        "    }\n",
        "    if (count > 0) {\n",
        "        sum += ((*addr) & htons (0xFF00));\n",
        "    }\n",
        "    while (sum >> 16) {\n",
        "        sum = (sum & 0xffff) + (sum >> 16);\n",
        "    }\n",
        "    sum = ~sum;\n",
        "    return ((unsigned short) sum);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "calc_tcp6_checksum": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 35,
      "endLine": 93,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/common/common_sum.c",
      "funcName": "calc_tcp6_checksum",
      "developer_inline_comments": [
        {
          "start_line": 42,
          "end_line": 42,
          "text": "add the pseudo header "
        },
        {
          "start_line": 43,
          "end_line": 43,
          "text": "the source ip"
        },
        {
          "start_line": 56,
          "end_line": 56,
          "text": "the dest ip"
        },
        {
          "start_line": 69,
          "end_line": 69,
          "text": "protocol and reserved: 6"
        },
        {
          "start_line": 72,
          "end_line": 72,
          "text": "the length"
        },
        {
          "start_line": 75,
          "end_line": 75,
          "text": "add the IP payload"
        },
        {
          "start_line": 76,
          "end_line": 76,
          "text": "initialize checksum to 0"
        },
        {
          "start_line": 82,
          "end_line": 82,
          "text": "if any bytes left, pad the bytes and add"
        },
        {
          "start_line": 86,
          "end_line": 86,
          "text": "Fold 32-bit sum to 16 bits: add carrier to result"
        },
        {
          "start_line": 91,
          "end_line": 91,
          "text": "set computation result"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct ip6_hdr *pIph",
        " unsigned short *ipPayload"
      ],
      "output": "void",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "void calc_tcp6_checksum (struct ip6_hdr *pIph, unsigned short *ipPayload)\n",
        "{\n",
        "    register unsigned long sum = 0;\n",
        "    unsigned short tcpLen = ntohs (pIph -> ip6_plen);\n",
        "    struct tcphdr *tcphdrp = (struct tcphdr *) (ipPayload);\n",
        "    sum += (pIph->ip6_src.s6_addr32[0] >> 16) & 0xFFFF;\n",
        "    sum += (pIph->ip6_src.s6_addr32[0]) & 0xFFFF;\n",
        "    sum += (pIph->ip6_src.s6_addr32[1] >> 16) & 0xFFFF;\n",
        "    sum += (pIph->ip6_src.s6_addr32[1]) & 0xFFFF;\n",
        "    sum += (pIph->ip6_src.s6_addr32[2] >> 16) & 0xFFFF;\n",
        "    sum += (pIph->ip6_src.s6_addr32[2]) & 0xFFFF;\n",
        "    sum += (pIph->ip6_src.s6_addr32[3] >> 16) & 0xFFFF;\n",
        "    sum += (pIph->ip6_src.s6_addr32[3]) & 0xFFFF;\n",
        "    sum += (pIph->ip6_dst.s6_addr32[0] >> 16) & 0xFFFF;\n",
        "    sum += (pIph->ip6_dst.s6_addr32[0]) & 0xFFFF;\n",
        "    sum += (pIph->ip6_dst.s6_addr32[1] >> 16) & 0xFFFF;\n",
        "    sum += (pIph->ip6_dst.s6_addr32[1]) & 0xFFFF;\n",
        "    sum += (pIph->ip6_dst.s6_addr32[2] >> 16) & 0xFFFF;\n",
        "    sum += (pIph->ip6_dst.s6_addr32[2]) & 0xFFFF;\n",
        "    sum += (pIph->ip6_dst.s6_addr32[3] >> 16) & 0xFFFF;\n",
        "    sum += (pIph->ip6_dst.s6_addr32[3]) & 0xFFFF;\n",
        "    sum += htons (IPPROTO_TCP);\n",
        "    sum += htons (tcpLen);\n",
        "    tcphdrp->check = 0;\n",
        "    while (tcpLen > 1) {\n",
        "        sum += *ipPayload++;\n",
        "        tcpLen -= 2;\n",
        "    }\n",
        "    if (tcpLen > 0) {\n",
        "        sum += ((*ipPayload) & htons (0xFF00));\n",
        "    }\n",
        "    while (sum >> 16) {\n",
        "        sum = (sum & 0xffff) + (sum >> 16);\n",
        "    }\n",
        "    sum = ~sum;\n",
        "    tcphdrp->check = (unsigned short) sum;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "calc_tcp_checksum": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 95,
      "endLine": 131,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/common/common_sum.c",
      "funcName": "calc_tcp_checksum",
      "developer_inline_comments": [
        {
          "start_line": 101,
          "end_line": 101,
          "text": "add the pseudo header "
        },
        {
          "start_line": 102,
          "end_line": 102,
          "text": "the source ip"
        },
        {
          "start_line": 105,
          "end_line": 105,
          "text": "the dest ip"
        },
        {
          "start_line": 108,
          "end_line": 108,
          "text": "protocol and reserved: 6"
        },
        {
          "start_line": 110,
          "end_line": 110,
          "text": "the length"
        },
        {
          "start_line": 113,
          "end_line": 113,
          "text": "add the IP payload"
        },
        {
          "start_line": 114,
          "end_line": 114,
          "text": "initialize checksum to 0"
        },
        {
          "start_line": 120,
          "end_line": 120,
          "text": "if any bytes left, pad the bytes and add"
        },
        {
          "start_line": 124,
          "end_line": 124,
          "text": "Fold 32-bit sum to 16 bits: add carrier to result"
        },
        {
          "start_line": 129,
          "end_line": 129,
          "text": "set computation result"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct iphdr *pIph",
        " unsigned short *ipPayload"
      ],
      "output": "void",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "void calc_tcp_checksum (struct iphdr *pIph, unsigned short *ipPayload)\n",
        "{\n",
        "    register unsigned long sum = 0;\n",
        "    unsigned short tcpLen = ntohs (pIph->tot_len) - (pIph->ihl << 2);\n",
        "    struct tcphdr *tcphdrp = (struct tcphdr *) (ipPayload);\n",
        "    sum += (pIph->saddr >> 16) & 0xFFFF;\n",
        "    sum += (pIph->saddr) & 0xFFFF;\n",
        "    sum += (pIph->daddr >> 16) & 0xFFFF;\n",
        "    sum += (pIph->daddr) & 0xFFFF;\n",
        "    sum += htons (IPPROTO_TCP);\n",
        "    sum += htons (tcpLen);\n",
        "    tcphdrp->check = 0;\n",
        "    while (tcpLen > 1) {\n",
        "        sum += *ipPayload++;\n",
        "        tcpLen -= 2;\n",
        "    }\n",
        "    if (tcpLen > 0) {\n",
        "        sum += ((*ipPayload) & htons (0xFF00));\n",
        "    }\n",
        "    while (sum >> 16) {\n",
        "        sum = (sum & 0xffff) + (sum >> 16);\n",
        "    }\n",
        "    sum = ~sum;\n",
        "    tcphdrp->check = (unsigned short) sum;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "calc_ip_csum": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 133,
      "endLine": 138,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/common/common_sum.c",
      "funcName": "calc_ip_csum",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct iphdr *iph"
      ],
      "output": "void",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "void calc_ip_csum (struct iphdr *iph)\n",
        "{\n",
        "    iph->check = 0;\n",
        "    iph->check = calc_csum ((unsigned short *) iph, (iph->ihl) << 2);\n",
        "}\n"
      ],
      "called_function_list": [
        "calc_csum"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "pdi_map_alloc": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 14,
      "endLine": 29,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/common/common_pdi.c",
      "funcName": "pdi_map_alloc",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 5,
          "text": " * Copyright (c) 2022 NetLOX Inc * * SPDX short identifier: BSD-3-Clause "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const char *name",
        " pdi_add_map_op_t add_map",
        " pdi_del_map_op_t del_map"
      ],
      "output": "structpdi_map",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "struct pdi_map *pdi_map_alloc (const char *name, pdi_add_map_op_t add_map, pdi_del_map_op_t del_map)\n",
        "{\n",
        "    struct pdi_map *map = calloc (1, sizeof (struct pdi_map));\n",
        "    if (name) {\n",
        "        strncpy (map->name, name, PDI_MAP_NAME_LEN);\n",
        "        map->name[PDI_MAP_NAME_LEN - 1] = '\\0';\n",
        "    }\n",
        "    else {\n",
        "        strncpy (map->name, \"default\", PDI_MAP_NAME_LEN);\n",
        "    }\n",
        "    map->pdi_add_map_em = add_map;\n",
        "    map->pdi_del_map_em = del_map;\n",
        "    return map;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "pdi_key2str": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 31,
      "endLine": 44,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/common/common_pdi.c",
      "funcName": "pdi_key2str",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct pdi_key *key",
        " char *fstr"
      ],
      "output": "void",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "void pdi_key2str (struct pdi_key *key, char *fstr)\n",
        "{\n",
        "    int l = 0;\n",
        "    PDI_MATCH_PRINT (&key->dest, \"dest\", fstr, l, none);\n",
        "    PDI_MATCH_PRINT (&key->source, \"source\", fstr, l, none);\n",
        "    PDI_RMATCH_PRINT (&key->dport, \"dport\", fstr, l, none);\n",
        "    PDI_RMATCH_PRINT (&key->dport, \"sport\", fstr, l, none);\n",
        "    PDI_MATCH_PRINT (&key->inport, \"inport\", fstr, l, none);\n",
        "    PDI_MATCH_PRINT (&key->protocol, \"prot\", fstr, l, none);\n",
        "    PDI_MATCH_PRINT (&key->zone, \"zone\", fstr, l, none);\n",
        "    PDI_MATCH_PRINT (&key->bd, \"bd\", fstr, l, none);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "pdi_rule2str": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 46,
      "endLine": 55,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/common/common_pdi.c",
      "funcName": "pdi_rule2str",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct pdi_rule *node"
      ],
      "output": "void",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "void pdi_rule2str (struct pdi_rule *node)\n",
        "{\n",
        "    char fmtstr [1000] = {0};\n",
        "    if (1) {\n",
        "        pdi_key2str (&node->key, fmtstr);\n",
        "        printf (\"(%s)%d\\n\", fmtstr, node->data.pref);\n",
        "    }\n",
        "}\n"
      ],
      "called_function_list": [
        "pdi_key2str"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "pdi_rules2str": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 57,
      "endLine": 68,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/common/common_pdi.c",
      "funcName": "pdi_rules2str",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct pdi_map *map"
      ],
      "output": "void",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "void pdi_rules2str (struct pdi_map *map)\n",
        "{\n",
        "    struct pdi_rule *node = map->head;\n",
        "    printf (\"#### Rules ####\\n\");\n",
        "    while (node) {\n",
        "        pdi_rule2str (node);\n",
        "        node = node->next;\n",
        "    }\n",
        "    printf (\"##############\\n\");\n",
        "}\n"
      ],
      "called_function_list": [
        "pdi_rule2str"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "pdi_rule_insert": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 70,
      "endLine": 123,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/common/common_pdi.c",
      "funcName": "pdi_rule_insert",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct pdi_map *map",
        " struct pdi_rule *new",
        " int *nr"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "int pdi_rule_insert (struct pdi_map *map, struct pdi_rule *new, int *nr)\n",
        "{\n",
        "    struct pdi_rule *prev = NULL;\n",
        "    struct pdi_rule *node;\n",
        "    uint32_t pref = new->data.pref;\n",
        "    if (nr)\n",
        "        *nr = 0;\n",
        "    PDI_MAP_LOCK (map);\n",
        "    node = map->head;\n",
        "    while (node) {\n",
        "        if (pref > node->data.pref) {\n",
        "            if (prev) {\n",
        "                prev->next = new;\n",
        "                new->next = node;\n",
        "            }\n",
        "            else {\n",
        "                map->head = new;\n",
        "                new->next = node;\n",
        "            }\n",
        "            map->nr++;\n",
        "            PDI_MAP_ULOCK (map);\n",
        "            return 0;\n",
        "        }\n",
        "        if (pref == node->data.pref) {\n",
        "            if (PDI_KEY_EQ (&new->key, &node->key)) {\n",
        "                PDI_MAP_ULOCK (map);\n",
        "                return -EEXIST;\n",
        "            }\n",
        "        }\n",
        "        prev = node;\n",
        "        node = node->next;\n",
        "        if (nr) {\n",
        "            *nr = *nr + 1;\n",
        "            ;\n",
        "        }\n",
        "    }\n",
        "    if (prev) {\n",
        "        prev->next = new;\n",
        "        new->next = node;\n",
        "    }\n",
        "    else {\n",
        "        map->head = new;\n",
        "        new->next = node;\n",
        "    }\n",
        "    map->nr++;\n",
        "    PDI_MAP_ULOCK (map);\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "pdi_rule_delete__": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 125,
      "endLine": 153,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/common/common_pdi.c",
      "funcName": "pdi_rule_delete__",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct pdi_map *map",
        " struct pdi_key *key",
        " uint32_t pref",
        " int *nr"
      ],
      "output": "structpdi_rule",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "struct pdi_rule *pdi_rule_delete__ (struct pdi_map *map, struct pdi_key *key, uint32_t pref, int *nr)\n",
        "{\n",
        "    struct pdi_rule *prev = NULL;\n",
        "    struct pdi_rule *node;\n",
        "    node = map->head;\n",
        "    while (node) {\n",
        "        if (pref == node->data.pref) {\n",
        "            if (PDI_KEY_EQ (key, &node->key)) {\n",
        "                if (prev) {\n",
        "                    prev->next = node->next;\n",
        "                }\n",
        "                else {\n",
        "                    map->head = node->next;\n",
        "                }\n",
        "                map->nr--;\n",
        "                return node;\n",
        "            }\n",
        "        }\n",
        "        prev = node;\n",
        "        node = node->next;\n",
        "        if (nr) {\n",
        "            *nr = *nr + 1;\n",
        "        }\n",
        "    }\n",
        "    return NULL;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "pdi_rule_delete": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 155,
      "endLine": 182,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/common/common_pdi.c",
      "funcName": "pdi_rule_delete",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct pdi_map *map",
        " struct pdi_key *key",
        " uint32_t pref",
        " int *nr"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "int pdi_rule_delete (struct pdi_map *map, struct pdi_key *key, uint32_t pref, int *nr)\n",
        "{\n",
        "    struct pdi_rule *node = NULL;\n",
        "    struct pdi_val *val, *tmp;\n",
        "    PDI_MAP_LOCK (map);\n",
        "    node = pdi_rule_delete__ (map, key, pref, nr);\n",
        "    if (node != NULL) {\n",
        "        pdi_rule2str (node);\n",
        "        HASH_ITER (hh, node -> hash, val, tmp) {\n",
        "            HASH_DEL (node->hash, val);\n",
        "            if (map->pdi_del_map_em) {\n",
        "                map->pdi_del_map_em (&val->val);\n",
        "            }\n",
        "            free (val);\n",
        "            printf (\"Hash del\\n\");\n",
        "        }\n",
        "\n",
        "        free (node);\n",
        "        PDI_MAP_ULOCK (map);\n",
        "        return 0;\n",
        "    }\n",
        "    PDI_MAP_ULOCK (map);\n",
        "    return -1;\n",
        "}\n"
      ],
      "called_function_list": [
        "pdi_rule2str",
        "pdi_rule_delete__"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "pdi_rule_get__": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 184,
      "endLine": 197,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/common/common_pdi.c",
      "funcName": "pdi_rule_get__",
      "developer_inline_comments": [
        {
          "start_line": 190,
          "end_line": 190,
          "text": "pdi_rule2str(node);"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct pdi_map *map",
        " struct pdi_key *val"
      ],
      "output": "structpdi_rule",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "struct pdi_rule *pdi_rule_get__ (struct pdi_map *map, struct pdi_key *val)\n",
        "{\n",
        "    struct pdi_rule *node = map->head;\n",
        "    while (node) {\n",
        "        if (PDI_PKEY_EQ (val, &node->key)) {\n",
        "            return node;\n",
        "        }\n",
        "        node = node->next;\n",
        "    }\n",
        "    return NULL;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "pdi_add_val": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 199,
      "endLine": 233,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/common/common_pdi.c",
      "funcName": "pdi_add_val",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct pdi_map *map",
        " struct pdi_key *kval"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "int pdi_add_val (struct pdi_map *map, struct pdi_key *kval)\n",
        "{\n",
        "    struct pdi_val *hval = NULL;\n",
        "    struct pdi_rule *rule = NULL;\n",
        "    PDI_MAP_LOCK (map);\n",
        "    rule = pdi_rule_get__ (map, kval);\n",
        "    if (rule != NULL) {\n",
        "        printf (\"Found match --\\n\");\n",
        "        pdi_rule2str (rule);\n",
        "        HASH_FIND (hh, rule->hash, kval, sizeof (struct pdi_key), hval);\n",
        "        if (hval) {\n",
        "            printf (\"hval exists\\n\");\n",
        "            if (map->pdi_add_map_em) {\n",
        "                map->pdi_add_map_em (kval, &rule->data, sizeof (rule->data));\n",
        "            }\n",
        "            PDI_MAP_ULOCK (map);\n",
        "            return -EEXIST;\n",
        "        }\n",
        "        hval = calloc (1, sizeof (* hval));\n",
        "        memcpy (&hval->val, kval, sizeof (*kval));\n",
        "        hval->r = rule;\n",
        "        HASH_ADD (hh, rule->hash, val, sizeof (struct pdi_key), hval);\n",
        "        PDI_MAP_ULOCK (map);\n",
        "        return 0;\n",
        "    }\n",
        "    PDI_MAP_ULOCK (map);\n",
        "    return -1;\n",
        "}\n"
      ],
      "called_function_list": [
        "pdi_rule2str",
        "pdi_rule_get__"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "pdi_del_val": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 235,
      "endLine": 262,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/common/common_pdi.c",
      "funcName": "pdi_del_val",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct pdi_map *map",
        " struct pdi_key *kval"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "int pdi_del_val (struct pdi_map *map, struct pdi_key *kval)\n",
        "{\n",
        "    struct pdi_val *hval = NULL;\n",
        "    struct pdi_rule *rule = NULL;\n",
        "    PDI_MAP_LOCK (map);\n",
        "    rule = pdi_rule_get__ (map, kval);\n",
        "    if (rule != NULL) {\n",
        "        printf (\"Found match --\\n\");\n",
        "        pdi_rule2str (rule);\n",
        "        HASH_FIND (hh, rule->hash, kval, sizeof (struct pdi_key), hval);\n",
        "        if (hval == NULL) {\n",
        "            printf (\"hval does not exist\\n\");\n",
        "            PDI_MAP_ULOCK (map);\n",
        "            return -EINVAL;\n",
        "        }\n",
        "        HASH_DEL (rule->hash, hval);\n",
        "        PDI_MAP_ULOCK (map);\n",
        "        return 0;\n",
        "    }\n",
        "    PDI_MAP_ULOCK (map);\n",
        "    return -1;\n",
        "}\n"
      ],
      "called_function_list": [
        "pdi_rule2str",
        "pdi_rule_get__"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ],
  "pdi_val_expired": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 264,
      "endLine": 269,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/common/common_pdi.c",
      "funcName": "pdi_val_expired",
      "developer_inline_comments": [
        {
          "start_line": 267,
          "end_line": 267,
          "text": " TODO "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct pdi_val *v"
      ],
      "output": "staticint",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int pdi_val_expired (struct pdi_val *v)\n",
        "{\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "pdi_map_run": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 271,
      "endLine": 297,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/common/common_pdi.c",
      "funcName": "pdi_map_run",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct pdi_map *map"
      ],
      "output": "void",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "void pdi_map_run (struct pdi_map *map)\n",
        "{\n",
        "    struct pdi_rule *node;\n",
        "    struct pdi_val *val, *tmp;\n",
        "    char fmtstr [512] = {0};\n",
        "    PDI_MAP_LOCK (map);\n",
        "    node = map->head;\n",
        "    while (node) {\n",
        "        HASH_ITER (hh, node -> hash, val, tmp) {\n",
        "            if (pdi_val_expired (val)) {\n",
        "                HASH_DEL (node->hash, val);\n",
        "                if (map->pdi_del_map_em) {\n",
        "                    map->pdi_del_map_em (&val->val);\n",
        "                }\n",
        "                pdi_key2str (&val->val, fmtstr);\n",
        "                printf (\"Expired entry %s\\n\", fmtstr);\n",
        "                free (val);\n",
        "            }\n",
        "        }\n",
        "\n",
        "        node = node->next;\n",
        "    }\n",
        "    PDI_MAP_ULOCK (map);\n",
        "}\n"
      ],
      "called_function_list": [
        "pdi_val_expired",
        "pdi_key2str"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ],
  "pdi_unit_test": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 299,
      "endLine": 396,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/common/common_pdi.c",
      "funcName": "pdi_unit_test",
      "developer_inline_comments": [
        {
          "start_line": 349,
          "end_line": 349,
          "text": " Free "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "int pdi_unit_test (void)\n",
        "{\n",
        "    struct pdi_map *map;\n",
        "    int r = 0;\n",
        "    map = pdi_map_alloc (\"ufw4\", NULL, NULL);\n",
        "    struct pdi_rule *new = calloc (1, sizeof (struct pdi_rule));\n",
        "    if (new) {\n",
        "        PDI_MATCH_INIT (&new->key.dest, 0x0a0a0a0a, 0xffffff00);\n",
        "        PDI_RMATCH_INIT (&new->key.dport, 1, 100, 200);\n",
        "        r = pdi_rule_insert (map, new, NULL);\n",
        "        if (r != 0) {\n",
        "            printf (\"Insert fail1\\n\");\n",
        "            exit (0);\n",
        "        }\n",
        "    }\n",
        "    struct pdi_rule *new1 = calloc (1, sizeof (struct pdi_rule));\n",
        "    if (new1) {\n",
        "        memcpy (new1, new, sizeof (*new));\n",
        "        new1->data.pref = 100;\n",
        "        r = pdi_rule_insert (map, new1, NULL);\n",
        "        if (r != 0) {\n",
        "            printf (\"Insert fail2\\n\");\n",
        "            exit (0);\n",
        "        }\n",
        "    }\n",
        "    struct pdi_rule *new2 = calloc (1, sizeof (struct pdi_rule));\n",
        "    if (new2) {\n",
        "        PDI_MATCH_INIT (&new2->key.dest, 0x0a0a0a0a, 0xffffff00);\n",
        "        PDI_RMATCH_INIT (&new2->key.dport, 0, 100, 0xffff);\n",
        "        r = pdi_rule_insert (map, new2, NULL);\n",
        "        if (r != 0) {\n",
        "            printf (\"Insert fail3\\n\");\n",
        "            exit (0);\n",
        "        }\n",
        "        r = pdi_rule_insert (map, new2, NULL);\n",
        "        if (r == 0) {\n",
        "            printf (\"Insert fail4\\n\");\n",
        "            exit (0);\n",
        "        }\n",
        "    }\n",
        "    if (pdi_rule_delete (map, &new1->key, 100, NULL) != 0) {\n",
        "        printf (\"Delete fail4\\n\");\n",
        "        exit (0);\n",
        "    }\n",
        "    struct pdi_rule *new4 = calloc (1, sizeof (struct pdi_rule));\n",
        "    if (new4) {\n",
        "        PDI_MATCH_INIT (&new4->key.dest, 0x0a0a0a0a, 0xffffff00);\n",
        "        PDI_MATCH_INIT (&new4->key.source, 0x0b0b0b00, 0xffffff00);\n",
        "        PDI_RMATCH_INIT (&new4->key.dport, 1, 500, 600);\n",
        "        PDI_RMATCH_INIT (&new4->key.sport, 1, 500, 600);\n",
        "        r = pdi_rule_insert (map, new4, NULL);\n",
        "        if (r != 0) {\n",
        "            printf (\"Insert fail1\\n\");\n",
        "            exit (0);\n",
        "        }\n",
        "    }\n",
        "    pdi_rules2str (map);\n",
        "    if (1) {\n",
        "        struct pdi_key key = {0}\n",
        "        ;\n",
        "        PDI_VAL_INIT (&key.source, 0x0b0b0b0b);\n",
        "        PDI_VAL_INIT (&key.dest, 0x0a0a0a0a);\n",
        "        PDI_RVAL_INIT (&key.dport, 501);\n",
        "        PDI_RVAL_INIT (&key.sport, 501);\n",
        "        if (pdi_add_val (map, &key) != 0) {\n",
        "            printf (\"Failed to add pdi val1\\n\");\n",
        "        }\n",
        "    }\n",
        "    if (1) {\n",
        "        struct pdi_key key = {0}\n",
        "        ;\n",
        "        PDI_VAL_INIT (&key.source, 0x0b0b0b0b);\n",
        "        PDI_VAL_INIT (&key.dest, 0x0a0a0a0a);\n",
        "        PDI_RVAL_INIT (&key.dport, 502);\n",
        "        PDI_RVAL_INIT (&key.sport, 502);\n",
        "        if (pdi_add_val (map, &key) != 0) {\n",
        "            printf (\"Failed to add pdi val2\\n\");\n",
        "        }\n",
        "    }\n",
        "    if (pdi_rule_delete (map, &new4->key, 0, NULL) != 0) {\n",
        "        printf (\"Failed delete--%d\\n\", __LINE__);\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "pdi_map_alloc",
        "pdi_rule_insert",
        "pdi_rule_delete",
        "pdi_add_val",
        "pdi_rules2str"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ],
  "create_raw_tcp6": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 22,
      "endLine": 73,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/common/common_frame.c",
      "funcName": "create_raw_tcp6",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 5,
          "text": " * Copyright (c) 2022 NetLOX Inc * * SPDX short identifier: BSD-3-Clause "
        },
        {
          "start_line": 37,
          "end_line": 37,
          "text": " Fill in the IP header "
        },
        {
          "start_line": 45,
          "end_line": 45,
          "text": " Fill in the TCP header "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *packet",
        " size_t *plen",
        " struct mkr_args *args"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "int create_raw_tcp6 (void *packet, size_t *plen, struct mkr_args *args)\n",
        "{\n",
        "    size_t orig_len;\n",
        "    struct ip6_hdr *pip;\n",
        "    struct tcphdr *ptcp;\n",
        "    if (!packet || !plen)\n",
        "        return -1;\n",
        "    if (!args->v6 || args->protocol != 0x6)\n",
        "        return -1;\n",
        "    orig_len = *plen;\n",
        "    memset (packet, 0, orig_len);\n",
        "    pip = (void *) packet;\n",
        "    pip->ip6_vfc = 0x6 << 4 & 0xff;\n",
        "    pip->ip6_plen = htons (sizeof (struct tcphdr));\n",
        "    pip->ip6_nxt = 0x6;\n",
        "    pip->ip6_hlim = 64;\n",
        "    memcpy (&pip->ip6_src, args->sip, sizeof (pip->ip6_src));\n",
        "    memcpy (&pip->ip6_dst, args->dip, sizeof (pip->ip6_dst));\n",
        "    ptcp = (struct tcphdr *) (pip + 1);\n",
        "    ptcp->source = htons (args->sport);\n",
        "    ptcp->dest = htons (args->dport);\n",
        "    ptcp->seq = htonl (args->t.seq);\n",
        "    ptcp->doff = 5;\n",
        "    if (args->t.fin) {\n",
        "        ptcp->fin = 1;\n",
        "    }\n",
        "    if (args->t.syn) {\n",
        "        ptcp->syn = 1;\n",
        "    }\n",
        "    if (args->t.rst) {\n",
        "        ptcp->rst = 1;\n",
        "    }\n",
        "    if (args->t.ack) {\n",
        "        ptcp->ack = 1;\n",
        "    }\n",
        "    if (args->t.psh) {\n",
        "        ptcp->psh = 1;\n",
        "    }\n",
        "    if (args->t.urg) {\n",
        "        ptcp->urg = 1;\n",
        "    }\n",
        "    calc_tcp6_checksum (pip, (void *) ptcp);\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "calc_tcp6_checksum"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "create_raw_tcp": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 75,
      "endLine": 131,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/common/common_frame.c",
      "funcName": "create_raw_tcp",
      "developer_inline_comments": [
        {
          "start_line": 84,
          "end_line": 84,
          "text": " Unsupported for now "
        },
        {
          "start_line": 91,
          "end_line": 91,
          "text": " Fill in the IP header "
        },
        {
          "start_line": 103,
          "end_line": 103,
          "text": " Fill in the TCP header "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *packet",
        " size_t *plen",
        " struct mkr_args *args"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "int create_raw_tcp (void *packet, size_t *plen, struct mkr_args *args)\n",
        "{\n",
        "    size_t orig_len;\n",
        "    struct iphdr *pip;\n",
        "    struct tcphdr *ptcp;\n",
        "    if (!packet || !plen)\n",
        "        return -1;\n",
        "    if (args->v6 || args->protocol != 0x6)\n",
        "        return -1;\n",
        "    orig_len = *plen;\n",
        "    memset (packet, 0, orig_len);\n",
        "    pip = (void *) packet;\n",
        "    pip->version = 4;\n",
        "    pip->ihl = 5;\n",
        "    pip->tot_len = htons (sizeof (struct iphdr) + sizeof (struct tcphdr));\n",
        "    pip->id = 0xbeef;\n",
        "    pip->frag_off = 0x0000;\n",
        "    pip->protocol = 0x6;\n",
        "    pip->ttl = 64;\n",
        "    pip->saddr = htonl (args->sip[0]);\n",
        "    pip->daddr = htonl (args->dip[0]);\n",
        "    calc_ip_csum (pip);\n",
        "    ptcp = (struct tcphdr *) (pip + 1);\n",
        "    ptcp->source = htons (args->sport);\n",
        "    ptcp->dest = htons (args->dport);\n",
        "    ptcp->seq = htonl (args->t.seq);\n",
        "    ptcp->doff = 5;\n",
        "    if (args->t.fin) {\n",
        "        ptcp->fin = 1;\n",
        "    }\n",
        "    if (args->t.syn) {\n",
        "        ptcp->syn = 1;\n",
        "    }\n",
        "    if (args->t.rst) {\n",
        "        ptcp->rst = 1;\n",
        "    }\n",
        "    if (args->t.ack) {\n",
        "        ptcp->ack = 1;\n",
        "    }\n",
        "    if (args->t.psh) {\n",
        "        ptcp->psh = 1;\n",
        "    }\n",
        "    if (args->t.urg) {\n",
        "        ptcp->urg = 1;\n",
        "    }\n",
        "    calc_tcp_checksum (pip, (void *) ptcp);\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "calc_ip_csum",
        "calc_tcp_checksum"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "xmit_raw": [
    {
      "capabilities": [
        {
          "capability": "update_pkt",
          "update_pkt": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Description": "Emulate a call to setsockopt() on the socket associated to <[ socket ]>(IP: 0) , which must be a full socket. The <[ level ]>(IP: 1) at which the option resides and the name <[ optname ]>(IP: 2) of the option must be specified , see setsockopt(2) for more information. The option value of length <[ optlen ]>(IP: 4) is pointed by optval. This helper actually implements a subset of setsockopt(). It supports the following levels: \u00b7 SOL_SOCKET , which supports the following optnames: SO_RCVBUF , SO_SNDBUF , SO_MAX_PACING_RATE , SO_PRIORITY , SO_RCVLOWAT , SO_MARK. \u00b7 IPPROTO_TCP , which supports the following optnames: TCP_CONGESTION , TCP_BPF_IW , TCP_BPF_SNDCWND_CLAMP. \u00b7 IPPROTO_IP , which supports <[ optname ]>(IP: 2) IP_TOS. \u00b7 IPPROTO_IPV6 , which supports <[ optname ]>(IP: 2) IPV6_TCLASS. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "setsockopt",
              "Input Params": [
                "{Type: struct sock_ops ,Var: *socket}",
                "{Type:  int ,Var: level}",
                "{Type:  int ,Var: optname}",
                "{Type:  char ,Var: *optval}",
                "{Type:  int ,Var: optlen}"
              ],
              "compatible_hookpoints": [
                "sock_ops"
              ],
              "capabilities": [
                "update_pkt"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 133,
      "endLine": 188,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/common/common_frame.c",
      "funcName": "xmit_raw",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *packet",
        " size_t plen",
        " struct mkr_args *args"
      ],
      "output": "staticint",
      "helper": [
        "setsockopt"
      ],
      "compatibleHookpoints": [
        "sock_ops"
      ],
      "source": [
        "static int xmit_raw (void *packet, size_t plen, struct mkr_args *args)\n",
        "{\n",
        "    struct sockaddr_in caddr;\n",
        "    struct sockaddr_in6 caddr6;\n",
        "    void *sockaddr = NULL;\n",
        "    int raw_socket;\n",
        "    int hdr_incl = 1;\n",
        "    int sent_bytes;\n",
        "    if (args->v6 == 0) {\n",
        "        if ((raw_socket = socket (AF_INET, SOCK_RAW, args->protocol)) < 0) {\n",
        "            return -1;\n",
        "        }\n",
        "        if (setsockopt (raw_socket, IPPROTO_IP, IP_HDRINCL, &hdr_incl, sizeof (hdr_incl)) < 0) {\n",
        "            close (raw_socket);\n",
        "            return -1;\n",
        "        }\n",
        "        memset (&caddr, 0, sizeof (caddr));\n",
        "        caddr.sin_family = AF_INET;\n",
        "        caddr.sin_port = htons (args->dport);\n",
        "        caddr.sin_addr.s_addr = htonl (args->dip[0]);\n",
        "        sockaddr = &caddr;\n",
        "    }\n",
        "    else {\n",
        "        if ((raw_socket = socket (AF_INET6, SOCK_RAW, IPPROTO_UDP)) < 0) {\n",
        "            return -1;\n",
        "        }\n",
        "        if (setsockopt (raw_socket, IPPROTO_IPV6, IPV6_HDRINCL, &hdr_incl, sizeof (hdr_incl)) < 0) {\n",
        "            close (raw_socket);\n",
        "            return -1;\n",
        "        }\n",
        "        memset (&caddr6, 0, sizeof (caddr6));\n",
        "        caddr6.sin6_family = AF_INET6;\n",
        "        caddr6.sin6_port = 0;\n",
        "        memcpy (&caddr6.sin6_addr, args->dip, 16);\n",
        "        sockaddr = &caddr6;\n",
        "    }\n",
        "    sent_bytes = sendto (raw_socket, packet, plen, 0, (struct sockaddr *) sockaddr, args -> v6 ? sizeof (struct sockaddr_in6) : sizeof (struct sockaddr_in));\n",
        "    if (sent_bytes < 0) {\n",
        "        close (raw_socket);\n",
        "        return -1;\n",
        "    }\n",
        "    close (raw_socket);\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "create_xmit_raw_tcp": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 190,
      "endLine": 209,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/common/common_frame.c",
      "funcName": "create_xmit_raw_tcp",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct mkr_args *args"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "int create_xmit_raw_tcp (struct mkr_args *args)\n",
        "{\n",
        "    uint8_t frame [64] = {0};\n",
        "    size_t len;\n",
        "    int ret;\n",
        "    if (args->v6) {\n",
        "        len = sizeof (struct ip6_hdr) + sizeof (struct tcphdr);\n",
        "        ret = create_raw_tcp6 (frame, & len, args);\n",
        "    }\n",
        "    else {\n",
        "        len = sizeof (struct iphdr) + sizeof (struct tcphdr);\n",
        "        ret = create_raw_tcp (frame, & len, args);\n",
        "    }\n",
        "    if (ret < 0) {\n",
        "        return -1;\n",
        "    }\n",
        "    return xmit_raw (frame, len, args);\n",
        "}\n"
      ],
      "called_function_list": [
        "xmit_raw",
        "create_raw_tcp6",
        "create_raw_tcp"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_do_if_lkup": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 7,
      "endLine": 61,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_devif.c",
      "funcName": "dp_do_if_lkup",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 6,
          "text": " *  llb_kernel_devif.c: LoxiLB kernel eBPF dev in/out pipeline *  Copyright (C) 2022,  NetLOX <www.netlox.io> *  * SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause) "
        },
        {
          "start_line": 37,
          "end_line": 37,
          "text": "LLBS_PPLN_DROP(xf);"
        }
      ],
      "updateMaps": [],
      "readMaps": [
        "  intf_map",
        "  tx_intf_map"
      ],
      "input": [
        "void *ctx",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_do_if_lkup (void *ctx, struct xfi *xf)\n",
        "{\n",
        "    struct intf_key key;\n",
        "    struct dp_intf_tact *l2a;\n",
        "    key.ifindex = DP_IFI (ctx);\n",
        "    key.ing_vid = xf->l2m.vlan[0];\n",
        "    key.pad = 0;\n",
        "\n",
        "#ifdef HAVE_DP_EGR_HOOK\n",
        "    if (DP_IIFI (ctx) == 0) {\n",
        "        __u32 ikey = LLB_PORT_NO;\n",
        "        __u32 *oif = NULL;\n",
        "        oif = bpf_map_lookup_elem (& tx_intf_map, & ikey);\n",
        "        if (!oif) {\n",
        "            return DP_PASS;\n",
        "        }\n",
        "        key.ifindex = *(__u32*) oif;\n",
        "    }\n",
        "\n",
        "#endif\n",
        "    LL_DBG_PRINTK (\"[INTF] -- Lookup\\n\");\n",
        "    LL_DBG_PRINTK (\"[INTF] ifidx %d vid %d\\n\", key.ifindex, bpf_ntohs (key.ing_vid));\n",
        "    xf->pm.table_id = LL_DP_SMAC_MAP;\n",
        "    l2a = bpf_map_lookup_elem (& intf_map, & key);\n",
        "    if (!l2a) {\n",
        "        LL_DBG_PRINTK (\"[INTF] not found\");\n",
        "        LLBS_PPLN_PASS (xf);\n",
        "        return -1;\n",
        "    }\n",
        "    LL_DBG_PRINTK (\"[INTF] L2 action %d\\n\", l2a->ca.act_type);\n",
        "    if (l2a->ca.act_type == DP_SET_DROP) {\n",
        "        LLBS_PPLN_DROP (xf);\n",
        "    }\n",
        "    else if (l2a->ca.act_type == DP_SET_TOCP) {\n",
        "        LLBS_PPLN_TRAP (xf);\n",
        "    }\n",
        "    else if (l2a->ca.act_type == DP_SET_IFI) {\n",
        "        xf->pm.iport = l2a->set_ifi.xdp_ifidx;\n",
        "        xf->pm.zone = l2a->set_ifi.zone;\n",
        "        xf->pm.bd = l2a->set_ifi.bd;\n",
        "        xf->pm.mirr = l2a->set_ifi.mirr;\n",
        "        xf->pm.pprop = l2a->set_ifi.pprop;\n",
        "        xf->qm.ipolid = l2a->set_ifi.polid;\n",
        "    }\n",
        "    else {\n",
        "        LLBS_PPLN_DROP (xf);\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_do_mark_mirr": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 64,
      "endLine": 82,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_devif.c",
      "funcName": "dp_do_mark_mirr",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [
        "  tx_intf_map"
      ],
      "input": [
        "void *ctx",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_map_lookup_elem",
        "redirect",
        "bpf_clone_redirect"
      ],
      "compatibleHookpoints": [
        "lwt_xmit",
        "sched_cls",
        "sched_act"
      ],
      "source": [
        "static int __always_inline dp_do_mark_mirr (void *ctx, struct xfi *xf)\n",
        "{\n",
        "    struct  __sk_buff *skb = DP_TC_PTR (ctx);\n",
        "    int *oif;\n",
        "    int key;\n",
        "    key = LLB_PORT_NO;\n",
        "    oif = bpf_map_lookup_elem (& tx_intf_map, & key);\n",
        "    if (!oif) {\n",
        "        return -1;\n",
        "    }\n",
        "    skb->cb[0] = LLB_MIRR_MARK;\n",
        "    skb->cb[1] = xf->pm.mirr;\n",
        "    LL_DBG_PRINTK (\"[REDR] Mirr port %d OIF %d\\n\", key, *oif);\n",
        "    return bpf_clone_redirect (skb, *oif, BPF_F_INGRESS);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 116,
      "endLine": 120,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_devif.c",
      "funcName": "dp_do_mark_mirr",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_do_mark_mirr (void *ctx, struct xfi *xf)\n",
        "{\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_do_mirr_lkup": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 84,
      "endLine": 112,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_devif.c",
      "funcName": "dp_do_mirr_lkup",
      "developer_inline_comments": [
        {
          "start_line": 108,
          "end_line": 108,
          "text": " VXLAN to be done "
        }
      ],
      "updateMaps": [],
      "readMaps": [
        "  mirr_map"
      ],
      "input": [
        "void *ctx",
        " struct xfi *xf"
      ],
      "output": "staticint",
      "helper": [
        "bpf_map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int dp_do_mirr_lkup (void *ctx, struct xfi *xf)\n",
        "{\n",
        "    struct dp_mirr_tact *ma;\n",
        "    __u32 mkey = xf->pm.mirr;\n",
        "    LL_DBG_PRINTK (\"[MIRR] -- Lookup\\n\");\n",
        "    LL_DBG_PRINTK (\"[MIRR] -- Key %u\\n\", mkey);\n",
        "    ma = bpf_map_lookup_elem (& mirr_map, & mkey);\n",
        "    if (!ma) {\n",
        "        LLBS_PPLN_DROP (xf);\n",
        "        return -1;\n",
        "    }\n",
        "    LL_DBG_PRINTK (\"[MIRR] Action %d\\n\", ma->ca.act_type);\n",
        "    if (ma->ca.act_type == DP_SET_ADD_L2VLAN || ma->ca.act_type == DP_SET_RM_L2VLAN) {\n",
        "        struct dp_l2vlan_act *va = &ma->vlan_act;\n",
        "        return dp_set_egr_vlan (ctx, xf, ma->ca.act_type == DP_SET_RM_L2VLAN ? 0 : va->vlan, va->oport);\n",
        "    }\n",
        "    LLBS_PPLN_DROP (xf);\n",
        "    return -1;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_set_egr_vlan"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 122,
      "endLine": 127,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_devif.c",
      "funcName": "dp_do_mirr_lkup",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_do_mirr_lkup (void *ctx, struct xfi *xf)\n",
        "{\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_set_egr_vlan"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_trap_packet": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 131,
      "endLine": 158,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_devif.c",
      "funcName": "dp_trap_packet",
      "developer_inline_comments": [
        {
          "start_line": 138,
          "end_line": 138,
          "text": " Metadata will be in the perf event before the packet data. "
        }
      ],
      "updateMaps": [],
      "readMaps": [
        "  pkts"
      ],
      "input": [
        "void *ctx",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_map_lookup_elem",
        "bpf_perf_event_output"
      ],
      "compatibleHookpoints": [
        "socket_filter",
        "sock_ops",
        "xdp",
        "sched_act",
        "lwt_seg6local",
        "raw_tracepoint",
        "lwt_in",
        "sk_skb",
        "lwt_xmit",
        "raw_tracepoint_writable",
        "kprobe",
        "perf_event",
        "lwt_out",
        "sched_cls",
        "cgroup_skb",
        "tracepoint"
      ],
      "source": [
        "static int __always_inline dp_trap_packet (void *ctx, struct xfi *xf)\n",
        "{\n",
        "    struct ll_dp_pmdi *pmd;\n",
        "    int z = 0;\n",
        "    __u64 flags = BPF_F_CURRENT_CPU;\n",
        "    pmd = bpf_map_lookup_elem (& pkts, & z);\n",
        "    if (!pmd)\n",
        "        return 0;\n",
        "    LL_DBG_PRINTK (\"[TRAP] START--\\n\");\n",
        "    pmd->ifindex = ctx->ingress_ifindex;\n",
        "    pmd->xdp_inport = xf->pm.iport;\n",
        "    pmd->xdp_oport = xf->pm.oport;\n",
        "    pmd->pm.table_id = xf->table_id;\n",
        "    pmd->rcode = xf->pm.rcode;\n",
        "    pmd->pkt_len = xf->pm.py_bytes;\n",
        "    flags |= (__u64) pmd->pkt_len << 32;\n",
        "    if (bpf_perf_event_output (ctx, &pkt_ring, flags, pmd, sizeof (*pmd))) {\n",
        "        LL_DBG_PRINTK (\"[TRAP] FAIL--\\n\");\n",
        "    }\n",
        "    return DP_DROP;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_add_l2",
        "dp_redirect_port"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 160,
      "endLine": 226,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_devif.c",
      "funcName": "dp_trap_packet",
      "developer_inline_comments": [
        {
          "start_line": 171,
          "end_line": 173,
          "text": " FIXME - There is a problem right now if we send decapped   * packet up the stack. So, this is a safety check for now   "
        },
        {
          "start_line": 174,
          "end_line": 174,
          "text": "if (xf->tm.tun_decap)"
        },
        {
          "start_line": 175,
          "end_line": 175,
          "text": "  return DP_DROP;"
        },
        {
          "start_line": 182,
          "end_line": 182,
          "text": " If tunnel was present, outer metadata is popped "
        },
        {
          "start_line": 187,
          "end_line": 190,
          "text": " This can fail to push headroom for tunnelled packets.     * It might be better to pass it rather than drop it in case     * of failure     "
        },
        {
          "start_line": 203,
          "end_line": 203,
          "text": " Add LLB shim "
        },
        {
          "start_line": 215,
          "end_line": 215,
          "text": " FIXME "
        },
        {
          "start_line": 224,
          "end_line": 224,
          "text": " TODO - Apply stats "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf",
        " void *fa_"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "redirect"
      ],
      "compatibleHookpoints": [
        "lwt_xmit",
        "sched_cls",
        "xdp",
        "sched_act"
      ],
      "source": [
        "static int __always_inline dp_trap_packet (void *ctx, struct xfi *xf, void *fa_)\n",
        "{\n",
        "    struct ethhdr *neth;\n",
        "    struct ethhdr *oeth;\n",
        "    uint16_t ntype;\n",
        "    struct llb_ethhdr *llb;\n",
        "    void *dend = DP_TC_PTR (DP_PDATA_END (ctx));\n",
        "    LL_DBG_PRINTK (\"[TRAP] START--\\n\");\n",
        "    oeth = DP_TC_PTR (DP_PDATA (ctx));\n",
        "    if (oeth + 1 > dend) {\n",
        "        return DP_DROP;\n",
        "    }\n",
        "    memcpy (xf->l2m.dl_dst, oeth->h_dest, 6 * 2);\n",
        "    ntype = oeth->h_proto;\n",
        "    if (dp_add_l2 (ctx, (int) sizeof (*llb))) {\n",
        "        return DP_PASS;\n",
        "    }\n",
        "    neth = DP_TC_PTR (DP_PDATA (ctx));\n",
        "    dend = DP_TC_PTR (DP_PDATA_END (ctx));\n",
        "    if (neth + 1 > dend) {\n",
        "        return DP_DROP;\n",
        "    }\n",
        "    memcpy (neth->h_dest, xf->l2m.dl_dst, 6 * 2);\n",
        "    neth->h_proto = bpf_htons (ETH_TYPE_LLB);\n",
        "    llb = DP_ADD_PTR (neth, sizeof (* neth));\n",
        "    if (llb + 1 > dend) {\n",
        "        return DP_DROP;\n",
        "    }\n",
        "    llb->iport = bpf_htons (xf->pm.iport);\n",
        "    llb->oport = bpf_htons (xf->pm.oport);\n",
        "    llb->rcode = xf->pm.rcode;\n",
        "    if (xf->tm.tun_decap) {\n",
        "        llb->rcode |= LLB_PIPE_RC_TUN_DECAP;\n",
        "    }\n",
        "    llb->mmap = xf->pm.table_id;\n",
        "    llb->ntype = ntype;\n",
        "    xf->pm.oport = LLB_PORT_NO;\n",
        "    if (dp_redirect_port (&tx_intf_map, xf) != DP_REDIRECT) {\n",
        "        LL_DBG_PRINTK (\"[TRAP] FAIL--\\n\");\n",
        "        return DP_DROP;\n",
        "    }\n",
        "    return DP_REDIRECT;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_add_l2",
        "dp_redirect_port"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_redir_packet": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 229,
      "endLine": 244,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_devif.c",
      "funcName": "dp_redir_packet",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "redirect"
      ],
      "compatibleHookpoints": [
        "lwt_xmit",
        "sched_cls",
        "xdp",
        "sched_act"
      ],
      "source": [
        "static int __always_inline dp_redir_packet (void *ctx, struct xfi *xf)\n",
        "{\n",
        "    LL_DBG_PRINTK (\"[REDI] --\\n\");\n",
        "    if (dp_redirect_port (&tx_intf_map, xf) != DP_REDIRECT) {\n",
        "        LL_DBG_PRINTK (\"[REDI] FAIL--\\n\");\n",
        "        return DP_DROP;\n",
        "    }\n",
        "\n",
        "#ifdef LLB_DP_IF_STATS\n",
        "    dp_do_map_stats (ctx, xf, LL_DP_TX_INTF_STATS_MAP, xf->pm.oport);\n",
        "\n",
        "#endif\n",
        "    return DP_REDIRECT;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_redirect_port",
        "dp_do_map_stats"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_rewire_packet": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 246,
      "endLine": 257,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_devif.c",
      "funcName": "dp_rewire_packet",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_rewire_packet (void *ctx, struct xfi *xf)\n",
        "{\n",
        "    LL_DBG_PRINTK (\"[REWR] --\\n\");\n",
        "    if (dp_rewire_port (&tx_intf_map, xf) != DP_REDIRECT) {\n",
        "        LL_DBG_PRINTK (\"[REWR] FAIL--\\n\");\n",
        "        return DP_DROP;\n",
        "    }\n",
        "    return DP_REDIRECT;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_rewire_port"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_pipe_check_res": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 262,
      "endLine": 311,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_devif.c",
      "funcName": "dp_pipe_check_res",
      "developer_inline_comments": [
        {
          "start_line": 259,
          "end_line": 259,
          "text": "#ifdef HAVE_DP_FUNCS"
        },
        {
          "start_line": 260,
          "end_line": 260,
          "text": "static int"
        },
        {
          "start_line": 261,
          "end_line": 261,
          "text": "#else"
        },
        {
          "start_line": 263,
          "end_line": 263,
          "text": "#endif"
        },
        {
          "start_line": 310,
          "end_line": 310,
          "text": " FIXME "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf",
        " void *fa"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_pipe_check_res (void *ctx, struct xfi *xf, void *fa)\n",
        "{\n",
        "    LL_DBG_PRINTK (\"[PIPE] act 0x%x\\n\", xf->pm.pipe_act);\n",
        "\n",
        "#ifdef HAVE_DP_EGR_HOOK\n",
        "    DP_LLB_MRK_INGP (ctx);\n",
        "\n",
        "#endif\n",
        "    if (xf->pm.pipe_act) {\n",
        "        if (xf->pm.pipe_act & LLB_PIPE_DROP) {\n",
        "            return DP_DROP;\n",
        "        }\n",
        "        if (dp_unparse_packet_always (ctx, xf) != 0) {\n",
        "            return DP_DROP;\n",
        "        }\n",
        "\n",
        "#ifndef HAVE_LLB_DISAGGR\n",
        "\n",
        "#ifdef HAVE_OOB_CH\n",
        "        if (xf->pm.pipe_act & LLB_PIPE_TRAP) {\n",
        "            return dp_trap_packet (ctx, xf, fa);\n",
        "        }\n",
        "        if (xf->pm.pipe_act & LLB_PIPE_PASS) {\n",
        "            return DP_PASS;\n",
        "        }\n",
        "\n",
        "#else\n",
        "        if (xf->pm.pipe_act & (LLB_PIPE_TRAP | LLB_PIPE_PASS)) {\n",
        "            return DP_PASS;\n",
        "        }\n",
        "\n",
        "#endif\n",
        "\n",
        "#else\n",
        "        if (xf->pm.pipe_act & (LLB_PIPE_TRAP | LLB_PIPE_PASS)) {\n",
        "            return dp_trap_packet (ctx, xf, fa);\n",
        "        }\n",
        "\n",
        "#endif\n",
        "        if (xf->pm.pipe_act & LLB_PIPE_RDR_MASK) {\n",
        "            if (dp_unparse_packet (ctx, xf) != 0) {\n",
        "                return DP_DROP;\n",
        "            }\n",
        "            return dp_redir_packet (ctx, xf);\n",
        "        }\n",
        "    }\n",
        "    return DP_PASS;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_unparse_packet",
        "dp_trap_packet",
        "dp_unparse_packet_always",
        "dp_redir_packet"
      ],
      "call_depth": 5,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_ing": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 313,
      "endLine": 331,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_devif.c",
      "funcName": "dp_ing",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_ing (void *ctx, struct xfi *xf)\n",
        "{\n",
        "    dp_do_if_lkup (ctx, xf);\n",
        "\n",
        "#ifdef LLB_DP_IF_STATS\n",
        "    dp_do_map_stats (ctx, xf, LL_DP_INTF_STATS_MAP, xf->pm.iport);\n",
        "\n",
        "#endif\n",
        "    dp_do_map_stats (ctx, xf, LL_DP_BD_STATS_MAP, xf->pm.bd);\n",
        "    if (xf->pm.mirr != 0) {\n",
        "        dp_do_mark_mirr (ctx, xf);\n",
        "    }\n",
        "    if (xf->qm.ipolid != 0) {\n",
        "        do_dp_policer (ctx, xf, 0);\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_do_if_lkup",
        "dp_do_map_stats",
        "dp_do_mark_mirr",
        "do_dp_policer"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_insert_fcv4": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        },
        {
          "capability": "map_update",
          "map_update": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_map_update_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}",
                "{Type:  const void ,Var: *value}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_update"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 333,
      "endLine": 359,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_devif.c",
      "funcName": "dp_insert_fcv4",
      "developer_inline_comments": [],
      "updateMaps": [
        " fc_v4_map"
      ],
      "readMaps": [
        " fc_v4_map",
        "  tx_intf_map",
        "  xfck"
      ],
      "input": [
        "void *ctx",
        " struct xfi *xf",
        " struct dp_fc_tacts *acts"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_map_lookup_elem",
        "bpf_map_update_elem"
      ],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "cgroup_device",
        "lwt_xmit",
        "cgroup_sock",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "cgroup_sysctl",
        "sk_msg",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "perf_event",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_insert_fcv4 (void *ctx, struct xfi *xf, struct dp_fc_tacts *acts)\n",
        "{\n",
        "    struct dp_fcv4_key *key;\n",
        "    int z = 0;\n",
        "    int *oif;\n",
        "    int pkey = xf->pm.oport;\n",
        "    oif = bpf_map_lookup_elem (& tx_intf_map, & pkey);\n",
        "    if (oif) {\n",
        "        acts->ca.oaux = *oif;\n",
        "    }\n",
        "    LL_DBG_PRINTK (\"[FCH4] INS--\\n\");\n",
        "    key = bpf_map_lookup_elem (& xfck, & z);\n",
        "    if (key == NULL) {\n",
        "        return -1;\n",
        "    }\n",
        "    if (bpf_map_lookup_elem (&fc_v4_map, key) != NULL) {\n",
        "        return 1;\n",
        "    }\n",
        "    bpf_map_update_elem (&fc_v4_map, key, acts, BPF_ANY);\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_ing_slow_main": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        },
        {
          "capability": "read_sys_info",
          "read_sys_info": [
            {
              "Project": "bcc",
              "FunctionName": "bpf_ktime_get_ns",
              "Return Type": "u64",
              "Description": "u64 bpf_ktime_get_ns(void) Return: u64 number of nanoseconds. Starts at system boot time but stops during suspend. Examples in situ: \"https://github.com/iovisor/bcc/search?q=bpf_ktime_get_ns+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=bpf_ktime_get_ns+path%3Atools&type=Code search /tools ",
              "Return": "u64 number of nanoseconds",
              "Input Prameters": [],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 361,
      "endLine": 420,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_devif.c",
      "funcName": "dp_ing_slow_main",
      "developer_inline_comments": [
        {
          "start_line": 371,
          "end_line": 371,
          "text": " No nonsense no loop "
        },
        {
          "start_line": 381,
          "end_line": 381,
          "text": " memset is too costly "
        },
        {
          "start_line": 382,
          "end_line": 382,
          "text": "memset(fa->fcta, 0, sizeof(fa->fcta));"
        },
        {
          "start_line": 387,
          "end_line": 390,
          "text": " If there are any packets marked for mirroring, we do   * it here and immediately get it out of way without   * doing any further processing   "
        },
        {
          "start_line": 398,
          "end_line": 400,
          "text": " If there are pipeline errors at this stage,   * we again skip any further processing   "
        },
        {
          "start_line": 408,
          "end_line": 408,
          "text": " fast-cache is used only when certain conditions are met "
        }
      ],
      "updateMaps": [],
      "readMaps": [
        "  fcas"
      ],
      "input": [
        "void *ctx",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_map_lookup_elem",
        "bpf_ktime_get_ns",
        "bpf_tail_call"
      ],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "lwt_xmit",
        "cgroup_sock",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "perf_event",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_ing_slow_main (void *ctx, struct xfi *xf)\n",
        "{\n",
        "    struct dp_fc_tacts *fa = NULL;\n",
        "\n",
        "#ifdef HAVE_DP_FC\n",
        "    int z = 0;\n",
        "    fa = bpf_map_lookup_elem (& fcas, & z);\n",
        "    if (!fa)\n",
        "        return 0;\n",
        "    fa->ca.ftrap = 0;\n",
        "    fa->ca.cidx = 0;\n",
        "    fa->zone = 0;\n",
        "    fa->its = bpf_ktime_get_ns ();\n",
        "\n",
        "#pragma clang loop unroll(full)\n",
        "    for (z = 0; z < LLB_FCV4_MAP_ACTS; z++) {\n",
        "        fa->fcta[z].ca.act_type = 0;\n",
        "    }\n",
        "\n",
        "#endif\n",
        "    LL_DBG_PRINTK (\"[INGR] START--\\n\");\n",
        "    if (xf->pm.mirr != 0) {\n",
        "        dp_do_mirr_lkup (ctx, xf);\n",
        "        goto out;\n",
        "    }\n",
        "    dp_ing (ctx, xf);\n",
        "    if (xf->pm.pipe_act || xf->pm.tc == 0) {\n",
        "        goto out;\n",
        "    }\n",
        "    dp_ing_l2 (ctx, xf, fa);\n",
        "\n",
        "#ifdef HAVE_DP_FC\n",
        "    if (LL_PIPE_FC_CAP (xf)) {\n",
        "        fa->zone = xf->pm.zone;\n",
        "        dp_insert_fcv4 (ctx, xf, fa);\n",
        "    }\n",
        "\n",
        "#endif\n",
        "out :\n",
        "    xf->pm.phit |= LLB_DP_RES_HIT;\n",
        "    bpf_tail_call (ctx, &pgm_tbl, LLB_DP_CT_PGM_ID);\n",
        "    return DP_PASS;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_ing_l2",
        "dp_do_mirr_lkup",
        "dp_insert_fcv4",
        "dp_ing"
      ],
      "call_depth": 10,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_ing_ct_main": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 422,
      "endLine": 475,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_devif.c",
      "funcName": "dp_ing_ct_main",
      "developer_inline_comments": [
        {
          "start_line": 437,
          "end_line": 440,
          "text": " If ACL is hit, and packet arrives here    * it only means that we need CT processing.   * In such a case, we skip nat lookup   "
        },
        {
          "start_line": 463,
          "end_line": 469,
          "text": " CT pipeline is hit after acl lookup fails    * So, after CT processing we continue the rest   * of the stack. We could potentially make    * another tail-call to where ACL lookup failed   * and start over. But simplicity wins against   * complexity for now    "
        }
      ],
      "updateMaps": [],
      "readMaps": [
        "  fcas"
      ],
      "input": [
        "void *ctx",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_map_lookup_elem",
        "bpf_tail_call"
      ],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "lwt_xmit",
        "cgroup_sock",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "perf_event",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_ing_ct_main (void *ctx, struct xfi *xf)\n",
        "{\n",
        "    int val = 0;\n",
        "    struct dp_fc_tacts *fa = NULL;\n",
        "\n",
        "#ifdef HAVE_DP_FC\n",
        "    fa = bpf_map_lookup_elem (& fcas, & val);\n",
        "    if (!fa)\n",
        "        return DP_DROP;\n",
        "\n",
        "#endif\n",
        "    if (xf->pm.phit & LLB_DP_RES_HIT) {\n",
        "        goto res_end;\n",
        "    }\n",
        "    if ((xf->pm.phit & LLB_DP_ACL_HIT) == 0) {\n",
        "        if (xf->pm.fw_lid < LLB_FW4_MAP_ENTRIES) {\n",
        "            bpf_tail_call (ctx, &pgm_tbl, LLB_DP_FW_PGM_ID);\n",
        "        }\n",
        "        if (xf->pm.dp_rec) {\n",
        "            dp_record_it (ctx, xf);\n",
        "        }\n",
        "        dp_do_nat (ctx, xf);\n",
        "    }\n",
        "    LL_DBG_PRINTK (\"[CTRK] start\\n\");\n",
        "    val = dp_ct_in (ctx, xf);\n",
        "    if (val < 0) {\n",
        "        return DP_PASS;\n",
        "    }\n",
        "    xf->nm.ct_sts = LLB_PIPE_CT_INP;\n",
        "    dp_l3_fwd (ctx, xf, fa);\n",
        "    dp_eg_l2 (ctx, xf, fa);\n",
        "res_end :\n",
        "    return dp_pipe_check_res (ctx, xf, fa);\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_record_it",
        "dp_eg_l2",
        "dp_l3_fwd",
        "dp_pipe_check_res",
        "dp_ct_in",
        "dp_do_nat"
      ],
      "call_depth": 6,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_ing_pass_main": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 477,
      "endLine": 483,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_devif.c",
      "funcName": "dp_ing_pass_main",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_ing_pass_main (void *ctx)\n",
        "{\n",
        "    LL_DBG_PRINTK (\"[INGR] PASS--\\n\");\n",
        "    return DP_PASS;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_run_ct_helper": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 59,
      "endLine": 78,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_ct.c",
      "funcName": "dp_run_ct_helper",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 6,
          "text": " *  llb_kern_ct.c: Loxilb kernel eBPF ConnTracking Implementation *  Copyright (C) 2022,  NetLOX <www.netlox.io> *  * SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause) "
        },
        {
          "start_line": 73,
          "end_line": 75,
          "text": " We dont do much strict tracking after EST state.   * But need to maintain minimal ctinfo   "
        }
      ],
      "updateMaps": [],
      "readMaps": [
        "  ct_map"
      ],
      "input": [
        "struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_run_ct_helper (struct xfi *xf)\n",
        "{\n",
        "    struct dp_ct_key key;\n",
        "    struct dp_ct_tact *act;\n",
        "    CT_KEY_GEN (&key, xf);\n",
        "    act = bpf_map_lookup_elem (& ct_map, & key);\n",
        "    if (!act) {\n",
        "        LL_DBG_PRINTK (\"[FCH4] miss\");\n",
        "        return -1;\n",
        "    }\n",
        "    dp_run_ctact_helper (xf, act);\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ],
  "dp_ct_get_newctr": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 91,
      "endLine": 116,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_ct.c",
      "funcName": "dp_ct_get_newctr",
      "developer_inline_comments": [
        {
          "start_line": 104,
          "end_line": 106,
          "text": " FIXME - We can potentially do a percpu array and do away   *         with the locking here   "
        }
      ],
      "updateMaps": [],
      "readMaps": [
        "  ct_ctr"
      ],
      "input": [
        "void"
      ],
      "output": "static__u32__always_inline",
      "helper": [
        "bpf_map_lookup_elem",
        "bpf_spin_lock",
        "bpf_spin_unlock"
      ],
      "compatibleHookpoints": [
        "socket_filter",
        "sock_ops",
        "xdp",
        "sched_act",
        "sk_reuseport",
        "lwt_seg6local",
        "lwt_in",
        "sk_skb",
        "cgroup_skb",
        "lwt_xmit",
        "cgroup_sock",
        "lwt_out",
        "sched_cls",
        "flow_dissector",
        "sk_msg",
        "cgroup_sock_addr"
      ],
      "source": [
        "static __u32 __always_inline dp_ct_get_newctr (void)\n",
        "{\n",
        "    __u32 k = 0;\n",
        "    __u32 v = 0;\n",
        "    struct dp_ct_ctrtact *ctr;\n",
        "    ctr = bpf_map_lookup_elem (& ct_ctr, & k);\n",
        "    if (ctr == NULL) {\n",
        "        return 0;\n",
        "    }\n",
        "    bpf_spin_lock (&ctr->lock);\n",
        "    v = ctr->counter;\n",
        "    ctr->counter += 2;\n",
        "    if (ctr->counter >= ctr->entries) {\n",
        "        ctr->counter = ctr->start;\n",
        "    }\n",
        "    bpf_spin_unlock (&ctr->lock);\n",
        "    return v;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_ct_proto_xfk_init": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 118,
      "endLine": 223,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_ct.c",
      "funcName": "dp_ct_proto_xfk_init",
      "developer_inline_comments": [
        {
          "start_line": 143,
          "end_line": 143,
          "text": " Apply NAT xfrm if needed "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct dp_ct_key *key",
        " nxfrm_inf_t *xi",
        " struct dp_ct_key *xkey",
        " nxfrm_inf_t *xxi"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_ct_proto_xfk_init (struct dp_ct_key *key, nxfrm_inf_t *xi, struct dp_ct_key *xkey, nxfrm_inf_t *xxi)\n",
        "{\n",
        "    DP_XADDR_CP (xkey->daddr, key->saddr);\n",
        "    DP_XADDR_CP (xkey->saddr, key->daddr);\n",
        "    xkey->sport = key->dport;\n",
        "    xkey->dport = key->sport;\n",
        "    xkey->l4proto = key->l4proto;\n",
        "    xkey->zone = key->zone;\n",
        "    xkey->v6 = key->v6;\n",
        "    if (xi->dsr) {\n",
        "        if (xi->nat_flags & LLB_NAT_DST) {\n",
        "            xxi->nat_flags = LLB_NAT_SRC;\n",
        "            DP_XADDR_CP (xxi->nat_xip, key->daddr);\n",
        "            xxi->nat_xport = key->dport;\n",
        "            xxi->nv6 = xi->nv6;\n",
        "        }\n",
        "        xxi->dsr = xi->dsr;\n",
        "        return 0;\n",
        "    }\n",
        "    if (xi->nat_flags & LLB_NAT_DST) {\n",
        "        xkey->v6 = (__u8) (xi->nv6);\n",
        "        DP_XADDR_CP (xkey->saddr, xi->nat_xip);\n",
        "        if (!DP_XADDR_ISZR(xi->nat_rip)) {\n",
        "            DP_XADDR_CP (xkey->daddr, xi->nat_rip);\n",
        "            DP_XADDR_CP (xxi->nat_rip, key->saddr);\n",
        "        }\n",
        "        if (key->l4proto != IPPROTO_ICMP) {\n",
        "            if (xi->nat_xport)\n",
        "                xkey->sport = xi->nat_xport;\n",
        "            else\n",
        "                xi->nat_xport = key->dport;\n",
        "        }\n",
        "        xxi->nat_flags = LLB_NAT_SRC;\n",
        "        xxi->nv6 = key->v6;\n",
        "        DP_XADDR_CP (xxi->nat_xip, key->daddr);\n",
        "        if (key->l4proto != IPPROTO_ICMP)\n",
        "            xxi->nat_xport = key->dport;\n",
        "    }\n",
        "    if (xi->nat_flags & LLB_NAT_SRC) {\n",
        "        xkey->v6 = xi->nv6;\n",
        "        DP_XADDR_CP (xkey->daddr, xi->nat_xip);\n",
        "        if (!DP_XADDR_ISZR(xi->nat_rip)) {\n",
        "            DP_XADDR_CP (xkey->saddr, xi->nat_rip);\n",
        "            DP_XADDR_CP (xxi->nat_rip, key->daddr);\n",
        "        }\n",
        "        if (key->l4proto != IPPROTO_ICMP) {\n",
        "            if (xi->nat_xport)\n",
        "                xkey->dport = xi->nat_xport;\n",
        "            else\n",
        "                xi->nat_xport = key->sport;\n",
        "        }\n",
        "        xxi->nat_flags = LLB_NAT_DST;\n",
        "        xxi->nv6 = key->v6;\n",
        "        DP_XADDR_CP (xxi->nat_xip, key->saddr);\n",
        "        if (key->l4proto != IPPROTO_ICMP)\n",
        "            xxi->nat_xport = key->sport;\n",
        "    }\n",
        "    if (xi->nat_flags & LLB_NAT_HDST) {\n",
        "        DP_XADDR_CP (xkey->saddr, key->saddr);\n",
        "        DP_XADDR_CP (xkey->daddr, key->daddr);\n",
        "        if (key->l4proto != IPPROTO_ICMP) {\n",
        "            if (xi->nat_xport)\n",
        "                xkey->sport = xi->nat_xport;\n",
        "            else\n",
        "                xi->nat_xport = key->dport;\n",
        "        }\n",
        "        xxi->nat_flags = LLB_NAT_HSRC;\n",
        "        xxi->nv6 = key->v6;\n",
        "        DP_XADDR_SETZR (xxi->nat_xip);\n",
        "        DP_XADDR_SETZR (xi->nat_xip);\n",
        "        if (key->l4proto != IPPROTO_ICMP)\n",
        "            xxi->nat_xport = key->dport;\n",
        "    }\n",
        "    if (xi->nat_flags & LLB_NAT_HSRC) {\n",
        "        DP_XADDR_CP (xkey->saddr, key->saddr);\n",
        "        DP_XADDR_CP (xkey->daddr, key->daddr);\n",
        "        if (key->l4proto != IPPROTO_ICMP) {\n",
        "            if (xi->nat_xport)\n",
        "                xkey->dport = xi->nat_xport;\n",
        "            else\n",
        "                xi->nat_xport = key->sport;\n",
        "        }\n",
        "        xxi->nat_flags = LLB_NAT_HDST;\n",
        "        xxi->nv6 = key->v6;\n",
        "        DP_XADDR_SETZR (xxi->nat_xip);\n",
        "        DP_XADDR_SETZR (xi->nat_xip);\n",
        "        if (key->l4proto != IPPROTO_ICMP)\n",
        "            xxi->nat_xport = key->sport;\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_ct3_sm": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 225,
      "endLine": 260,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_ct.c",
      "funcName": "dp_ct3_sm",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct dp_ct_dat *tdat",
        " struct dp_ct_dat *xtdat",
        " ct_dir_t dir"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_ct3_sm (struct dp_ct_dat *tdat, struct dp_ct_dat *xtdat, ct_dir_t dir)\n",
        "{\n",
        "    ct_state_t new_state = tdat->pi.l3i.state;\n",
        "    switch (tdat->pi.l3i.state) {\n",
        "    case CT_STATE_NONE :\n",
        "        if (dir == CT_DIR_IN) {\n",
        "            new_state = CT_STATE_REQ;\n",
        "        }\n",
        "        else {\n",
        "            return -1;\n",
        "        }\n",
        "        break;\n",
        "    case CT_STATE_REQ :\n",
        "        if (dir == CT_DIR_OUT) {\n",
        "            new_state = CT_STATE_REP;\n",
        "        }\n",
        "        break;\n",
        "    case CT_STATE_REP :\n",
        "        if (dir == CT_DIR_IN) {\n",
        "            new_state = CT_STATE_EST;\n",
        "        }\n",
        "        break;\n",
        "    default :\n",
        "        break;\n",
        "    }\n",
        "    tdat->pi.l3i.state = new_state;\n",
        "    if (new_state == CT_STATE_EST) {\n",
        "        return 1;\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ],
  "dp_ct_tcp_sm": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 262,
      "endLine": 495,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_ct.c",
      "funcName": "dp_ct_tcp_sm",
      "developer_inline_comments": [
        {
          "start_line": 318,
          "end_line": 320,
          "text": " If DP starts after TCP was established     * we need to somehow handle this particular case     "
        },
        {
          "start_line": 344,
          "end_line": 344,
          "text": " SYN sent with ack 0 "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf",
        " struct dp_ct_tact *atdat",
        " struct dp_ct_tact *axtdat",
        " ct_dir_t dir"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_spin_lock",
        "bpf_spin_unlock"
      ],
      "compatibleHookpoints": [
        "socket_filter",
        "sock_ops",
        "xdp",
        "sched_act",
        "sk_reuseport",
        "lwt_seg6local",
        "lwt_in",
        "sk_skb",
        "cgroup_skb",
        "lwt_xmit",
        "cgroup_sock",
        "lwt_out",
        "sched_cls",
        "flow_dissector",
        "sk_msg",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_ct_tcp_sm (void *ctx, struct xfi *xf, struct dp_ct_tact *atdat, struct dp_ct_tact *axtdat, ct_dir_t dir)\n",
        "{\n",
        "    struct dp_ct_dat *tdat = &atdat->ctd;\n",
        "    struct dp_ct_dat *xtdat = &axtdat->ctd;\n",
        "    ct_tcp_pinf_t *ts = &tdat->pi.t;\n",
        "    ct_tcp_pinf_t *rts = &xtdat->pi.t;\n",
        "    void *dend = DP_TC_PTR (DP_PDATA_END (ctx));\n",
        "    struct tcphdr *t = DP_ADD_PTR (DP_PDATA (ctx), xf->pm.l4_off);\n",
        "    uint8_t tcp_flags = xf->pm.tcp_flags;\n",
        "    ct_tcp_pinfd_t *td = &ts->tcp_cts[dir];\n",
        "    ct_tcp_pinfd_t *rtd;\n",
        "    uint32_t seq;\n",
        "    uint32_t ack;\n",
        "    uint32_t nstate = 0;\n",
        "    if (t + 1 > dend) {\n",
        "        LLBS_PPLN_DROP (xf);\n",
        "        return -1;\n",
        "    }\n",
        "    seq = bpf_ntohl (t -> seq);\n",
        "    ack = bpf_ntohl (t -> ack_seq);\n",
        "    bpf_spin_lock (&atdat->lock);\n",
        "    if (dir == CT_DIR_IN) {\n",
        "        tdat->pi.t.tcp_cts[0].pseq = t->seq;\n",
        "        tdat->pi.t.tcp_cts[0].pack = t->ack_seq;\n",
        "        tdat->pb.bytes += xf->pm.l3_len;\n",
        "        tdat->pb.packets += 1;\n",
        "    }\n",
        "    else {\n",
        "        xtdat->pi.t.tcp_cts[0].pseq = t->seq;\n",
        "        xtdat->pi.t.tcp_cts[0].pack = t->ack_seq;\n",
        "        xtdat->pb.bytes += xf->pm.l3_len;\n",
        "        xtdat->pb.packets += 1;\n",
        "    }\n",
        "    rtd = &ts->tcp_cts[dir == CT_DIR_IN ? CT_DIR_OUT : CT_DIR_IN];\n",
        "    if (tcp_flags & LLB_TCP_RST) {\n",
        "        nstate = CT_TCP_CW;\n",
        "        goto end;\n",
        "    }\n",
        "    switch (ts->state) {\n",
        "    case CT_TCP_CLOSED :\n",
        "        if (xf->nm.dsr) {\n",
        "            nstate = CT_TCP_EST;\n",
        "            goto end;\n",
        "        }\n",
        "        if (tcp_flags & LLB_TCP_ACK) {\n",
        "            td->seq = seq;\n",
        "            if (td->init_acks) {\n",
        "                if (ack > rtd->seq + 2) {\n",
        "                    nstate = CT_TCP_ERR;\n",
        "                    goto end;\n",
        "                }\n",
        "            }\n",
        "            td->init_acks++;\n",
        "            if (td->init_acks >= CT_TCP_INIT_ACK_THRESHOLD && rtd->init_acks >= CT_TCP_INIT_ACK_THRESHOLD) {\n",
        "                nstate = CT_TCP_EST;\n",
        "                break;\n",
        "            }\n",
        "            nstate = CT_TCP_ERR;\n",
        "            goto end;\n",
        "        }\n",
        "        if ((tcp_flags & LLB_TCP_SYN) != LLB_TCP_SYN) {\n",
        "            nstate = CT_TCP_ERR;\n",
        "            goto end;\n",
        "        }\n",
        "        if (ack != 0 && dir != CT_DIR_IN) {\n",
        "            nstate = CT_TCP_ERR;\n",
        "            goto end;\n",
        "        }\n",
        "        td->seq = seq;\n",
        "        nstate = CT_TCP_SS;\n",
        "        break;\n",
        "    case CT_TCP_SS :\n",
        "        if (dir != CT_DIR_OUT) {\n",
        "            if ((tcp_flags & LLB_TCP_SYN) == LLB_TCP_SYN) {\n",
        "                td->seq = seq;\n",
        "                nstate = CT_TCP_SS;\n",
        "            }\n",
        "            else {\n",
        "                nstate = CT_TCP_ERR;\n",
        "            }\n",
        "            goto end;\n",
        "        }\n",
        "        if ((tcp_flags & (LLB_TCP_SYN | LLB_TCP_ACK)) != (LLB_TCP_SYN | LLB_TCP_ACK)) {\n",
        "            nstate = CT_TCP_ERR;\n",
        "            goto end;\n",
        "        }\n",
        "        if (ack != rtd->seq + 1) {\n",
        "            nstate = CT_TCP_ERR;\n",
        "            goto end;\n",
        "        }\n",
        "        td->seq = seq;\n",
        "        nstate = CT_TCP_SA;\n",
        "        break;\n",
        "    case CT_TCP_SA :\n",
        "        if (dir != CT_DIR_IN) {\n",
        "            if ((tcp_flags & (LLB_TCP_SYN | LLB_TCP_ACK)) != (LLB_TCP_SYN | LLB_TCP_ACK)) {\n",
        "                nstate = CT_TCP_ERR;\n",
        "                goto end;\n",
        "            }\n",
        "            if (ack != rtd->seq + 1) {\n",
        "                nstate = CT_TCP_ERR;\n",
        "                goto end;\n",
        "            }\n",
        "            nstate = CT_TCP_SA;\n",
        "            goto end;\n",
        "        }\n",
        "        if ((tcp_flags & LLB_TCP_SYN) == LLB_TCP_SYN) {\n",
        "            td->seq = seq;\n",
        "            nstate = CT_TCP_SS;\n",
        "            goto end;\n",
        "        }\n",
        "        if ((tcp_flags & LLB_TCP_ACK) != LLB_TCP_ACK) {\n",
        "            nstate = CT_TCP_ERR;\n",
        "            goto end;\n",
        "        }\n",
        "        if (ack != rtd->seq + 1) {\n",
        "            nstate = CT_TCP_ERR;\n",
        "            goto end;\n",
        "        }\n",
        "        td->seq = seq;\n",
        "        nstate = CT_TCP_EST;\n",
        "        break;\n",
        "    case CT_TCP_EST :\n",
        "        if (tcp_flags & LLB_TCP_FIN) {\n",
        "            ts->fndir = dir;\n",
        "            nstate = CT_TCP_FINI;\n",
        "            td->seq = seq;\n",
        "        }\n",
        "        else {\n",
        "            nstate = CT_TCP_EST;\n",
        "        }\n",
        "        break;\n",
        "    case CT_TCP_FINI :\n",
        "        if (ts->fndir != dir) {\n",
        "            if ((tcp_flags & (LLB_TCP_FIN | LLB_TCP_ACK)) == (LLB_TCP_FIN | LLB_TCP_ACK)) {\n",
        "                if (ack != rtd->seq + 1) {\n",
        "                    nstate = CT_TCP_ERR;\n",
        "                    goto end;\n",
        "                }\n",
        "                nstate = CT_TCP_FINI3;\n",
        "                td->seq = seq;\n",
        "            }\n",
        "            else if (tcp_flags & LLB_TCP_ACK) {\n",
        "                if (ack != rtd->seq + 1) {\n",
        "                    nstate = CT_TCP_ERR;\n",
        "                    goto end;\n",
        "                }\n",
        "                nstate = CT_TCP_FINI2;\n",
        "                td->seq = seq;\n",
        "            }\n",
        "        }\n",
        "        break;\n",
        "    case CT_TCP_FINI2 :\n",
        "        if (ts->fndir != dir) {\n",
        "            if (tcp_flags & LLB_TCP_FIN) {\n",
        "                nstate = CT_TCP_FINI3;\n",
        "                td->seq = seq;\n",
        "            }\n",
        "        }\n",
        "        break;\n",
        "    case CT_TCP_FINI3 :\n",
        "        if (ts->fndir == dir) {\n",
        "            if (tcp_flags & LLB_TCP_ACK) {\n",
        "                if (ack != rtd->seq + 1) {\n",
        "                    nstate = CT_TCP_ERR;\n",
        "                    goto end;\n",
        "                }\n",
        "                nstate = CT_TCP_CW;\n",
        "            }\n",
        "        }\n",
        "        break;\n",
        "    default :\n",
        "        break;\n",
        "    }\n",
        "end :\n",
        "    ts->state = nstate;\n",
        "    rts->state = nstate;\n",
        "    if (nstate != CT_TCP_ERR && dir == CT_DIR_OUT) {\n",
        "        xtdat->pi.t.tcp_cts[0].seq = seq;\n",
        "    }\n",
        "    bpf_spin_unlock (&atdat->lock);\n",
        "    if (nstate == CT_TCP_EST) {\n",
        "        return CT_SMR_EST;\n",
        "    }\n",
        "    else if (nstate & CT_TCP_CW) {\n",
        "        return CT_SMR_CTD;\n",
        "    }\n",
        "    else if (nstate & CT_TCP_ERR) {\n",
        "        return CT_SMR_ERR;\n",
        "    }\n",
        "    else if (nstate & CT_TCP_FIN_MASK) {\n",
        "        return CT_SMR_FIN;\n",
        "    }\n",
        "    return CT_SMR_INPROG;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_ct_udp_sm": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 497,
      "endLine": 559,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_ct.c",
      "funcName": "dp_ct_udp_sm",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf",
        " struct dp_ct_tact *atdat",
        " struct dp_ct_tact *axtdat",
        " ct_dir_t dir"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_spin_lock",
        "bpf_spin_unlock"
      ],
      "compatibleHookpoints": [
        "socket_filter",
        "sock_ops",
        "xdp",
        "sched_act",
        "sk_reuseport",
        "lwt_seg6local",
        "lwt_in",
        "sk_skb",
        "cgroup_skb",
        "lwt_xmit",
        "cgroup_sock",
        "lwt_out",
        "sched_cls",
        "flow_dissector",
        "sk_msg",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_ct_udp_sm (void *ctx, struct xfi *xf, struct dp_ct_tact *atdat, struct dp_ct_tact *axtdat, ct_dir_t dir)\n",
        "{\n",
        "    struct dp_ct_dat *tdat = &atdat->ctd;\n",
        "    struct dp_ct_dat *xtdat = &axtdat->ctd;\n",
        "    ct_udp_pinf_t *us = &tdat->pi.u;\n",
        "    ct_udp_pinf_t *xus = &xtdat->pi.u;\n",
        "    uint32_t nstate = us->state;\n",
        "    bpf_spin_lock (&atdat->lock);\n",
        "    if (dir == CT_DIR_IN) {\n",
        "        tdat->pb.bytes += xf->pm.l3_len;\n",
        "        tdat->pb.packets += 1;\n",
        "        us->pkts_seen++;\n",
        "    }\n",
        "    else {\n",
        "        xtdat->pb.bytes += xf->pm.l3_len;\n",
        "        xtdat->pb.packets += 1;\n",
        "        us->rpkts_seen++;\n",
        "    }\n",
        "    switch (us->state) {\n",
        "    case CT_UDP_CNI :\n",
        "        if (xf->nm.dsr) {\n",
        "            nstate = CT_UDP_EST;\n",
        "            break;\n",
        "        }\n",
        "        if (us->pkts_seen && us->rpkts_seen) {\n",
        "            nstate = CT_UDP_EST;\n",
        "        }\n",
        "        else if (us->pkts_seen > CT_UDP_CONN_THRESHOLD) {\n",
        "            nstate = CT_UDP_UEST;\n",
        "        }\n",
        "        break;\n",
        "    case CT_UDP_UEST :\n",
        "        if (us->rpkts_seen)\n",
        "            nstate = CT_UDP_EST;\n",
        "        break;\n",
        "    case CT_UDP_EST :\n",
        "        break;\n",
        "    default :\n",
        "        break;\n",
        "    }\n",
        "    us->state = nstate;\n",
        "    xus->state = nstate;\n",
        "    bpf_spin_unlock (&atdat->lock);\n",
        "    if (nstate == CT_UDP_UEST)\n",
        "        return CT_SMR_UEST;\n",
        "    else if (nstate == CT_UDP_EST)\n",
        "        return CT_SMR_EST;\n",
        "    return CT_SMR_INPROG;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_ct_icmp6_sm": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 561,
      "endLine": 656,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_ct.c",
      "funcName": "dp_ct_icmp6_sm",
      "developer_inline_comments": [
        {
          "start_line": 581,
          "end_line": 584,
          "text": " We fetch the sequence number even if icmp may not be   * echo type because we can't call another fn holding   * spinlock   "
        },
        {
          "start_line": 608,
          "end_line": 608,
          "text": " Further state-machine processing "
        },
        {
          "start_line": 641,
          "end_line": 641,
          "text": " Connection is tracked now "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf",
        " struct dp_ct_tact *atdat",
        " struct dp_ct_tact *axtdat",
        " ct_dir_t dir"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_spin_lock",
        "bpf_spin_unlock"
      ],
      "compatibleHookpoints": [
        "socket_filter",
        "sock_ops",
        "xdp",
        "sched_act",
        "sk_reuseport",
        "lwt_seg6local",
        "lwt_in",
        "sk_skb",
        "cgroup_skb",
        "lwt_xmit",
        "cgroup_sock",
        "lwt_out",
        "sched_cls",
        "flow_dissector",
        "sk_msg",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_ct_icmp6_sm (void *ctx, struct xfi *xf, struct dp_ct_tact *atdat, struct dp_ct_tact *axtdat, ct_dir_t dir)\n",
        "{\n",
        "    struct dp_ct_dat *tdat = &atdat->ctd;\n",
        "    struct dp_ct_dat *xtdat = &axtdat->ctd;\n",
        "    ct_icmp_pinf_t *is = &tdat->pi.i;\n",
        "    ct_icmp_pinf_t *xis = &xtdat->pi.i;\n",
        "    void *dend = DP_TC_PTR (DP_PDATA_END (ctx));\n",
        "    struct icmp6hdr *i = DP_ADD_PTR (DP_PDATA (ctx), xf->pm.l4_off);\n",
        "    uint32_t nstate;\n",
        "    uint16_t seq;\n",
        "    if (i + 1 > dend) {\n",
        "        LLBS_PPLN_DROP (xf);\n",
        "        return -1;\n",
        "    }\n",
        "    seq = bpf_ntohs (i -> icmp6_dataun.u_echo.sequence);\n",
        "    bpf_spin_lock (&atdat->lock);\n",
        "    if (dir == CT_DIR_IN) {\n",
        "        tdat->pb.bytes += xf->pm.l3_len;\n",
        "        tdat->pb.packets += 1;\n",
        "    }\n",
        "    else {\n",
        "        xtdat->pb.bytes += xf->pm.l3_len;\n",
        "        xtdat->pb.packets += 1;\n",
        "    }\n",
        "    nstate = is->state;\n",
        "    switch (i->icmp6_type) {\n",
        "    case ICMPV6_DEST_UNREACH :\n",
        "        is->state |= CT_ICMP_DUNR;\n",
        "        goto end;\n",
        "    case ICMPV6_TIME_EXCEED :\n",
        "        is->state |= CT_ICMP_TTL;\n",
        "        goto end;\n",
        "    case ICMPV6_ECHO_REPLY :\n",
        "    case ICMPV6_ECHO_REQUEST :\n",
        "        break;\n",
        "    default :\n",
        "        is->state |= CT_ICMP_UNK;\n",
        "        goto end;\n",
        "    }\n",
        "    switch (is->state) {\n",
        "    case CT_ICMP_CLOSED :\n",
        "        if (xf->nm.dsr) {\n",
        "            nstate = CT_ICMP_REPS;\n",
        "            goto end;\n",
        "        }\n",
        "        if (i->icmp6_type != ICMPV6_ECHO_REQUEST) {\n",
        "            is->errs = 1;\n",
        "            goto end;\n",
        "        }\n",
        "        nstate = CT_ICMP_REQS;\n",
        "        is->lseq = seq;\n",
        "        break;\n",
        "    case CT_ICMP_REQS :\n",
        "        if (i->icmp6_type == ICMPV6_ECHO_REQUEST) {\n",
        "            is->lseq = seq;\n",
        "        }\n",
        "        else if (i->icmp6_type == ICMPV6_ECHO_REPLY) {\n",
        "            if (is->lseq != seq) {\n",
        "                is->errs = 1;\n",
        "                goto end;\n",
        "            }\n",
        "            nstate = CT_ICMP_REPS;\n",
        "            is->lseq = seq;\n",
        "        }\n",
        "        break;\n",
        "    case CT_ICMP_REPS :\n",
        "    default :\n",
        "        break;\n",
        "    }\n",
        "end :\n",
        "    is->state = nstate;\n",
        "    xis->state = nstate;\n",
        "    bpf_spin_unlock (&atdat->lock);\n",
        "    if (nstate == CT_ICMP_REPS)\n",
        "        return CT_SMR_EST;\n",
        "    return CT_SMR_INPROG;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_ct_icmp_sm": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 658,
      "endLine": 757,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_ct.c",
      "funcName": "dp_ct_icmp_sm",
      "developer_inline_comments": [
        {
          "start_line": 678,
          "end_line": 681,
          "text": " We fetch the sequence number even if icmp may not be   * echo type because we can't call another fn holding   * spinlock   "
        },
        {
          "start_line": 708,
          "end_line": 708,
          "text": " Further state-machine processing "
        },
        {
          "start_line": 742,
          "end_line": 742,
          "text": " Connection is tracked now "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf",
        " struct dp_ct_tact *atdat",
        " struct dp_ct_tact *axtdat",
        " ct_dir_t dir"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_spin_lock",
        "bpf_spin_unlock"
      ],
      "compatibleHookpoints": [
        "socket_filter",
        "sock_ops",
        "xdp",
        "sched_act",
        "sk_reuseport",
        "lwt_seg6local",
        "lwt_in",
        "sk_skb",
        "cgroup_skb",
        "lwt_xmit",
        "cgroup_sock",
        "lwt_out",
        "sched_cls",
        "flow_dissector",
        "sk_msg",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_ct_icmp_sm (void *ctx, struct xfi *xf, struct dp_ct_tact *atdat, struct dp_ct_tact *axtdat, ct_dir_t dir)\n",
        "{\n",
        "    struct dp_ct_dat *tdat = &atdat->ctd;\n",
        "    struct dp_ct_dat *xtdat = &axtdat->ctd;\n",
        "    ct_icmp_pinf_t *is = &tdat->pi.i;\n",
        "    ct_icmp_pinf_t *xis = &xtdat->pi.i;\n",
        "    void *dend = DP_TC_PTR (DP_PDATA_END (ctx));\n",
        "    struct icmphdr *i = DP_ADD_PTR (DP_PDATA (ctx), xf->pm.l4_off);\n",
        "    uint32_t nstate;\n",
        "    uint16_t seq;\n",
        "    if (i + 1 > dend) {\n",
        "        LLBS_PPLN_DROP (xf);\n",
        "        return -1;\n",
        "    }\n",
        "    seq = bpf_ntohs (i -> un.echo.sequence);\n",
        "    bpf_spin_lock (&atdat->lock);\n",
        "    if (dir == CT_DIR_IN) {\n",
        "        tdat->pb.bytes += xf->pm.l3_len;\n",
        "        tdat->pb.packets += 1;\n",
        "    }\n",
        "    else {\n",
        "        xtdat->pb.bytes += xf->pm.l3_len;\n",
        "        xtdat->pb.packets += 1;\n",
        "    }\n",
        "    nstate = is->state;\n",
        "    switch (i->type) {\n",
        "    case ICMP_DEST_UNREACH :\n",
        "        is->state |= CT_ICMP_DUNR;\n",
        "        goto end;\n",
        "    case ICMP_TIME_EXCEEDED :\n",
        "        is->state |= CT_ICMP_TTL;\n",
        "        goto end;\n",
        "    case ICMP_REDIRECT :\n",
        "        is->state |= CT_ICMP_RDR;\n",
        "        goto end;\n",
        "    case ICMP_ECHOREPLY :\n",
        "    case ICMP_ECHO :\n",
        "        break;\n",
        "    default :\n",
        "        is->state |= CT_ICMP_UNK;\n",
        "        goto end;\n",
        "    }\n",
        "    switch (is->state) {\n",
        "    case CT_ICMP_CLOSED :\n",
        "        if (xf->nm.dsr) {\n",
        "            nstate = CT_ICMP_REPS;\n",
        "            goto end;\n",
        "        }\n",
        "        if (i->type != ICMP_ECHO) {\n",
        "            is->errs = 1;\n",
        "            goto end;\n",
        "        }\n",
        "        nstate = CT_ICMP_REQS;\n",
        "        is->lseq = seq;\n",
        "        break;\n",
        "    case CT_ICMP_REQS :\n",
        "        if (i->type == ICMP_ECHO) {\n",
        "            is->lseq = seq;\n",
        "        }\n",
        "        else if (i->type == ICMP_ECHOREPLY) {\n",
        "            if (is->lseq != seq) {\n",
        "                is->errs = 1;\n",
        "                goto end;\n",
        "            }\n",
        "            nstate = CT_ICMP_REPS;\n",
        "            is->lseq = seq;\n",
        "        }\n",
        "        break;\n",
        "    case CT_ICMP_REPS :\n",
        "    default :\n",
        "        break;\n",
        "    }\n",
        "end :\n",
        "    is->state = nstate;\n",
        "    xis->state = nstate;\n",
        "    bpf_spin_unlock (&atdat->lock);\n",
        "    if (nstate == CT_ICMP_REPS)\n",
        "        return CT_SMR_EST;\n",
        "    return CT_SMR_INPROG;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_ct_sctp_sm": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 759,
      "endLine": 998,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_ct.c",
      "funcName": "dp_ct_sctp_sm",
      "developer_inline_comments": [
        {
          "start_line": 838,
          "end_line": 838,
          "text": "bpf_printk(\"IP 0x%x\", bpf_ntohl(*ip));"
        },
        {
          "start_line": 840,
          "end_line": 840,
          "text": " Checksum to be taken care of later stage "
        },
        {
          "start_line": 894,
          "end_line": 894,
          "text": "bpf_printk(\"ina ip 0x%x\", bpf_ntohl(*ip));"
        },
        {
          "start_line": 896,
          "end_line": 896,
          "text": " Checksum to be taken care of later stage "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf",
        " struct dp_ct_tact *atdat",
        " struct dp_ct_tact *axtdat",
        " ct_dir_t dir"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_spin_lock",
        "bpf_spin_unlock"
      ],
      "compatibleHookpoints": [
        "socket_filter",
        "sock_ops",
        "xdp",
        "sched_act",
        "sk_reuseport",
        "lwt_seg6local",
        "lwt_in",
        "sk_skb",
        "cgroup_skb",
        "lwt_xmit",
        "cgroup_sock",
        "lwt_out",
        "sched_cls",
        "flow_dissector",
        "sk_msg",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_ct_sctp_sm (void *ctx, struct xfi *xf, struct dp_ct_tact *atdat, struct dp_ct_tact *axtdat, ct_dir_t dir)\n",
        "{\n",
        "    struct dp_ct_dat *tdat = &atdat->ctd;\n",
        "    struct dp_ct_dat *xtdat = &axtdat->ctd;\n",
        "    ct_sctp_pinf_t *ss = &tdat->pi.s;\n",
        "    ct_sctp_pinf_t *xss = &xtdat->pi.s;\n",
        "    uint32_t nstate = 0;\n",
        "    uint16_t sz = 0;\n",
        "    void *dend = DP_TC_PTR (DP_PDATA_END (ctx));\n",
        "    struct sctphdr *s = DP_ADD_PTR (DP_PDATA (ctx), xf->pm.l4_off);\n",
        "    struct sctp_dch *c;\n",
        "    struct sctp_init_ch *ic;\n",
        "    struct sctp_cookie *ck;\n",
        "    struct sctp_param *pm;\n",
        "    int i = 0;\n",
        "    if (s + 1 > dend) {\n",
        "        LLBS_PPLN_DROP (xf);\n",
        "        return -1;\n",
        "    }\n",
        "    c = DP_TC_PTR (DP_ADD_PTR (s, sizeof (* s)));\n",
        "    if (c + 1 > dend) {\n",
        "        LLBS_PPLN_DROP (xf);\n",
        "        return -1;\n",
        "    }\n",
        "    nstate = ss->state;\n",
        "    bpf_spin_lock (&atdat->lock);\n",
        "    switch (c->type) {\n",
        "    case SCTP_ERROR :\n",
        "        nstate = CT_SCTP_ERR;\n",
        "        goto end;\n",
        "    case SCTP_SHUT :\n",
        "        nstate = CT_SCTP_SHUT;\n",
        "        goto end;\n",
        "    case SCTP_ABORT :\n",
        "        nstate = CT_SCTP_ABRT;\n",
        "        goto end;\n",
        "    }\n",
        "    switch (ss->state) {\n",
        "    case CT_SCTP_CLOSED :\n",
        "        if (xf->nm.dsr) {\n",
        "            nstate = CT_SCTP_EST;\n",
        "            goto end;\n",
        "        }\n",
        "        if (c->type != SCTP_INIT_CHUNK && dir != CT_DIR_IN) {\n",
        "            nstate = CT_SCTP_ERR;\n",
        "            goto end;\n",
        "        }\n",
        "        ic = DP_TC_PTR (DP_ADD_PTR (c, sizeof (* c)));\n",
        "        if (ic + 1 > dend) {\n",
        "            LLBS_PPLN_DROP (xf);\n",
        "            goto end;\n",
        "        }\n",
        "        ss->itag = ic->tag;\n",
        "        nstate = CT_SCTP_INIT;\n",
        "        pm = DP_TC_PTR (DP_ADD_PTR (ic, sizeof (* ic)));\n",
        "        if (pm + 1 > dend) {\n",
        "            break;\n",
        "        }\n",
        "        for (i = 0; i < SCTP_MAX_BIND_ADDRS; i++) {\n",
        "            if (pm->type == bpf_htons (SCTP_IPV4_ADDR_PARAM)) {\n",
        "                __be32 *ip = DP_TC_PTR (DP_ADD_PTR (pm, sizeof (*pm)));\n",
        "                if (ip + 1 > dend) {\n",
        "                    break;\n",
        "                }\n",
        "                if (atdat->nat_act.rip[0] != 0 && !atdat->nat_act.nv6) {\n",
        "                    *ip = atdat->nat_act.rip[0];\n",
        "                }\n",
        "            }\n",
        "            sz = bpf_ntohs (pm -> len);\n",
        "            if (sz >= 32) {\n",
        "                break;\n",
        "            }\n",
        "            pm = DP_TC_PTR (DP_ADD_PTR (pm, sz));\n",
        "            if (pm + 1 > dend) {\n",
        "                break;\n",
        "            }\n",
        "        }\n",
        "        break;\n",
        "    case CT_SCTP_INIT :\n",
        "        if ((c->type != SCTP_INIT_CHUNK && dir != CT_DIR_IN) && (c->type != SCTP_INIT_CHUNK_ACK && dir != CT_DIR_OUT)) {\n",
        "            nstate = CT_SCTP_ERR;\n",
        "            goto end;\n",
        "        }\n",
        "        ic = DP_TC_PTR (DP_ADD_PTR (c, sizeof (* c)));\n",
        "        if (ic + 1 > dend) {\n",
        "            LLBS_PPLN_DROP (xf);\n",
        "            goto end;\n",
        "        }\n",
        "        if (c->type == SCTP_INIT_CHUNK) {\n",
        "            ss->itag = ic->tag;\n",
        "            ss->otag = 0;\n",
        "            nstate = CT_SCTP_INIT;\n",
        "        }\n",
        "        else {\n",
        "            if (s->vtag != ss->itag) {\n",
        "                nstate = CT_SCTP_ERR;\n",
        "                goto end;\n",
        "            }\n",
        "            ss->otag = ic->tag;\n",
        "            nstate = CT_SCTP_INITA;\n",
        "        }\n",
        "        pm = DP_TC_PTR (DP_ADD_PTR (ic, sizeof (* ic)));\n",
        "        if (pm + 1 > dend) {\n",
        "            break;\n",
        "        }\n",
        "        for (i = 0; i < SCTP_MAX_BIND_ADDRS; i++) {\n",
        "            if (pm->type == bpf_htons (SCTP_IPV4_ADDR_PARAM)) {\n",
        "                __be32 *ip = DP_TC_PTR (DP_ADD_PTR (pm, sizeof (*pm)));\n",
        "                if (ip + 1 > dend) {\n",
        "                    break;\n",
        "                }\n",
        "                if (axtdat->nat_act.xip[0] != 0 && !axtdat->nat_act.nv6) {\n",
        "                    *ip = axtdat->nat_act.xip[0];\n",
        "                }\n",
        "            }\n",
        "            sz = bpf_ntohs (pm -> len);\n",
        "            if (sz >= 32) {\n",
        "                break;\n",
        "            }\n",
        "            pm = DP_TC_PTR (DP_ADD_PTR (pm, sz));\n",
        "            if (pm + 1 > dend) {\n",
        "                break;\n",
        "            }\n",
        "        }\n",
        "        break;\n",
        "    case CT_SCTP_INITA :\n",
        "        if ((c->type != SCTP_INIT_CHUNK && dir != CT_DIR_IN) && (c->type != SCTP_COOKIE_ECHO && dir != CT_DIR_IN)) {\n",
        "            nstate = CT_SCTP_ERR;\n",
        "            goto end;\n",
        "        }\n",
        "        if (c->type == SCTP_INIT_CHUNK) {\n",
        "            ic = DP_TC_PTR (DP_ADD_PTR (c, sizeof (* c)));\n",
        "            if (ic + 1 > dend) {\n",
        "                LLBS_PPLN_DROP (xf);\n",
        "                goto end;\n",
        "            }\n",
        "            ss->itag = ic->tag;\n",
        "            ss->otag = 0;\n",
        "            nstate = CT_SCTP_INIT;\n",
        "            goto end;\n",
        "        }\n",
        "        ck = DP_TC_PTR (DP_ADD_PTR (c, sizeof (* c)));\n",
        "        if (ck + 1 > dend) {\n",
        "            LLBS_PPLN_DROP (xf);\n",
        "            goto end;\n",
        "        }\n",
        "        if (ss->otag != s->vtag) {\n",
        "            nstate = CT_SCTP_ERR;\n",
        "            goto end;\n",
        "        }\n",
        "        ss->cookie = ck->cookie;\n",
        "        nstate = CT_SCTP_COOKIE;\n",
        "        break;\n",
        "    case CT_SCTP_COOKIE :\n",
        "        if (c->type != SCTP_COOKIE_ACK && dir != CT_DIR_OUT) {\n",
        "            nstate = CT_SCTP_ERR;\n",
        "            goto end;\n",
        "        }\n",
        "        if (ss->itag != s->vtag) {\n",
        "            nstate = CT_SCTP_ERR;\n",
        "            goto end;\n",
        "        }\n",
        "        nstate = CT_SCTP_COOKIEA;\n",
        "        break;\n",
        "    case CT_SCTP_COOKIEA :\n",
        "        nstate = CT_SCTP_EST;\n",
        "        break;\n",
        "    case CT_SCTP_ABRT :\n",
        "        nstate = CT_SCTP_ABRT;\n",
        "        break;\n",
        "    case CT_SCTP_SHUT :\n",
        "        if (c->type != SCTP_SHUT_ACK && dir != CT_DIR_OUT) {\n",
        "            nstate = CT_SCTP_ERR;\n",
        "            goto end;\n",
        "        }\n",
        "        nstate = CT_SCTP_SHUTA;\n",
        "        break;\n",
        "    case CT_SCTP_SHUTA :\n",
        "        if (c->type != SCTP_SHUT_COMPLETE && dir != CT_DIR_IN) {\n",
        "            nstate = CT_SCTP_ERR;\n",
        "            goto end;\n",
        "        }\n",
        "        nstate = CT_SCTP_SHUTC;\n",
        "        break;\n",
        "    default :\n",
        "        break;\n",
        "    }\n",
        "end :\n",
        "    ss->state = nstate;\n",
        "    xss->state = nstate;\n",
        "    bpf_spin_unlock (&atdat->lock);\n",
        "    if (nstate == CT_SCTP_COOKIEA) {\n",
        "        return CT_SMR_EST;\n",
        "    }\n",
        "    else if (nstate & CT_SCTP_SHUTC) {\n",
        "        return CT_SMR_CTD;\n",
        "    }\n",
        "    else if (nstate & CT_SCTP_ERR) {\n",
        "        return CT_SMR_ERR;\n",
        "    }\n",
        "    else if (nstate & CT_SCTP_FIN_MASK) {\n",
        "        return CT_SMR_FIN;\n",
        "    }\n",
        "    return CT_SMR_INPROG;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_ct_sm": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1000,
      "endLine": 1037,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_ct.c",
      "funcName": "dp_ct_sm",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf",
        " struct dp_ct_tact *atdat",
        " struct dp_ct_tact *axtdat",
        " ct_dir_t dir"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_ct_sm (void *ctx, struct xfi *xf, struct dp_ct_tact *atdat, struct dp_ct_tact *axtdat, ct_dir_t dir)\n",
        "{\n",
        "    int sm_ret = 0;\n",
        "    if (xf->pm.l4_off == 0) {\n",
        "        atdat->ctd.pi.frag = 1;\n",
        "        return CT_SMR_UNT;\n",
        "    }\n",
        "    atdat->ctd.pi.frag = 0;\n",
        "    switch (xf->l34m.nw_proto) {\n",
        "    case IPPROTO_TCP :\n",
        "        sm_ret = dp_ct_tcp_sm (ctx, xf, atdat, axtdat, dir);\n",
        "        break;\n",
        "    case IPPROTO_UDP :\n",
        "        sm_ret = dp_ct_udp_sm (ctx, xf, atdat, axtdat, dir);\n",
        "        break;\n",
        "    case IPPROTO_ICMP :\n",
        "        sm_ret = dp_ct_icmp_sm (ctx, xf, atdat, axtdat, dir);\n",
        "        break;\n",
        "    case IPPROTO_SCTP :\n",
        "        sm_ret = dp_ct_sctp_sm (ctx, xf, atdat, axtdat, dir);\n",
        "        break;\n",
        "    case IPPROTO_ICMPV6 :\n",
        "        sm_ret = dp_ct_icmp6_sm (ctx, xf, atdat, axtdat, dir);\n",
        "        break;\n",
        "    default :\n",
        "        sm_ret = CT_SMR_UNT;\n",
        "        break;\n",
        "    }\n",
        "    return sm_ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_ct_udp_sm",
        "dp_ct_tcp_sm",
        "dp_ct_icmp6_sm",
        "dp_ct_sctp_sm",
        "dp_ct_icmp_sm"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_ct_in": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        },
        {
          "capability": "read_sys_info",
          "read_sys_info": [
            {
              "Project": "bcc",
              "FunctionName": "bpf_ktime_get_ns",
              "Return Type": "u64",
              "Description": "u64 bpf_ktime_get_ns(void) Return: u64 number of nanoseconds. Starts at system boot time but stops during suspend. Examples in situ: \"https://github.com/iovisor/bcc/search?q=bpf_ktime_get_ns+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=bpf_ktime_get_ns+path%3Atools&type=Code search /tools ",
              "Return": "u64 number of nanoseconds",
              "Input Prameters": [],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            }
          ]
        },
        {
          "capability": "map_update",
          "map_update": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_map_update_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}",
                "{Type:  const void ,Var: *value}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_update"
              ]
            },
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Delete entry with <[ key ]>(IP: 1) from map. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_map_delete_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_update"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1046,
      "endLine": 1212,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_ct.c",
      "funcName": "dp_ct_in",
      "developer_inline_comments": [
        {
          "start_line": 1074,
          "end_line": 1074,
          "text": " CT Key "
        },
        {
          "start_line": 1144,
          "end_line": 1144,
          "text": " FIXME This is duplicated data "
        }
      ],
      "updateMaps": [
        " ct_map"
      ],
      "readMaps": [
        "  ct_map",
        "  xctk"
      ],
      "input": [
        "void *ctx",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_map_lookup_elem",
        "bpf_ktime_get_ns",
        "bpf_map_update_elem",
        "bpf_map_delete_elem"
      ],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "lwt_xmit",
        "cgroup_sock",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "perf_event",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_ct_in (void *ctx, struct xfi *xf)\n",
        "{\n",
        "    struct dp_ct_key key;\n",
        "    struct dp_ct_key xkey;\n",
        "    struct dp_ct_tact *adat;\n",
        "    struct dp_ct_tact *axdat;\n",
        "    struct dp_ct_tact *atdat;\n",
        "    struct dp_ct_tact *axtdat;\n",
        "    nxfrm_inf_t *xi;\n",
        "    nxfrm_inf_t *xxi;\n",
        "    ct_dir_t cdir = CT_DIR_IN;\n",
        "    int smr = CT_SMR_ERR;\n",
        "    int k;\n",
        "    k = 0;\n",
        "    adat = bpf_map_lookup_elem (& xctk, & k);\n",
        "    k = 1;\n",
        "    axdat = bpf_map_lookup_elem (& xctk, & k);\n",
        "    if (adat == NULL || axdat == NULL) {\n",
        "        return smr;\n",
        "    }\n",
        "    xi = &adat->ctd.xi;\n",
        "    xxi = &axdat->ctd.xi;\n",
        "    DP_XADDR_CP (key.daddr, xf->l34m.daddr);\n",
        "    DP_XADDR_CP (key.saddr, xf->l34m.saddr);\n",
        "    key.sport = xf->l34m.source;\n",
        "    key.dport = xf->l34m.dest;\n",
        "    key.l4proto = xf->l34m.nw_proto;\n",
        "    key.zone = xf->pm.zone;\n",
        "    key.v6 = xf->l2m.dl_type == bpf_ntohs (ETH_P_IPV6) ? 1 : 0;\n",
        "    if (key.l4proto != IPPROTO_TCP && key.l4proto != IPPROTO_UDP && key.l4proto != IPPROTO_ICMP && key.l4proto != IPPROTO_SCTP && key.l4proto != IPPROTO_ICMPV6) {\n",
        "        return 0;\n",
        "    }\n",
        "    xi->nat_flags = xf->pm.nf;\n",
        "    DP_XADDR_CP (xi->nat_xip, xf->nm.nxip);\n",
        "    DP_XADDR_CP (xi->nat_rip, xf->nm.nrip);\n",
        "    xi->nat_xport = xf->nm.nxport;\n",
        "    xi->nv6 = xf->nm.nv6;\n",
        "    xi->dsr = xf->nm.dsr;\n",
        "    xxi->nat_flags = 0;\n",
        "    xxi->nat_xport = 0;\n",
        "    DP_XADDR_SETZR (xxi->nat_xip);\n",
        "    DP_XADDR_SETZR (xxi->nat_rip);\n",
        "    if (xf->pm.nf & (LLB_NAT_DST | LLB_NAT_SRC)) {\n",
        "        if (DP_XADDR_ISZR (xi->nat_xip)) {\n",
        "            if (xf->pm.nf == LLB_NAT_DST) {\n",
        "                xi->nat_flags = LLB_NAT_HDST;\n",
        "            }\n",
        "            else if (xf->pm.nf == LLB_NAT_SRC) {\n",
        "                xi->nat_flags = LLB_NAT_HSRC;\n",
        "            }\n",
        "        }\n",
        "    }\n",
        "    dp_ct_proto_xfk_init (&key, xi, &xkey, xxi);\n",
        "    atdat = bpf_map_lookup_elem (& ct_map, & key);\n",
        "    axtdat = bpf_map_lookup_elem (& ct_map, & xkey);\n",
        "    if (atdat == NULL || axtdat == NULL) {\n",
        "        LL_DBG_PRINTK (\"[CTRK] new-ct4\");\n",
        "        adat->ca.ftrap = 0;\n",
        "        adat->ca.oaux = 0;\n",
        "        adat->ca.cidx = dp_ct_get_newctr ();\n",
        "        adat->ca.fwrid = xf->pm.fw_rid;\n",
        "        adat->ca.record = xf->pm.dp_rec;\n",
        "        memset (&adat->ctd.pi, 0, sizeof (ct_pinf_t));\n",
        "        if (xi->nat_flags) {\n",
        "            adat->ca.act_type = xi->nat_flags & (LLB_NAT_DST | LLB_NAT_HDST) ? DP_SET_DNAT : DP_SET_SNAT;\n",
        "            DP_XADDR_CP (adat->nat_act.xip, xi->nat_xip);\n",
        "            DP_XADDR_CP (adat->nat_act.rip, xi->nat_rip);\n",
        "            adat->nat_act.xport = xi->nat_xport;\n",
        "            adat->nat_act.doct = 1;\n",
        "            adat->nat_act.rid = xf->pm.rule_id;\n",
        "            adat->nat_act.aid = xf->nm.sel_aid;\n",
        "            adat->nat_act.nv6 = xf->nm.nv6 ? 1 : 0;\n",
        "            adat->nat_act.dsr = xf->nm.dsr;\n",
        "            adat->ito = xf->nm.ito;\n",
        "        }\n",
        "        else {\n",
        "            adat->ito = 0;\n",
        "            adat->ca.act_type = DP_SET_DO_CT;\n",
        "        }\n",
        "        adat->ctd.dir = cdir;\n",
        "        adat->ctd.rid = xf->pm.rule_id;\n",
        "        adat->ctd.aid = xf->nm.sel_aid;\n",
        "        adat->ctd.smr = CT_SMR_INIT;\n",
        "        axdat->ca.ftrap = 0;\n",
        "        axdat->ca.oaux = 0;\n",
        "        axdat->ca.cidx = adat->ca.cidx + 1;\n",
        "        axdat->ca.fwrid = xf->pm.fw_rid;\n",
        "        axdat->ca.record = xf->pm.dp_rec;\n",
        "        memset (&axdat->ctd.pi, 0, sizeof (ct_pinf_t));\n",
        "        if (xxi->nat_flags) {\n",
        "            axdat->ca.act_type = xxi->nat_flags & (LLB_NAT_DST | LLB_NAT_HDST) ? DP_SET_DNAT : DP_SET_SNAT;\n",
        "            DP_XADDR_CP (axdat->nat_act.xip, xxi->nat_xip);\n",
        "            DP_XADDR_CP (axdat->nat_act.rip, xxi->nat_rip);\n",
        "            axdat->nat_act.xport = xxi->nat_xport;\n",
        "            axdat->nat_act.doct = 1;\n",
        "            axdat->nat_act.rid = xf->pm.rule_id;\n",
        "            axdat->nat_act.aid = xf->nm.sel_aid;\n",
        "            axdat->nat_act.nv6 = key.v6 ? 1 : 0;\n",
        "            axdat->nat_act.dsr = xf->nm.dsr;\n",
        "            axdat->ito = xf->nm.ito;\n",
        "        }\n",
        "        else {\n",
        "            axdat->ito = 0;\n",
        "            axdat->ca.act_type = DP_SET_DO_CT;\n",
        "        }\n",
        "        axdat->lts = adat->lts;\n",
        "        axdat->ctd.dir = CT_DIR_OUT;\n",
        "        axdat->ctd.smr = CT_SMR_INIT;\n",
        "        axdat->ctd.rid = adat->ctd.rid;\n",
        "        axdat->ctd.aid = adat->ctd.aid;\n",
        "        bpf_map_update_elem (&ct_map, &xkey, axdat, BPF_ANY);\n",
        "        bpf_map_update_elem (&ct_map, &key, adat, BPF_ANY);\n",
        "        atdat = bpf_map_lookup_elem (& ct_map, & key);\n",
        "        axtdat = bpf_map_lookup_elem (& ct_map, & xkey);\n",
        "    }\n",
        "    if (atdat != NULL && axtdat != NULL) {\n",
        "        atdat->lts = bpf_ktime_get_ns ();\n",
        "        axtdat->lts = atdat->lts;\n",
        "        if (atdat->ctd.dir == CT_DIR_IN) {\n",
        "            LL_DBG_PRINTK (\"[CTRK] in-dir\");\n",
        "            smr = dp_ct_sm (ctx, xf, atdat, axtdat, CT_DIR_IN);\n",
        "        }\n",
        "        else {\n",
        "            LL_DBG_PRINTK (\"[CTRK] out-dir\");\n",
        "            smr = dp_ct_sm (ctx, xf, axtdat, atdat, CT_DIR_OUT);\n",
        "        }\n",
        "        LL_DBG_PRINTK (\"[CTRK] smr %d\", smr);\n",
        "        if (smr == CT_SMR_EST) {\n",
        "            if (xi->nat_flags) {\n",
        "                atdat->nat_act.doct = 0;\n",
        "                axtdat->nat_act.doct = 0;\n",
        "            }\n",
        "            else {\n",
        "                atdat->ca.act_type = DP_SET_NOP;\n",
        "                axtdat->ca.act_type = DP_SET_NOP;\n",
        "            }\n",
        "        }\n",
        "        else if (smr == CT_SMR_ERR || smr == CT_SMR_CTD) {\n",
        "            bpf_map_delete_elem (&ct_map, &xkey);\n",
        "            bpf_map_delete_elem (&ct_map, &key);\n",
        "        }\n",
        "    }\n",
        "    return smr;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_ct_get_newctr",
        "dp_ct_proto_xfk_init",
        "dp_ct_sm"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_do_fcv4_ct_helper": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 8,
      "endLine": 37,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_fcfwd.c",
      "funcName": "dp_do_fcv4_ct_helper",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 6,
          "text": " *  llb_kern_fc.c: LoxiLB kernel cache based forwarding *  Copyright (C) 2022,  NetLOX <www.netlox.io> *  * SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause) "
        },
        {
          "start_line": 22,
          "end_line": 24,
          "text": " We dont do much strict tracking after EST state.   * But need to maintain certain ct info   "
        }
      ],
      "updateMaps": [],
      "readMaps": [
        "  ct_map"
      ],
      "input": [
        "struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_do_fcv4_ct_helper (struct xfi *xf)\n",
        "{\n",
        "    struct dp_ct_key key;\n",
        "    struct dp_ct_tact *act;\n",
        "    CT_KEY_GEN (&key, xf);\n",
        "    act = bpf_map_lookup_elem (& ct_map, & key);\n",
        "    if (!act) {\n",
        "        LL_DBG_PRINTK (\"[FCH4] miss\");\n",
        "        return -1;\n",
        "    }\n",
        "    switch (act->ca.act_type) {\n",
        "    case DP_SET_NOP :\n",
        "    case DP_SET_SNAT :\n",
        "    case DP_SET_DNAT :\n",
        "        act->ctd.pi.t.tcp_cts[CT_DIR_IN].pseq = xf->l34m.seq;\n",
        "        act->ctd.pi.t.tcp_cts[CT_DIR_IN].pack = xf->l34m.ack;\n",
        "        break;\n",
        "    default :\n",
        "        break;\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ],
  "dp_mk_fcv4_key": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 39,
      "endLine": 67,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_fcfwd.c",
      "funcName": "dp_mk_fcv4_key",
      "developer_inline_comments": [
        {
          "start_line": 47,
          "end_line": 47,
          "text": "key->bd = xf->pm.bd;"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct xfi *xf",
        " struct dp_fcv4_key *key"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_mk_fcv4_key (struct xfi *xf, struct dp_fcv4_key *key)\n",
        "{\n",
        "\n",
        "#ifdef HAVE_DP_EXTFC\n",
        "    memcpy (key->smac, xf->l2m.dl_src, 6);\n",
        "    memcpy (key->dmac, xf->l2m.dl_dst, 6);\n",
        "    memcpy (key->in_smac, xf->il2m.dl_src, 6);\n",
        "    memcpy (key->in_dmac, xf->il2m.dl_dst, 6);\n",
        "\n",
        "#endif\n",
        "    key->daddr = xf->l34m.daddr4;\n",
        "    key->saddr = xf->l34m.saddr4;\n",
        "    key->sport = xf->l34m.source;\n",
        "    key->dport = xf->l34m.dest;\n",
        "    key->l4proto = xf->l34m.nw_proto;\n",
        "    key->pad = 0;\n",
        "    key->in_port = 0;\n",
        "\n",
        "#ifdef HAVE_DP_EXTFC\n",
        "    key->in_daddr = xf->il34m.daddr4;\n",
        "    key->in_saddr = xf->il34m.saddr4;\n",
        "    key->in_sport = xf->il34m.source;\n",
        "    key->in_dport = xf->il34m.dest;\n",
        "    key->in_l4proto = xf->il34m.nw_proto;\n",
        "\n",
        "#endif\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_do_fcv4_lkup": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        },
        {
          "capability": "read_sys_info",
          "read_sys_info": [
            {
              "Project": "bcc",
              "FunctionName": "bpf_ktime_get_ns",
              "Return Type": "u64",
              "Description": "u64 bpf_ktime_get_ns(void) Return: u64 number of nanoseconds. Starts at system boot time but stops during suspend. Examples in situ: \"https://github.com/iovisor/bcc/search?q=bpf_ktime_get_ns+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=bpf_ktime_get_ns+path%3Atools&type=Code search /tools ",
              "Return": "u64 number of nanoseconds",
              "Input Prameters": [],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            }
          ]
        },
        {
          "capability": "map_update",
          "map_update": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_map_update_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}",
                "{Type:  const void ,Var: *value}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_update"
              ]
            },
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Delete entry with <[ key ]>(IP: 1) from map. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_map_delete_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_update"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 69,
      "endLine": 216,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_fcfwd.c",
      "funcName": "dp_do_fcv4_lkup",
      "developer_inline_comments": [
        {
          "start_line": 96,
          "end_line": 99,
          "text": " xfck - fcache key table is maintained so that      * there is no need to make fcv4 key again in     * tail-call sections     "
        },
        {
          "start_line": 104,
          "end_line": 104,
          "text": " Check timeout "
        },
        {
          "start_line": 191,
          "end_line": 191,
          "text": " Catch any conditions which need us to go to cp/ct "
        },
        {
          "start_line": 209,
          "end_line": 209,
          "text": " Field overloaded as oif "
        }
      ],
      "updateMaps": [
        " fc_v4_map",
        " xfck"
      ],
      "readMaps": [
        "  fc_v4_map"
      ],
      "input": [
        "void *ctx",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_map_lookup_elem",
        "bpf_ktime_get_ns",
        "bpf_map_update_elem",
        "bpf_map_delete_elem"
      ],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "lwt_xmit",
        "cgroup_sock",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "perf_event",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_do_fcv4_lkup (void *ctx, struct xfi *xf)\n",
        "{\n",
        "    struct dp_fcv4_key key;\n",
        "    struct dp_fc_tacts *acts;\n",
        "    struct dp_fc_tact *ta;\n",
        "    int ret = 1;\n",
        "    int z = 0;\n",
        "    dp_mk_fcv4_key (xf, &key);\n",
        "    LL_FC_PRINTK (\"[FCH4] -- Lookup\\n\");\n",
        "    LL_FC_PRINTK (\"[FCH4] key-sz %d\\n\", sizeof (key));\n",
        "    LL_FC_PRINTK (\"[FCH4] daddr %x\\n\", key.daddr);\n",
        "    LL_FC_PRINTK (\"[FCH4] saddr %x\\n\", key.saddr);\n",
        "    LL_FC_PRINTK (\"[FCH4] sport %x\\n\", key.sport);\n",
        "    LL_FC_PRINTK (\"[FCH4] dport %x\\n\", key.dport);\n",
        "    LL_FC_PRINTK (\"[FCH4] l4proto %x\\n\", key.l4proto);\n",
        "    LL_FC_PRINTK (\"[FCH4] idaddr %x\\n\", key.in_daddr);\n",
        "    LL_FC_PRINTK (\"[FCH4] isaddr %x\\n\", key.in_saddr);\n",
        "    LL_FC_PRINTK (\"[FCH4] isport %x\\n\", key.in_sport);\n",
        "    LL_FC_PRINTK (\"[FCH4] idport %x\\n\", key.in_dport);\n",
        "    LL_FC_PRINTK (\"[FCH4] il4proto %x\\n\", key.in_l4proto);\n",
        "    xf->pm.table_id = LL_DP_FCV4_MAP;\n",
        "    acts = bpf_map_lookup_elem (& fc_v4_map, & key);\n",
        "    if (!acts) {\n",
        "        bpf_map_update_elem (&xfck, &z, &key, BPF_ANY);\n",
        "        return 0;\n",
        "    }\n",
        "    if (bpf_ktime_get_ns () - acts->its > FC_V4_DPTO) {\n",
        "        LL_FC_PRINTK (\"[FCH4] hto\");\n",
        "        bpf_map_update_elem (&xfck, &z, &key, BPF_ANY);\n",
        "        bpf_map_delete_elem (&fc_v4_map, &key);\n",
        "        return 0;\n",
        "    }\n",
        "    LL_FC_PRINTK (\"[FCH4] key found act-sz %d\\n\", sizeof (struct dp_fc_tacts));\n",
        "    if (acts->ca.ftrap)\n",
        "        return 0;\n",
        "    xf->pm.phit |= LLB_DP_FC_HIT;\n",
        "    xf->pm.zone = acts->zone;\n",
        "\n",
        "#ifdef HAVE_DP_EXTFC\n",
        "    if (acts->fcta[DP_SET_RM_VXLAN].ca.act_type == DP_SET_RM_VXLAN) {\n",
        "        LL_FC_PRINTK (\"[FCH4] strip-vxlan-act\\n\");\n",
        "        ta = &acts->fcta[DP_SET_RM_VXLAN];\n",
        "        dp_pipe_set_rm_vx_tun (ctx, xf, &ta->nh_act);\n",
        "    }\n",
        "\n",
        "#endif\n",
        "    if (acts->fcta[DP_SET_SNAT].ca.act_type == DP_SET_SNAT) {\n",
        "        LL_FC_PRINTK (\"[FCH4] snat-act\\n\");\n",
        "        ta = &acts->fcta[DP_SET_SNAT];\n",
        "        if (ta->nat_act.fr == 1 || ta->nat_act.doct) {\n",
        "            return 0;\n",
        "        }\n",
        "        dp_pipe_set_nat (ctx, xf, &ta->nat_act, 1);\n",
        "        dp_do_map_stats (ctx, xf, LL_DP_NAT_STATS_MAP, ta->nat_act.rid);\n",
        "    }\n",
        "    else if (acts->fcta[DP_SET_DNAT].ca.act_type == DP_SET_DNAT) {\n",
        "        LL_FC_PRINTK (\"[FCH4] dnat-act\\n\");\n",
        "        ta = &acts->fcta[DP_SET_DNAT];\n",
        "        if (ta->nat_act.fr == 1 || ta->nat_act.doct) {\n",
        "            return 0;\n",
        "        }\n",
        "        dp_pipe_set_nat (ctx, xf, &ta->nat_act, 0);\n",
        "        dp_do_map_stats (ctx, xf, LL_DP_NAT_STATS_MAP, ta->nat_act.rid);\n",
        "    }\n",
        "\n",
        "#ifdef HAVE_DP_EXTFC\n",
        "    if (acts->fcta[DP_SET_RT_TUN_NH].ca.act_type == DP_SET_RT_TUN_NH) {\n",
        "        ta = &acts->fcta[DP_SET_RT_TUN_NH];\n",
        "        LL_FC_PRINTK (\"[FCH4] tun-nh found\\n\");\n",
        "        dp_pipe_set_l22_tun_nh (ctx, xf, &ta->nh_act);\n",
        "    }\n",
        "    else if (acts->fcta[DP_SET_L3RT_TUN_NH].ca.act_type == DP_SET_L3RT_TUN_NH) {\n",
        "        LL_FC_PRINTK (\"[FCH4] l3-rt-tnh-act\\n\");\n",
        "        ta = &acts->fcta[DP_SET_L3RT_TUN_NH];\n",
        "        dp_pipe_set_l32_tun_nh (ctx, xf, &ta->nh_act);\n",
        "    }\n",
        "\n",
        "#endif\n",
        "    if (acts->fcta[DP_SET_NEIGH_L2].ca.act_type == DP_SET_NEIGH_L2) {\n",
        "        LL_FC_PRINTK (\"[FCH4] l2-rt-nh-act\\n\");\n",
        "        ta = &acts->fcta[DP_SET_NEIGH_L2];\n",
        "        dp_do_rt_l2_nh (ctx, xf, &ta->nl2);\n",
        "    }\n",
        "\n",
        "#ifdef HAVE_DP_EXTFC\n",
        "    if (acts->fcta[DP_SET_NEIGH_VXLAN].ca.act_type == DP_SET_NEIGH_VXLAN) {\n",
        "        LL_FC_PRINTK (\"[FCH4] rt-l2-nh-vxlan-act\\n\");\n",
        "        ta = &acts->fcta[DP_SET_NEIGH_VXLAN];\n",
        "        dp_do_rt_tun_nh (ctx, xf, LLB_TUN_VXLAN, &ta->ntun);\n",
        "    }\n",
        "\n",
        "#endif\n",
        "    if (acts->fcta[DP_SET_ADD_L2VLAN].ca.act_type == DP_SET_ADD_L2VLAN) {\n",
        "        LL_FC_PRINTK (\"[FCH4] new-l2-vlan-act\\n\");\n",
        "        ta = &acts->fcta[DP_SET_ADD_L2VLAN];\n",
        "        dp_set_egr_vlan (ctx, xf, ta->l2ov.vlan, ta->l2ov.oport);\n",
        "    }\n",
        "    else if (acts->fcta[DP_SET_RM_L2VLAN].ca.act_type == DP_SET_RM_L2VLAN) {\n",
        "        LL_FC_PRINTK (\"[FCH4] strip-l2-vlan-act\\n\");\n",
        "        ta = &acts->fcta[DP_SET_RM_L2VLAN];\n",
        "        dp_set_egr_vlan (ctx, xf, 0, ta->l2ov.oport);\n",
        "    }\n",
        "    else {\n",
        "        goto del_out;\n",
        "    }\n",
        "    if (xf->pm.l4fin) {\n",
        "        acts->ca.ftrap = 1;\n",
        "        goto del_out;\n",
        "    }\n",
        "    DP_RUN_CT_HELPER (xf);\n",
        "    if (acts->ca.fwrid != 0) {\n",
        "        dp_do_map_stats (ctx, xf, LL_DP_FW4_STATS_MAP, acts->ca.fwrid);\n",
        "    }\n",
        "    dp_do_map_stats (ctx, xf, LL_DP_CT_STATS_MAP, acts->ca.cidx);\n",
        "    LL_FC_PRINTK (\"[FCH4] oport %d\\n\", xf->pm.oport);\n",
        "    dp_unparse_packet_always (ctx, xf);\n",
        "    dp_unparse_packet (ctx, xf);\n",
        "    xf->pm.oport = acts->ca.oaux;\n",
        "    return ret;\n",
        "del_out :\n",
        "    bpf_map_delete_elem (&fc_v4_map, &key);\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_do_rt_l2_nh",
        "dp_mk_fcv4_key",
        "dp_pipe_set_l22_tun_nh",
        "dp_pipe_set_l32_tun_nh",
        "dp_unparse_packet",
        "dp_do_map_stats",
        "dp_pipe_set_nat",
        "dp_do_rt_tun_nh",
        "dp_set_egr_vlan",
        "dp_unparse_packet_always",
        "dp_pipe_set_rm_vx_tun"
      ],
      "call_depth": 5,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_ing_fc_main": [
    {
      "capabilities": [
        {
          "capability": "map_update",
          "map_update": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_map_update_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}",
                "{Type:  const void ,Var: *value}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_update"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 218,
      "endLine": 240,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_fcfwd.c",
      "funcName": "dp_ing_fc_main",
      "developer_inline_comments": [],
      "updateMaps": [
        " xfis"
      ],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_tail_call",
        "bpf_redirect",
        "bpf_map_update_elem"
      ],
      "compatibleHookpoints": [
        "lwt_xmit",
        "sched_cls",
        "xdp",
        "sched_act"
      ],
      "source": [
        "static int __always_inline dp_ing_fc_main (void *ctx, struct xfi *xf)\n",
        "{\n",
        "    int z = 0;\n",
        "    __u32 idx = LLB_DP_PKT_SLOW_PGM_ID;\n",
        "    LL_FC_PRINTK (\"[FCHM] Main--\\n\");\n",
        "    if (xf->pm.pipe_act == 0 && xf->l2m.dl_type == bpf_ntohs (ETH_P_IP)) {\n",
        "        if (dp_do_fcv4_lkup (ctx, xf) == 1) {\n",
        "            if (xf->pm.pipe_act == LLB_PIPE_RDR) {\n",
        "                int oif = xf->pm.oport;\n",
        "\n",
        "#ifdef HAVE_DP_EGR_HOOK\n",
        "                DP_LLB_MRK_INGP (ctx);\n",
        "\n",
        "#endif\n",
        "                return bpf_redirect (oif, 0);\n",
        "            }\n",
        "        }\n",
        "    }\n",
        "    bpf_map_update_elem (&xfis, &z, xf, BPF_ANY);\n",
        "    bpf_tail_call (ctx, &pgm_tbl, idx);\n",
        "    return DP_PASS;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_do_fcv4_lkup"
      ],
      "call_depth": 6,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "main": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 6,
      "endLine": 9,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp_main.c",
      "funcName": "main",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": " SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause) "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "NA"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "int main ()\n",
        "{\n",
        "    return loxilb_main (NULL);\n",
        "}\n"
      ],
      "called_function_list": [
        "loxilb_main"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ],
  "dp_ing_pkt_main": [
    {
      "capabilities": [
        {
          "capability": "read_sys_info",
          "read_sys_info": [
            {
              "Project": "libbpf",
              "Return Type": "u32",
              "Description": "Get the SMP (symmetric multiprocessing) processor id. Note that all programs run with preemption disabled , which means that the SMP processor id is stable during all the execution of the program. ",
              "Return": " The SMP id of the processor running the program.",
              "Function Name": "bpf_get_smp_processor_id",
              "Input Params": [
                "{Type: voi ,Var: void}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 31,
      "endLine": 59,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_entry.c",
      "funcName": "dp_ing_pkt_main",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 6,
          "text": " *  llb_kern_entry.c: LoxiLB Kernel eBPF entry points *  Copyright (C) 2022,  NetLOX <www.netlox.io> *  * SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause) "
        },
        {
          "start_line": 46,
          "end_line": 46,
          "text": " Handle parser results "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *md",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_get_smp_processor_id"
      ],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_ing_pkt_main (void *md, struct xfi *xf)\n",
        "{\n",
        "    LL_DBG_PRINTK (\"[PRSR] START cpu %d \\n\", bpf_get_smp_processor_id ());\n",
        "    LL_DBG_PRINTK (\"[PRSR] fi  %d\\n\", sizeof (*xf));\n",
        "    LL_DBG_PRINTK (\"[PRSR] fm  %d\\n\", sizeof (xf->fm));\n",
        "    LL_DBG_PRINTK (\"[PRSR] l2m %d\\n\", sizeof (xf->l2m));\n",
        "    LL_DBG_PRINTK (\"[PRSR] l34m %d\\n\", sizeof (xf->l34m));\n",
        "    LL_DBG_PRINTK (\"[PRSR] tm  %d\\n\", sizeof (xf->tm));\n",
        "    LL_DBG_PRINTK (\"[PRSR] qm  %d\\n\", sizeof (xf->qm));\n",
        "    if (xf->pm.phit & LLB_DP_FC_HIT) {\n",
        "        dp_parse_d0 (md, xf, 0);\n",
        "    }\n",
        "    if (xf->pm.pipe_act & LLB_PIPE_REWIRE) {\n",
        "        return dp_rewire_packet (md, xf);\n",
        "    }\n",
        "    else if (xf->pm.pipe_act & LLB_PIPE_RDR) {\n",
        "        return dp_redir_packet (md, xf);\n",
        "    }\n",
        "    if (xf->pm.pipe_act & LLB_PIPE_PASS || xf->pm.pipe_act & LLB_PIPE_TRAP) {\n",
        "        return DP_PASS;\n",
        "    }\n",
        "    return dp_ing_slow_main (md, xf);\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_rewire_packet",
        "dp_ing_slow_main",
        "dp_parse_d0",
        "dp_redir_packet"
      ],
      "call_depth": 11,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "xdp_packet_func": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 63,
      "endLine": 79,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_entry.c",
      "funcName": "xdp_packet_func",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [
        "  xfis"
      ],
      "input": [
        "struct xdp_md *ctx"
      ],
      "output": "int",
      "helper": [
        "bpf_map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "int xdp_packet_func (struct xdp_md *ctx)\n",
        "{\n",
        "    int z = 0;\n",
        "    struct xfi *xf;\n",
        "    LL_FC_PRINTK (\"[PRSR] xdp start\\n\");\n",
        "    xf = bpf_map_lookup_elem (& xfis, & z);\n",
        "    if (!xf) {\n",
        "        return DP_DROP;\n",
        "    }\n",
        "    memset (xf, 0, sizeof *xf);\n",
        "    dp_parse_d0 (ctx, xf, 0);\n",
        "    return DP_PASS;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_parse_d0"
      ],
      "call_depth": 4,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ],
  "xdp_pass_func": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 82,
      "endLine": 85,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_entry.c",
      "funcName": "xdp_pass_func",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct xdp_md *ctx"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "int xdp_pass_func (struct xdp_md *ctx)\n",
        "{\n",
        "    return dp_ing_pass_main (ctx);\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_ing_pass_main"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ],
  "tc_packet_func__": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 89,
      "endLine": 107,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_entry.c",
      "funcName": "tc_packet_func__",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [
        "  xfis"
      ],
      "input": [
        "struct  __sk_buff *md"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline tc_packet_func__ (struct  __sk_buff *md)\n",
        "{\n",
        "    int val = 0;\n",
        "    struct xfi *xf;\n",
        "    xf = bpf_map_lookup_elem (& xfis, & val);\n",
        "    if (!xf) {\n",
        "        return DP_DROP;\n",
        "    }\n",
        "    if (xf->pm.phit & LLB_DP_FC_HIT) {\n",
        "        memset (xf, 0, sizeof (*xf));\n",
        "        xf->pm.phit |= LLB_DP_FC_HIT;\n",
        "    }\n",
        "    xf->pm.tc = 1;\n",
        "    return dp_ing_pkt_main (md, xf);\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_ing_pkt_main"
      ],
      "call_depth": 12,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "tc_packet_func_fast": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 110,
      "endLine": 129,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_entry.c",
      "funcName": "tc_packet_func_fast",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __sk_buff *md"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "int tc_packet_func_fast (struct  __sk_buff *md)\n",
        "{\n",
        "\n",
        "#ifdef HAVE_DP_FC\n",
        "    struct xfi *xf;\n",
        "    DP_NEW_FCXF (xf);\n",
        "\n",
        "#ifdef HAVE_DP_EGR_HOOK\n",
        "    if (DP_LLB_INGP (md)) {\n",
        "        return DP_PASS;\n",
        "    }\n",
        "\n",
        "#endif\n",
        "    dp_parse_d0 (md, xf, 0);\n",
        "    return dp_ing_fc_main (md, xf);\n",
        "\n",
        "#else\n",
        "    return tc_packet_func__ (md);\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_ing_fc_main",
        "dp_parse_d0",
        "tc_packet_func__"
      ],
      "call_depth": 13,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ],
  "tc_packet_func": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 132,
      "endLine": 135,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_entry.c",
      "funcName": "tc_packet_func",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __sk_buff *md"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "int tc_packet_func (struct  __sk_buff *md)\n",
        "{\n",
        "    return tc_packet_func__ (md);\n",
        "}\n"
      ],
      "called_function_list": [
        "tc_packet_func__"
      ],
      "call_depth": 13,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ],
  "tc_packet_func_slow": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 138,
      "endLine": 149,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_entry.c",
      "funcName": "tc_packet_func_slow",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [
        "  xfis"
      ],
      "input": [
        "struct  __sk_buff *md"
      ],
      "output": "int",
      "helper": [
        "bpf_map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "int tc_packet_func_slow (struct  __sk_buff *md)\n",
        "{\n",
        "    int val = 0;\n",
        "    struct xfi *xf;\n",
        "    xf = bpf_map_lookup_elem (& xfis, & val);\n",
        "    if (!xf) {\n",
        "        return DP_DROP;\n",
        "    }\n",
        "    return dp_ing_ct_main (md, xf);\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_ing_ct_main"
      ],
      "call_depth": 7,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ],
  "tc_packet_func_fw": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 152,
      "endLine": 163,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_entry.c",
      "funcName": "tc_packet_func_fw",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [
        "  xfis"
      ],
      "input": [
        "struct  __sk_buff *md"
      ],
      "output": "int",
      "helper": [
        "bpf_map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "int tc_packet_func_fw (struct  __sk_buff *md)\n",
        "{\n",
        "    int val = 0;\n",
        "    struct xfi *xf;\n",
        "    xf = bpf_map_lookup_elem (& xfis, & val);\n",
        "    if (!xf) {\n",
        "        return DP_DROP;\n",
        "    }\n",
        "    return dp_do_fw_main (md, xf);\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_do_fw_main"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ],
  "tc_csum_func1": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 166,
      "endLine": 177,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_entry.c",
      "funcName": "tc_csum_func1",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [
        "  xfis"
      ],
      "input": [
        "struct  __sk_buff *md"
      ],
      "output": "int",
      "helper": [
        "bpf_map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "int tc_csum_func1 (struct  __sk_buff *md)\n",
        "{\n",
        "    int val = 0;\n",
        "    struct xfi *xf;\n",
        "    xf = bpf_map_lookup_elem (& xfis, & val);\n",
        "    if (!xf) {\n",
        "        return DP_DROP;\n",
        "    }\n",
        "    return dp_sctp_csum (md, xf);\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_sctp_csum"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ],
  "tc_csum_func2": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 180,
      "endLine": 191,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_entry.c",
      "funcName": "tc_csum_func2",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [
        "  xfis"
      ],
      "input": [
        "struct  __sk_buff *md"
      ],
      "output": "int",
      "helper": [
        "bpf_map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "int tc_csum_func2 (struct  __sk_buff *md)\n",
        "{\n",
        "    int val = 0;\n",
        "    struct xfi *xf;\n",
        "    xf = bpf_map_lookup_elem (& xfis, & val);\n",
        "    if (!xf) {\n",
        "        return DP_DROP;\n",
        "    }\n",
        "    return dp_sctp_csum (md, xf);\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_sctp_csum"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ],
  "tc_slow_unp_func": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 194,
      "endLine": 205,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_entry.c",
      "funcName": "tc_slow_unp_func",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [
        "  xfis"
      ],
      "input": [
        "struct  __sk_buff *md"
      ],
      "output": "int",
      "helper": [
        "bpf_map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "int tc_slow_unp_func (struct  __sk_buff *md)\n",
        "{\n",
        "    int val = 0;\n",
        "    struct xfi *xf;\n",
        "    xf = bpf_map_lookup_elem (& xfis, & val);\n",
        "    if (!xf) {\n",
        "        return DP_DROP;\n",
        "    }\n",
        "    return dp_unparse_packet_always_slow (md, xf);\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_unparse_packet_always_slow"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ],
  "dp_pipe_set_rm_gtp_tun": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 15,
      "endLine": 22,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_sessfwd.c",
      "funcName": "dp_pipe_set_rm_gtp_tun",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 6,
          "text": " *  llb_kern_sess.c: LoxiLB kernel eBPF Subscriber Session Implementation *  Copyright (C) 2022,  NetLOX <www.netlox.io> *  * SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause) "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_pipe_set_rm_gtp_tun (void *ctx, struct xfi *xf)\n",
        "{\n",
        "    LL_DBG_PRINTK (\"[SESS] rm-gtp \\n\");\n",
        "    dp_pop_outer_metadata (ctx, xf, 0);\n",
        "    xf->tm.tun_type = LLB_TUN_GTP;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_pop_outer_metadata"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_pipe_set_rm_ipip_tun": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 24,
      "endLine": 31,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_sessfwd.c",
      "funcName": "dp_pipe_set_rm_ipip_tun",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_pipe_set_rm_ipip_tun (void *ctx, struct xfi *xf)\n",
        "{\n",
        "    LL_DBG_PRINTK (\"[SESS] rm-ipip \\n\");\n",
        "    dp_pop_outer_metadata (ctx, xf, 0);\n",
        "    xf->tm.tun_type = LLB_TUN_IPIP;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_pop_outer_metadata"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_do_sess4_lkup": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 33,
      "endLine": 96,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_sessfwd.c",
      "funcName": "dp_do_sess4_lkup",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [
        "  sess_v4_map"
      ],
      "input": [
        "void *ctx",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_do_sess4_lkup (void *ctx, struct xfi *xf)\n",
        "{\n",
        "    struct dp_sess4_key key;\n",
        "    struct dp_sess_tact *act;\n",
        "    key.r = 0;\n",
        "    if (xf->tm.tunnel_id && xf->tm.tun_type != LLB_TUN_IPIP) {\n",
        "        key.daddr = xf->il34m.daddr4;\n",
        "        key.saddr = xf->il34m.saddr4;\n",
        "        key.teid = bpf_ntohl (xf->tm.tunnel_id);\n",
        "    }\n",
        "    else {\n",
        "        if (xf->pm.nf == LLB_NAT_SRC) {\n",
        "            key.saddr = xf->nm.nxip4;\n",
        "            key.daddr = xf->l34m.daddr4;\n",
        "        }\n",
        "        else if (xf->pm.nf == LLB_NAT_DST) {\n",
        "            key.daddr = xf->nm.nxip4;\n",
        "            key.saddr = xf->l34m.saddr4;\n",
        "        }\n",
        "        else {\n",
        "            key.daddr = xf->l34m.daddr4;\n",
        "            key.saddr = xf->l34m.saddr4;\n",
        "        }\n",
        "        key.teid = 0;\n",
        "    }\n",
        "    LL_DBG_PRINTK (\"[SESS4] -- Lookup\\n\");\n",
        "    LL_DBG_PRINTK (\"[SESS4] daddr %x\\n\", key.daddr);\n",
        "    LL_DBG_PRINTK (\"[SESS4] saddr %x\\n\", key.saddr);\n",
        "    LL_DBG_PRINTK (\"[SESS4] teid 0x%x\\n\", key.teid);\n",
        "    xf->pm.table_id = LL_DP_SESS4_MAP;\n",
        "    act = bpf_map_lookup_elem (& sess_v4_map, & key);\n",
        "    if (!act) {\n",
        "        LL_DBG_PRINTK (\"[SESS4] miss\");\n",
        "        return 0;\n",
        "    }\n",
        "    xf->pm.phit |= LLB_DP_SESS_HIT;\n",
        "    dp_do_map_stats (ctx, xf, LL_DP_SESS4_STATS_MAP, act->ca.cidx);\n",
        "    if (act->ca.act_type == DP_SET_DROP) {\n",
        "        goto drop;\n",
        "    }\n",
        "    else if (act->ca.act_type == DP_SET_RM_GTP) {\n",
        "        dp_pipe_set_rm_gtp_tun (ctx, xf);\n",
        "        xf->qm.qfi = act->qfi;\n",
        "        xf->pm.phit |= LLB_DP_TMAC_HIT;\n",
        "    }\n",
        "    else if (act->ca.act_type == DP_SET_RM_IPIP) {\n",
        "        dp_pipe_set_rm_ipip_tun (ctx, xf);\n",
        "        xf->pm.phit |= LLB_DP_TMAC_HIT;\n",
        "    }\n",
        "    else {\n",
        "        xf->tm.new_tunnel_id = act->teid;\n",
        "        xf->tm.tun_type = LLB_TUN_GTP;\n",
        "        xf->qm.qfi = act->qfi;\n",
        "        xf->tm.tun_rip = act->rip;\n",
        "        xf->tm.tun_sip = act->sip;\n",
        "    }\n",
        "    return 0;\n",
        "drop :\n",
        "    LLBS_PPLN_DROP (xf);\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_do_map_stats",
        "dp_pipe_set_rm_ipip_tun",
        "dp_pipe_set_rm_gtp_tun"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_do_smac_lkup": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 7,
      "endLine": 50,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_l2fwd.c",
      "funcName": "dp_do_smac_lkup",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 6,
          "text": " *  llb_kern_l2fwd.c: LoxiLB kernel eBPF L2 forwarder Implementation *  Copyright (C) 2022,  NetLOX <www.netlox.io> *  * SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause) "
        },
        {
          "start_line": 31,
          "end_line": 31,
          "text": " Default action "
        },
        {
          "start_line": 43,
          "end_line": 43,
          "text": " Nothing to do "
        }
      ],
      "updateMaps": [],
      "readMaps": [
        "  smac_map"
      ],
      "input": [
        "void *ctx",
        " struct xfi *xf",
        " void *fc"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_do_smac_lkup (void *ctx, struct xfi *xf, void *fc)\n",
        "{\n",
        "    struct dp_smac_key key;\n",
        "    struct dp_smac_tact *sma;\n",
        "    if (xf->l2m.vlan[0] == 0) {\n",
        "        return 0;\n",
        "    }\n",
        "    memcpy (key.smac, xf->l2m.dl_src, 6);\n",
        "    key.bd = xf->pm.bd;\n",
        "    LL_DBG_PRINTK (\"[SMAC] -- Lookup\\n\");\n",
        "    LL_DBG_PRINTK (\"[SMAC] %x:%x:%x\\n\", key.smac[0], key.smac[1], key.smac[2]);\n",
        "    LL_DBG_PRINTK (\"[SMAC] %x:%x:%x\\n\", key.smac[3], key.smac[4], key.smac[5]);\n",
        "    LL_DBG_PRINTK (\"[SMAC] BD%d\\n\", key.bd);\n",
        "    xf->pm.table_id = LL_DP_SMAC_MAP;\n",
        "    sma = bpf_map_lookup_elem (& smac_map, & key);\n",
        "    if (!sma) {\n",
        "        LLBS_PPLN_PASS (xf);\n",
        "        return 0;\n",
        "    }\n",
        "    LL_DBG_PRINTK (\"[SMAC] action %d\\n\", sma->ca.act_type);\n",
        "    if (sma->ca.act_type == DP_SET_DROP) {\n",
        "        LLBS_PPLN_DROP (xf);\n",
        "    }\n",
        "    else if (sma->ca.act_type == DP_SET_TOCP) {\n",
        "        LLBS_PPLN_TRAP (xf);\n",
        "    }\n",
        "    else if (sma->ca.act_type == DP_SET_NOP) {\n",
        "        return 0;\n",
        "    }\n",
        "    else {\n",
        "        LLBS_PPLN_DROP (xf);\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_pipe_set_l22_tun_nh": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 52,
      "endLine": 65,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_l2fwd.c",
      "funcName": "dp_pipe_set_l22_tun_nh",
      "developer_inline_comments": [
        {
          "start_line": 57,
          "end_line": 60,
          "text": "   * We do not set out_bd here. After NH lookup match is   * found and packet tunnel insertion is done, BD is set accordingly   "
        },
        {
          "start_line": 61,
          "end_line": 61,
          "text": "xf->pm.bd = rnh->bd;"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf",
        " struct dp_rt_nh_act *rnh"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_pipe_set_l22_tun_nh (void *ctx, struct xfi *xf, struct dp_rt_nh_act *rnh)\n",
        "{\n",
        "    xf->pm.nh_num = rnh->nh_num;\n",
        "    xf->tm.new_tunnel_id = rnh->tid;\n",
        "    LL_DBG_PRINTK (\"[TMAC] new-vx nh %u\\n\", xf->pm.nh_num);\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_pipe_set_rm_vx_tun": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 67,
      "endLine": 75,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_l2fwd.c",
      "funcName": "dp_pipe_set_rm_vx_tun",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf",
        " struct dp_rt_nh_act *rnh"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_pipe_set_rm_vx_tun (void *ctx, struct xfi *xf, struct dp_rt_nh_act *rnh)\n",
        "{\n",
        "    xf->pm.phit &= ~LLB_DP_TMAC_HIT;\n",
        "    xf->pm.bd = rnh->bd;\n",
        "    LL_DBG_PRINTK (\"[TMAC] rm-vx newbd %d \\n\", xf->pm.bd);\n",
        "    return dp_pop_outer_metadata (ctx, xf, 1);\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_pop_outer_metadata"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "__dp_do_tmac_lkup": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 77,
      "endLine": 140,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_l2fwd.c",
      "funcName": "__dp_do_tmac_lkup",
      "developer_inline_comments": [
        {
          "start_line": 108,
          "end_line": 108,
          "text": " No L3 lookup "
        }
      ],
      "updateMaps": [],
      "readMaps": [
        "  tmac_map"
      ],
      "input": [
        "void *ctx",
        " struct xfi *xf",
        " int tun_lkup",
        " void *fa_"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline __dp_do_tmac_lkup (void *ctx, struct xfi *xf, int tun_lkup, void *fa_)\n",
        "{\n",
        "    struct dp_tmac_key key;\n",
        "    struct dp_tmac_tact *tma;\n",
        "\n",
        "#ifdef HAVE_DP_EXTFC\n",
        "    struct dp_fc_tacts *fa = fa_;\n",
        "\n",
        "#endif\n",
        "    memcpy (key.mac, xf->l2m.dl_dst, 6);\n",
        "    key.pad = 0;\n",
        "    if (tun_lkup) {\n",
        "        key.tunnel_id = xf->tm.tunnel_id;\n",
        "        key.tun_type = xf->tm.tun_type;\n",
        "    }\n",
        "    else {\n",
        "        key.tunnel_id = 0;\n",
        "        key.tun_type = 0;\n",
        "    }\n",
        "    LL_DBG_PRINTK (\"[TMAC] -- Lookup\\n\");\n",
        "    LL_DBG_PRINTK (\"[TMAC] %x:%x:%x\\n\", key.mac[0], key.mac[1], key.mac[2]);\n",
        "    LL_DBG_PRINTK (\"[TMAC] %x:%x:%x\\n\", key.mac[3], key.mac[4], key.mac[5]);\n",
        "    LL_DBG_PRINTK (\"[TMAC] %x:%x\\n\", key.tunnel_id, key.tun_type);\n",
        "    xf->pm.table_id = LL_DP_TMAC_MAP;\n",
        "    tma = bpf_map_lookup_elem (& tmac_map, & key);\n",
        "    if (!tma) {\n",
        "        return 0;\n",
        "    }\n",
        "    LL_DBG_PRINTK (\"[TMAC] action %d %d\\n\", tma->ca.act_type, tma->ca.cidx);\n",
        "    if (tma->ca.cidx != 0) {\n",
        "        dp_do_map_stats (ctx, xf, LL_DP_TMAC_STATS_MAP, tma->ca.cidx);\n",
        "    }\n",
        "    if (tma->ca.act_type == DP_SET_DROP) {\n",
        "        LLBS_PPLN_DROP (xf);\n",
        "    }\n",
        "    else if (tma->ca.act_type == DP_SET_TOCP) {\n",
        "        LLBS_PPLN_TRAP (xf);\n",
        "    }\n",
        "    else if (tma->ca.act_type == DP_SET_RT_TUN_NH) {\n",
        "\n",
        "#ifdef HAVE_DP_EXTFC\n",
        "        struct dp_fc_tact *ta = &fa->fcta[DP_SET_RT_TUN_NH];\n",
        "        ta->ca.act_type = DP_SET_RT_TUN_NH;\n",
        "        memcpy (&ta->nh_act, &tma->rt_nh, sizeof (tma->rt_nh));\n",
        "\n",
        "#endif\n",
        "        return dp_pipe_set_l22_tun_nh (ctx, xf, &tma->rt_nh);\n",
        "    }\n",
        "    else if (tma->ca.act_type == DP_SET_L3_EN) {\n",
        "        xf->pm.phit |= LLB_DP_TMAC_HIT;\n",
        "    }\n",
        "    else if (tma->ca.act_type == DP_SET_RM_VXLAN) {\n",
        "\n",
        "#ifdef HAVE_DP_EXTFC\n",
        "        struct dp_fc_tact *ta = &fa->fcta[DP_SET_RM_VXLAN];\n",
        "        ta->ca.act_type = DP_SET_RM_VXLAN;\n",
        "        memcpy (&ta->nh_act, &tma->rt_nh, sizeof (tma->rt_nh));\n",
        "\n",
        "#endif\n",
        "        return dp_pipe_set_rm_vx_tun (ctx, xf, &tma->rt_nh);\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_pipe_set_l22_tun_nh",
        "dp_do_map_stats",
        "dp_pipe_set_rm_vx_tun"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_do_tmac_lkup": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 142,
      "endLine": 146,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_l2fwd.c",
      "funcName": "dp_do_tmac_lkup",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf",
        " void *fa"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_do_tmac_lkup (void *ctx, struct xfi *xf, void *fa)\n",
        "{\n",
        "    return __dp_do_tmac_lkup (ctx, xf, 0, fa);\n",
        "}\n"
      ],
      "called_function_list": [
        "__dp_do_tmac_lkup"
      ],
      "call_depth": 4,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_do_tun_lkup": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 148,
      "endLine": 155,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_l2fwd.c",
      "funcName": "dp_do_tun_lkup",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf",
        " void *fa"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_do_tun_lkup (void *ctx, struct xfi *xf, void *fa)\n",
        "{\n",
        "    if (xf->tm.tunnel_id != 0) {\n",
        "        return __dp_do_tmac_lkup (ctx, xf, 1, fa);\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "__dp_do_tmac_lkup"
      ],
      "call_depth": 4,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_set_egr_vlan": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 157,
      "endLine": 166,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_l2fwd.c",
      "funcName": "dp_set_egr_vlan",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf",
        " __u16 vlan",
        " __u16 oport"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_set_egr_vlan (void *ctx, struct xfi *xf, __u16 vlan, __u16 oport)\n",
        "{\n",
        "    LLBS_PPLN_RDR (xf);\n",
        "    xf->pm.oport = oport;\n",
        "    xf->pm.bd = vlan;\n",
        "    LL_DBG_PRINTK (\"[SETVLAN] OP %u V %u\\n\", oport, vlan);\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_do_dmac_lkup": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 168,
      "endLine": 226,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_l2fwd.c",
      "funcName": "dp_do_dmac_lkup",
      "developer_inline_comments": [
        {
          "start_line": 190,
          "end_line": 190,
          "text": " No DMAC lookup "
        }
      ],
      "updateMaps": [],
      "readMaps": [
        "  dmac_map"
      ],
      "input": [
        "void *ctx",
        " struct xfi *xf",
        " void *fa_"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_do_dmac_lkup (void *ctx, struct xfi *xf, void *fa_)\n",
        "{\n",
        "    struct dp_dmac_key key;\n",
        "    struct dp_dmac_tact *dma;\n",
        "\n",
        "#ifdef HAVE_DP_FC\n",
        "    struct dp_fc_tacts *fa = fa_;\n",
        "\n",
        "#endif\n",
        "    memcpy (key.dmac, xf->pm.lkup_dmac, 6);\n",
        "    key.bd = xf->pm.bd;\n",
        "    xf->pm.table_id = LL_DP_DMAC_MAP;\n",
        "    LL_DBG_PRINTK (\"[DMAC] -- Lookup \\n\");\n",
        "    LL_DBG_PRINTK (\"[DMAC] %x:%x:%x\\n\", key.dmac[0], key.dmac[1], key.dmac[2]);\n",
        "    LL_DBG_PRINTK (\"[DMAC] %x:%x:%x\\n\", key.dmac[3], key.dmac[4], key.dmac[5]);\n",
        "    LL_DBG_PRINTK (\"[DMAC] BD %d\\n\", key.bd);\n",
        "    dma = bpf_map_lookup_elem (& dmac_map, & key);\n",
        "    if (!dma) {\n",
        "        LL_DBG_PRINTK (\"[DMAC] not found\\n\");\n",
        "        LLBS_PPLN_PASS (xf);\n",
        "        return 0;\n",
        "    }\n",
        "    LL_DBG_PRINTK (\"[DMAC] action %d pipe %d\\n\", dma->ca.act_type, xf->pm.pipe_act);\n",
        "    if (dma->ca.act_type == DP_SET_DROP) {\n",
        "        LLBS_PPLN_DROP (xf);\n",
        "    }\n",
        "    else if (dma->ca.act_type == DP_SET_TOCP) {\n",
        "        LLBS_PPLN_TRAP (xf);\n",
        "    }\n",
        "    else if (dma->ca.act_type == DP_SET_RDR_PORT) {\n",
        "        struct dp_rdr_act *ra = &dma->port_act;\n",
        "        LLBS_PPLN_RDR (xf);\n",
        "        xf->pm.oport = ra->oport;\n",
        "        LL_DBG_PRINTK (\"[DMAC] oport %lu\\n\", xf->pm.oport);\n",
        "        return 0;\n",
        "    }\n",
        "    else if (dma->ca.act_type == DP_SET_ADD_L2VLAN || dma->ca.act_type == DP_SET_RM_L2VLAN) {\n",
        "        struct dp_l2vlan_act *va = &dma->vlan_act;\n",
        "\n",
        "#ifdef HAVE_DP_FC\n",
        "        struct dp_fc_tact *ta = &fa->fcta[dma->ca.act_type == DP_SET_ADD_L2VLAN ? DP_SET_ADD_L2VLAN : DP_SET_RM_L2VLAN];\n",
        "        ta->ca.act_type = dma->ca.act_type;\n",
        "        memcpy (&ta->l2ov, va, sizeof (*va));\n",
        "\n",
        "#endif\n",
        "        return dp_set_egr_vlan (ctx, xf, dma->ca.act_type == DP_SET_RM_L2VLAN ? 0 : va->vlan, va->oport);\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_set_egr_vlan"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_do_rt_l2_nh": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 228,
      "endLine": 238,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_l2fwd.c",
      "funcName": "dp_do_rt_l2_nh",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf",
        " struct dp_rt_l2nh_act *nl2"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_do_rt_l2_nh (void *ctx, struct xfi *xf, struct dp_rt_l2nh_act *nl2)\n",
        "{\n",
        "    memcpy (xf->l2m.dl_dst, nl2->dmac, 6);\n",
        "    memcpy (xf->l2m.dl_src, nl2->smac, 6);\n",
        "    memcpy (xf->pm.lkup_dmac, nl2->dmac, 6);\n",
        "    xf->pm.bd = nl2->bd;\n",
        "    return nl2->rnh_num;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_do_rt_tun_nh": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 240,
      "endLine": 263,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_l2fwd.c",
      "funcName": "dp_do_rt_tun_nh",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf",
        " __u32 tun_type",
        " struct dp_rt_tunnh_act *ntun"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_do_rt_tun_nh (void *ctx, struct xfi *xf, __u32 tun_type, struct dp_rt_tunnh_act *ntun)\n",
        "{\n",
        "    struct dp_rt_l2nh_act *nl2;\n",
        "    xf->tm.tun_rip = ntun->l3t.rip;\n",
        "    xf->tm.tun_sip = ntun->l3t.sip;\n",
        "    xf->tm.new_tunnel_id = ntun->l3t.tid;\n",
        "    xf->tm.tun_type = tun_type;\n",
        "    if (tun_type == LLB_TUN_VXLAN) {\n",
        "        memcpy (&xf->il2m, &xf->l2m, sizeof (xf->l2m));\n",
        "        xf->il2m.vlan[0] = 0;\n",
        "    }\n",
        "    nl2 = &ntun->l2nh;\n",
        "    memcpy (xf->l2m.dl_dst, nl2->dmac, 6);\n",
        "    memcpy (xf->l2m.dl_src, nl2->smac, 6);\n",
        "    memcpy (xf->pm.lkup_dmac, nl2->dmac, 6);\n",
        "    xf->pm.bd = nl2->bd;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_do_nh_lkup": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 265,
      "endLine": 326,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_l2fwd.c",
      "funcName": "dp_do_nh_lkup",
      "developer_inline_comments": [
        {
          "start_line": 282,
          "end_line": 282,
          "text": " No NH - Drop "
        },
        {
          "start_line": 301,
          "end_line": 301,
          "text": " Check if need to do recursive next-hop lookup "
        },
        {
          "start_line": 306,
          "end_line": 306,
          "text": " No NH - Trap "
        },
        {
          "start_line": 307,
          "end_line": 307,
          "text": " LLBS_PPLN_DROP(xf); "
        }
      ],
      "updateMaps": [],
      "readMaps": [
        "  nh_map"
      ],
      "input": [
        "void *ctx",
        " struct xfi *xf",
        " void *fa_"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_do_nh_lkup (void *ctx, struct xfi *xf, void *fa_)\n",
        "{\n",
        "    struct dp_nh_key key;\n",
        "    struct dp_nh_tact *nha;\n",
        "    int rnh = 0;\n",
        "\n",
        "#ifdef HAVE_DP_FC\n",
        "    struct dp_fc_tacts *fa = fa_;\n",
        "\n",
        "#endif\n",
        "    key.nh_num = (__u32) xf->pm.nh_num;\n",
        "    LL_DBG_PRINTK (\"[NHFW] -- Lookup ID %d\\n\", key.nh_num);\n",
        "    xf->pm.table_id = LL_DP_NH_MAP;\n",
        "    nha = bpf_map_lookup_elem (& nh_map, & key);\n",
        "    if (!nha) {\n",
        "        LLBS_PPLN_TRAP (xf)\n",
        "        return 0;\n",
        "    }\n",
        "    LL_DBG_PRINTK (\"[NHFW] action %d pipe %x\\n\", nha->ca.act_type, xf->pm.pipe_act);\n",
        "    if (nha->ca.act_type == DP_SET_DROP) {\n",
        "        LLBS_PPLN_DROP (xf);\n",
        "    }\n",
        "    else if (nha->ca.act_type == DP_SET_TOCP) {\n",
        "        LLBS_PPLN_TRAP (xf);\n",
        "    }\n",
        "    else if (nha->ca.act_type == DP_SET_NEIGH_L2) {\n",
        "\n",
        "#ifdef HAVE_DP_FC\n",
        "        struct dp_fc_tact *ta = &fa->fcta[DP_SET_NEIGH_L2];\n",
        "        ta->ca.act_type = nha->ca.act_type;\n",
        "        memcpy (&ta->nl2, &nha->rt_l2nh, sizeof (nha->rt_l2nh));\n",
        "\n",
        "#endif\n",
        "        rnh = dp_do_rt_l2_nh (ctx, xf, & nha -> rt_l2nh);\n",
        "        if (rnh != 0) {\n",
        "            key.nh_num = (__u32) rnh;\n",
        "            nha = bpf_map_lookup_elem (& nh_map, & key);\n",
        "            if (!nha) {\n",
        "                LLBS_PPLN_TRAP (xf)\n",
        "                return 0;\n",
        "            }\n",
        "        }\n",
        "    }\n",
        "    if (nha->ca.act_type == DP_SET_NEIGH_VXLAN) {\n",
        "\n",
        "#ifdef HAVE_DP_EXTFC\n",
        "        struct dp_fc_tact *ta = &fa->fcta[DP_SET_NEIGH_VXLAN];\n",
        "        ta->ca.act_type = nha->ca.act_type;\n",
        "        memcpy (&ta->ntun, &nha->rt_tnh, sizeof (nha->rt_tnh));\n",
        "\n",
        "#endif\n",
        "        return dp_do_rt_tun_nh (ctx, xf, LLB_TUN_VXLAN, &nha->rt_tnh);\n",
        "    }\n",
        "    else if (nha->ca.act_type == DP_SET_NEIGH_IPIP) {\n",
        "        return dp_do_rt_tun_nh (ctx, xf, LLB_TUN_IPIP, &nha->rt_tnh);\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_do_rt_l2_nh",
        "dp_do_rt_tun_nh"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_eg_l2": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 328,
      "endLine": 344,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_l2fwd.c",
      "funcName": "dp_eg_l2",
      "developer_inline_comments": [
        {
          "start_line": 331,
          "end_line": 331,
          "text": " Any processing based on results from L3 "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf",
        " void *fa"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_eg_l2 (void *ctx, struct xfi *xf, void *fa)\n",
        "{\n",
        "    if (xf->pm.pipe_act & LLB_PIPE_RDR_MASK) {\n",
        "        return 0;\n",
        "    }\n",
        "    if (xf->pm.nh_num != 0) {\n",
        "        dp_do_nh_lkup (ctx, xf, fa);\n",
        "    }\n",
        "    dp_do_map_stats (ctx, xf, LL_DP_TX_BD_STATS_MAP, xf->pm.bd);\n",
        "    dp_do_dmac_lkup (ctx, xf, fa);\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_do_nh_lkup",
        "dp_do_map_stats",
        "dp_do_dmac_lkup"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_ing_fwd": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 346,
      "endLine": 351,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_l2fwd.c",
      "funcName": "dp_ing_fwd",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf",
        " void *fa"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_ing_fwd (void *ctx, struct xfi *xf, void *fa)\n",
        "{\n",
        "    dp_ing_l3 (ctx, xf, fa);\n",
        "    return dp_eg_l2 (ctx, xf, fa);\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_eg_l2",
        "dp_ing_l3"
      ],
      "call_depth": 8,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_ing_l2_top": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 353,
      "endLine": 367,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_l2fwd.c",
      "funcName": "dp_ing_l2_top",
      "developer_inline_comments": [
        {
          "start_line": 361,
          "end_line": 361,
          "text": " FIXME Also need to check if L2 tunnel "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf",
        " void *fa"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_ing_l2_top (void *ctx, struct xfi *xf, void *fa)\n",
        "{\n",
        "    dp_do_smac_lkup (ctx, xf, fa);\n",
        "    dp_do_tmac_lkup (ctx, xf, fa);\n",
        "    dp_do_tun_lkup (ctx, xf, fa);\n",
        "    if (xf->tm.tun_decap) {\n",
        "        dp_do_smac_lkup (ctx, xf, fa);\n",
        "        dp_do_tmac_lkup (ctx, xf, fa);\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_do_smac_lkup",
        "dp_do_tmac_lkup",
        "dp_do_tun_lkup"
      ],
      "call_depth": 5,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_ing_l2": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 369,
      "endLine": 375,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_l2fwd.c",
      "funcName": "dp_ing_l2",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf",
        " void *fa"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_ing_l2 (void *ctx, struct xfi *xf, void *fa)\n",
        "{\n",
        "    LL_DBG_PRINTK (\"[ING L2]\");\n",
        "    dp_ing_l2_top (ctx, xf, fa);\n",
        "    return dp_ing_fwd (ctx, xf, fa);\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_ing_l2_top",
        "dp_ing_fwd"
      ],
      "call_depth": 9,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_do_rt4_fwdops": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 7,
      "endLine": 19,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_l3fwd.c",
      "funcName": "dp_do_rt4_fwdops",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 6,
          "text": " *  llb_kern_l3fwd.c: LoxiLB Kernel eBPF L3 forwarder Implementation *  Copyright (C) 2022,  NetLOX <www.netlox.io> *  * SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause) "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_do_rt4_fwdops (void *ctx, struct xfi *xf)\n",
        "{\n",
        "    struct iphdr *iph = DP_TC_PTR (DP_PDATA (ctx) +xf->pm.l3_off);\n",
        "    void *dend = DP_TC_PTR (DP_PDATA_END (ctx));\n",
        "    if (iph + 1 > dend) {\n",
        "        LLBS_PPLN_DROP (xf);\n",
        "        return -1;\n",
        "    }\n",
        "    ip_decrease_ttl (iph);\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "ip_decrease_ttl"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_do_rt6_fwdops": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 21,
      "endLine": 33,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_l3fwd.c",
      "funcName": "dp_do_rt6_fwdops",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_do_rt6_fwdops (void *ctx, struct xfi *xf)\n",
        "{\n",
        "    struct ipv6hdr *ip6h = DP_TC_PTR (DP_PDATA (ctx) +xf->pm.l3_off);\n",
        "    void *dend = DP_TC_PTR (DP_PDATA_END (ctx));\n",
        "    if (ip6h + 1 > dend) {\n",
        "        LLBS_PPLN_DROP (xf);\n",
        "        return -1;\n",
        "    }\n",
        "    ip6h->hop_limit--;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_do_rt_fwdops": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 35,
      "endLine": 44,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_l3fwd.c",
      "funcName": "dp_do_rt_fwdops",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_do_rt_fwdops (void *ctx, struct xfi *xf)\n",
        "{\n",
        "    if (xf->l2m.dl_type == ETH_P_IP) {\n",
        "        return dp_do_rt4_fwdops (ctx, xf);\n",
        "    }\n",
        "    else if (xf->l2m.dl_type == ETH_P_IPV6) {\n",
        "        return dp_do_rt6_fwdops (ctx, xf);\n",
        "    }\n",
        "    return DP_DROP;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_do_rt4_fwdops",
        "dp_do_rt6_fwdops"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_pipe_set_l32_tun_nh": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 46,
      "endLine": 67,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_l3fwd.c",
      "funcName": "dp_pipe_set_l32_tun_nh",
      "developer_inline_comments": [
        {
          "start_line": 52,
          "end_line": 55,
          "text": "   * We do not set out_bd here. After NH lookup match is   * found and packet tunnel insertion is done, BD is set accordingly   "
        },
        {
          "start_line": 56,
          "end_line": 56,
          "text": "xf->pm.bd = rnh->bd;"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf",
        " struct dp_rt_nh_act *rnh"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_pipe_set_l32_tun_nh (void *ctx, struct xfi *xf, struct dp_rt_nh_act *rnh)\n",
        "{\n",
        "    struct dp_rt_l2nh_act *nl2;\n",
        "    xf->pm.nh_num = rnh->nh_num;\n",
        "    xf->tm.new_tunnel_id = rnh->tid;\n",
        "    nl2 = &rnh->l2nh;\n",
        "    memcpy (xf->l2m.dl_dst, nl2->dmac, 6);\n",
        "    memcpy (xf->l2m.dl_src, nl2->smac, 6);\n",
        "    memcpy (xf->pm.lkup_dmac, nl2->dmac, 6);\n",
        "    xf->pm.bd = nl2->bd;\n",
        "    LL_DBG_PRINTK (\"[RTFW] new-vx nh %u\\n\", xf->pm.nh_num);\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_rtv4_get_ipkey": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 69,
      "endLine": 97,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_l3fwd.c",
      "funcName": "dp_rtv4_get_ipkey",
      "developer_inline_comments": [
        {
          "start_line": 87,
          "end_line": 89,
          "text": " In case of GTP, there is no interface created in OS          * which has a specific route through it. So, this hack !!         "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct xfi *xf"
      ],
      "output": "static__u32__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static __u32 __always_inline dp_rtv4_get_ipkey (struct xfi *xf)\n",
        "{\n",
        "    __u32 ipkey;\n",
        "    if (xf->pm.nf & LLB_NAT_DST) {\n",
        "        ipkey = xf->nm.nxip4 ? : xf->l34m.saddr4;\n",
        "    }\n",
        "    else {\n",
        "        if (xf->pm.nf & LLB_NAT_SRC) {\n",
        "            if (xf->nm.nrip4) {\n",
        "                ipkey = xf->nm.nrip4;\n",
        "            }\n",
        "            else if (xf->nm.nxip4 == 0) {\n",
        "                ipkey = xf->l34m.saddr4;\n",
        "            }\n",
        "            else {\n",
        "                ipkey = xf->l34m.daddr4;\n",
        "            }\n",
        "        }\n",
        "        else {\n",
        "            if (xf->tm.new_tunnel_id && xf->tm.tun_type == LLB_TUN_GTP) {\n",
        "                ipkey = xf->tm.tun_rip;\n",
        "            }\n",
        "            else {\n",
        "                ipkey = xf->l34m.daddr4;\n",
        "            }\n",
        "        }\n",
        "    }\n",
        "    return ipkey;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_do_rtops": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 99,
      "endLine": 129,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_l3fwd.c",
      "funcName": "dp_do_rtops",
      "developer_inline_comments": [
        {
          "start_line": 117,
          "end_line": 124,
          "text": "else if (act->ca.act_type == DP_SET_L3RT_TUN_NH) {#ifdef HAVE_DP_EXTFC    struct dp_fc_tact *ta = &fa->fcta[DP_SET_L3RT_TUN_NH];    ta->ca.act_type = DP_SET_L3RT_TUN_NH;    memcpy(&ta->nh_act,  &act->rt_nh, sizeof(act->rt_nh));#endif    return dp_pipe_set_l32_tun_nh(ctx, xf, &act->rt_nh);  } "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf",
        " void *fa_",
        " struct dp_rt_tact *act"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_do_rtops (void *ctx, struct xfi *xf, void *fa_, struct dp_rt_tact *act)\n",
        "{\n",
        "    LL_DBG_PRINTK (\"[RTFW] action %d pipe %x\\n\", act->ca.act_type, xf->pm.pipe_act);\n",
        "    if (act->ca.act_type == DP_SET_DROP) {\n",
        "        LLBS_PPLN_DROP (xf);\n",
        "    }\n",
        "    else if (act->ca.act_type == DP_SET_TOCP) {\n",
        "        LLBS_PPLN_TRAP (xf);\n",
        "    }\n",
        "    else if (act->ca.act_type == DP_SET_RDR_PORT) {\n",
        "        struct dp_rdr_act *ra = &act->port_act;\n",
        "        LLBS_PPLN_RDR (xf);\n",
        "        xf->pm.oport = ra->oport;\n",
        "    }\n",
        "    else if (act->ca.act_type == DP_SET_RT_NHNUM) {\n",
        "        struct dp_rt_nh_act *rnh = &act->rt_nh;\n",
        "        xf->pm.nh_num = rnh->nh_num;\n",
        "        return dp_do_rt_fwdops (ctx, xf);\n",
        "    }\n",
        "    else {\n",
        "        LLBS_PPLN_DROP (xf);\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_do_rt_fwdops"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_do_rtv6": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 131,
      "endLine": 179,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_l3fwd.c",
      "funcName": "dp_do_rtv6",
      "developer_inline_comments": [
        {
          "start_line": 137,
          "end_line": 137,
          "text": " 128-bit prefix "
        },
        {
          "start_line": 169,
          "end_line": 169,
          "text": " Default action - Nothing to do "
        }
      ],
      "updateMaps": [],
      "readMaps": [
        "  rt_v6_map"
      ],
      "input": [
        "void *ctx",
        " struct xfi *xf",
        " void *fa_"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_do_rtv6 (void *ctx, struct xfi *xf, void *fa_)\n",
        "{\n",
        "    struct dp_rtv6_key *key = (void *) xf->km.skey;\n",
        "    struct dp_rt_tact *act;\n",
        "    key->l.prefixlen = 128;\n",
        "    if (xf->pm.nf & LLB_NAT_DST) {\n",
        "        if (DP_XADDR_ISZR (xf->nm.nxip)) {\n",
        "            DP_XADDR_CP (key->addr, xf->l34m.saddr);\n",
        "        }\n",
        "        else {\n",
        "            DP_XADDR_CP (key->addr, xf->nm.nxip);\n",
        "        }\n",
        "    }\n",
        "    else {\n",
        "        if (xf->pm.nf & LLB_NAT_SRC) {\n",
        "            if (!DP_XADDR_ISZR(xf->nm.nrip)) {\n",
        "                DP_XADDR_CP (key->addr, xf->nm.nrip);\n",
        "            }\n",
        "            else if (DP_XADDR_ISZR (xf->nm.nxip)) {\n",
        "                DP_XADDR_CP (key->addr, xf->l34m.saddr);\n",
        "            }\n",
        "            else {\n",
        "                DP_XADDR_CP (key->addr, xf->l34m.daddr);\n",
        "            }\n",
        "        }\n",
        "        else {\n",
        "            DP_XADDR_CP (key->addr, xf->l34m.daddr);\n",
        "        }\n",
        "    }\n",
        "    LL_DBG_PRINTK (\"[RT6FW] --Lookup\");\n",
        "    LL_DBG_PRINTK (\"[RT6FW] --addr0 %x\", key->addr[0]);\n",
        "    LL_DBG_PRINTK (\"[RT6FW] --addr1 %x\", key->addr[1]);\n",
        "    LL_DBG_PRINTK (\"[RT6FW] --addr2 %x\", key->addr[2]);\n",
        "    LL_DBG_PRINTK (\"[RT6FW] --addr3 %x\", key->addr[3]);\n",
        "    xf->pm.table_id = LL_DP_RTV6_MAP;\n",
        "    act = bpf_map_lookup_elem (& rt_v6_map, key);\n",
        "    if (!act) {\n",
        "        xf->pm.nf &= ~LLB_NAT_SRC;\n",
        "        LL_DBG_PRINTK (\"RT Not found\");\n",
        "        return 0;\n",
        "    }\n",
        "    xf->pm.phit |= LLB_XDP_RT_HIT;\n",
        "    dp_do_map_stats (ctx, xf, LL_DP_RTV6_STATS_MAP, act->ca.cidx);\n",
        "    return dp_do_rtops (ctx, xf, fa_, act);\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_do_rtops",
        "dp_do_map_stats"
      ],
      "call_depth": 4,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_do_rtv4": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 181,
      "endLine": 211,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_l3fwd.c",
      "funcName": "dp_do_rtv4",
      "developer_inline_comments": [
        {
          "start_line": 184,
          "end_line": 184,
          "text": "struct dp_rtv4_key key = { 0 };"
        },
        {
          "start_line": 188,
          "end_line": 188,
          "text": " 16-bit zone + 32-bit prefix "
        },
        {
          "start_line": 202,
          "end_line": 202,
          "text": " Default action - Nothing to do "
        }
      ],
      "updateMaps": [],
      "readMaps": [
        "  rt_v4_map"
      ],
      "input": [
        "void *ctx",
        " struct xfi *xf",
        " void *fa_"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_do_rtv4 (void *ctx, struct xfi *xf, void *fa_)\n",
        "{\n",
        "    struct dp_rtv4_key *key = (void *) xf->km.skey;\n",
        "    struct dp_rt_tact *act;\n",
        "    key->l.prefixlen = 48;\n",
        "    key->v4k[0] = xf->pm.zone >> 8 & 0xff;\n",
        "    key->v4k[1] = xf->pm.zone & 0xff;\n",
        "    *(__u32*) &key->v4k[2] = dp_rtv4_get_ipkey (xf);\n",
        "    LL_DBG_PRINTK (\"[RTFW] --Lookup\\n\");\n",
        "    LL_DBG_PRINTK (\"[RTFW] Zone %d 0x%x\\n\", xf->pm.zone, *(__u32*) &key->v4k[2]);\n",
        "    xf->pm.table_id = LL_DP_RTV4_MAP;\n",
        "    act = bpf_map_lookup_elem (& rt_v4_map, key);\n",
        "    if (!act) {\n",
        "        xf->pm.nf &= ~LLB_NAT_SRC;\n",
        "        return 0;\n",
        "    }\n",
        "    xf->pm.phit |= LLB_XDP_RT_HIT;\n",
        "    dp_do_map_stats (ctx, xf, LL_DP_RTV4_STATS_MAP, act->ca.cidx);\n",
        "    return dp_do_rtops (ctx, xf, fa_, act);\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_do_rtops",
        "dp_do_map_stats",
        "dp_rtv4_get_ipkey"
      ],
      "call_depth": 4,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_pipe_set_nat": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 213,
      "endLine": 226,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_l3fwd.c",
      "funcName": "dp_pipe_set_nat",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf",
        " struct dp_nat_act *na",
        " int do_snat"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_pipe_set_nat (void *ctx, struct xfi *xf, struct dp_nat_act *na, int do_snat)\n",
        "{\n",
        "    xf->pm.nf = do_snat ? LLB_NAT_SRC : LLB_NAT_DST;\n",
        "    DP_XADDR_CP (xf->nm.nxip, na->xip);\n",
        "    DP_XADDR_CP (xf->nm.nrip, na->rip);\n",
        "    xf->nm.nxport = na->xport;\n",
        "    xf->nm.nv6 = na->nv6 ? 1 : 0;\n",
        "    xf->nm.dsr = na->dsr;\n",
        "    LL_DBG_PRINTK (\"[ACL4] NAT ACT %x\\n\", xf->pm.nf);\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_do_ctops": [
    {
      "capabilities": [
        {
          "capability": "read_sys_info",
          "read_sys_info": [
            {
              "Project": "bcc",
              "FunctionName": "bpf_ktime_get_ns",
              "Return Type": "u64",
              "Description": "u64 bpf_ktime_get_ns(void) Return: u64 number of nanoseconds. Starts at system boot time but stops during suspend. Examples in situ: \"https://github.com/iovisor/bcc/search?q=bpf_ktime_get_ns+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=bpf_ktime_get_ns+path%3Atools&type=Code search /tools ",
              "Return": "u64 number of nanoseconds",
              "Input Prameters": [],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 228,
      "endLine": 336,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_l3fwd.c",
      "funcName": "dp_do_ctops",
      "developer_inline_comments": [
        {
          "start_line": 299,
          "end_line": 299,
          "text": "LLBS_PPLN_TRAP(xf);"
        },
        {
          "start_line": 305,
          "end_line": 305,
          "text": " Same for DP_SET_DROP "
        },
        {
          "start_line": 324,
          "end_line": 327,
          "text": " Note that this might result in consistency problems    * between packet and byte counts at times but this should be    * better than holding bpf-spinlock    "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf",
        " void *fa_",
        " struct dp_ct_tact *act"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_ktime_get_ns",
        "tail_call"
      ],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "lwt_xmit",
        "cgroup_sock",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "perf_event",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_do_ctops (void *ctx, struct xfi *xf, void *fa_, struct dp_ct_tact *act)\n",
        "{\n",
        "\n",
        "#ifdef HAVE_DP_FC\n",
        "    struct dp_fc_tacts *fa = fa_;\n",
        "\n",
        "#endif\n",
        "    if (!act) {\n",
        "        LL_DBG_PRINTK (\"[ACL] miss\");\n",
        "        goto ct_trk;\n",
        "    }\n",
        "    xf->pm.phit |= LLB_DP_ACL_HIT;\n",
        "    act->lts = bpf_ktime_get_ns ();\n",
        "\n",
        "#ifdef HAVE_DP_FC\n",
        "    fa->ca.cidx = act->ca.cidx;\n",
        "    fa->ca.fwrid = act->ca.fwrid;\n",
        "\n",
        "#endif\n",
        "    if (act->ca.act_type == DP_SET_DO_CT) {\n",
        "        goto ct_trk;\n",
        "    }\n",
        "    else if (act->ca.act_type == DP_SET_NOP) {\n",
        "        struct dp_rdr_act *ar = &act->port_act;\n",
        "        if (xf->pm.l4fin) {\n",
        "            ar->fr = 1;\n",
        "        }\n",
        "        if (ar->fr == 1) {\n",
        "            goto ct_trk;\n",
        "        }\n",
        "    }\n",
        "    else if (act->ca.act_type == DP_SET_RDR_PORT) {\n",
        "        struct dp_rdr_act *ar = &act->port_act;\n",
        "        if (xf->pm.l4fin) {\n",
        "            ar->fr = 1;\n",
        "        }\n",
        "        if (ar->fr == 1) {\n",
        "            goto ct_trk;\n",
        "        }\n",
        "        LLBS_PPLN_RDR_PRIO (xf);\n",
        "        xf->pm.oport = ar->oport;\n",
        "    }\n",
        "    else if (act->ca.act_type == DP_SET_SNAT || act->ca.act_type == DP_SET_DNAT) {\n",
        "        struct dp_nat_act *na;\n",
        "\n",
        "#ifdef HAVE_DP_FC\n",
        "        struct dp_fc_tact *ta = &fa->fcta[act->ca.act_type == DP_SET_SNAT ? DP_SET_SNAT : DP_SET_DNAT];\n",
        "        ta->ca.act_type = act->ca.act_type;\n",
        "        memcpy (&ta->nat_act, &act->nat_act, sizeof (act->nat_act));\n",
        "\n",
        "#endif\n",
        "        na = &act->nat_act;\n",
        "        if (xf->pm.l4fin) {\n",
        "            na->fr = 1;\n",
        "        }\n",
        "        dp_pipe_set_nat (ctx, xf, na, act->ca.act_type == DP_SET_SNAT ? 1 : 0);\n",
        "        dp_do_map_stats (ctx, xf, LL_DP_NAT_STATS_MAP, na->rid);\n",
        "        if (na->fr == 1 || na->doct) {\n",
        "            goto ct_trk;\n",
        "        }\n",
        "    }\n",
        "    else if (act->ca.act_type == DP_SET_TOCP) {\n",
        "        LLBS_PPLN_TRAPC (xf, LLB_PIPE_RC_ACL_MISS);\n",
        "    }\n",
        "    else if (act->ca.act_type == DP_SET_SESS_FWD_ACT) {\n",
        "        struct dp_sess_act *pa = &act->pdr_sess_act;\n",
        "        xf->pm.sess_id = pa->sess_id;\n",
        "    }\n",
        "    else {\n",
        "        LLBS_PPLN_DROP (xf);\n",
        "    }\n",
        "\n",
        "#ifdef HAVE_DP_EXTCT\n",
        "    if (xf->l34m.nw_proto == IPPROTO_TCP) {\n",
        "        dp_run_ctact_helper (xf, act);\n",
        "    }\n",
        "\n",
        "#endif\n",
        "    if (act->ca.fwrid != 0) {\n",
        "        if (act->ca.record) {\n",
        "            dp_record_it (ctx, xf);\n",
        "            xf->pm.dp_rec = act->ca.record;\n",
        "        }\n",
        "        dp_do_map_stats (ctx, xf, LL_DP_FW4_STATS_MAP, act->ca.fwrid);\n",
        "    }\n",
        "    dp_do_map_stats (ctx, xf, LL_DP_CT_STATS_MAP, act->ca.cidx);\n",
        "\n",
        "#if 0\n",
        "    lock_xadd (&act->ctd.pb.bytes, xf->pm.l3_len);\n",
        "    lock_xadd (&act->ctd.pb.packets, 1);\n",
        "\n",
        "#endif\n",
        "    return 0;\n",
        "ct_trk :\n",
        "    return dp_tail_call (ctx, xf, fa_, LLB_DP_CT_PGM_ID);\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_record_it",
        "dp_do_map_stats",
        "dp_pipe_set_nat",
        "dp_tail_call"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_do_ing_ct": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 338,
      "endLine": 360,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_l3fwd.c",
      "funcName": "dp_do_ing_ct",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [
        "  ct_map"
      ],
      "input": [
        "void *ctx",
        " struct xfi *xf",
        " void *fa_"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_do_ing_ct (void *ctx, struct xfi *xf, void *fa_)\n",
        "{\n",
        "    struct dp_ct_key key;\n",
        "    struct dp_ct_tact *act;\n",
        "    CT_KEY_GEN (&key, xf);\n",
        "    LL_DBG_PRINTK (\"[ACL] -- Lookup\\n\");\n",
        "    LL_DBG_PRINTK (\"[ACL] daddr %x\\n\", key.daddr[0]);\n",
        "    LL_DBG_PRINTK (\"[ACL] saddr %d\\n\", key.saddr[0]);\n",
        "    LL_DBG_PRINTK (\"[ACL] sport %d\\n\", key.sport);\n",
        "    LL_DBG_PRINTK (\"[ACL] dport %d\\n\", key.dport);\n",
        "    LL_DBG_PRINTK (\"[ACL] l4proto %d\\n\", key.l4proto);\n",
        "    xf->pm.table_id = LL_DP_CT_MAP;\n",
        "    act = bpf_map_lookup_elem (& ct_map, & key);\n",
        "    if (!act) {\n",
        "        LL_DBG_PRINTK (\"[ACL] miss\");\n",
        "    }\n",
        "    return dp_do_ctops (ctx, xf, fa_, act);\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_do_ctops"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_do_ipv4_fwd": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 362,
      "endLine": 379,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_l3fwd.c",
      "funcName": "dp_do_ipv4_fwd",
      "developer_inline_comments": [
        {
          "start_line": 365,
          "end_line": 365,
          "text": " Check tunnel initiation "
        },
        {
          "start_line": 372,
          "end_line": 374,
          "text": " If some pipeline block already set a redirect before this,     * we honor this and dont do further l3 processing      "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf",
        " void *fa_"
      ],
      "output": "staticvoid__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static void __always_inline dp_do_ipv4_fwd (void *ctx, struct xfi *xf, void *fa_)\n",
        "{\n",
        "    if (xf->tm.tunnel_id == 0 || xf->tm.tun_type != LLB_TUN_GTP) {\n",
        "        dp_do_sess4_lkup (ctx, xf);\n",
        "    }\n",
        "    if (xf->pm.phit & LLB_DP_TMAC_HIT) {\n",
        "        if ((xf->pm.pipe_act & LLB_PIPE_RDR_MASK) == 0) {\n",
        "            dp_do_rtv4 (ctx, xf, fa_);\n",
        "        }\n",
        "    }\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_do_sess4_lkup",
        "dp_do_rtv4"
      ],
      "call_depth": 5,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_do_ipv6_fwd": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 381,
      "endLine": 393,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_l3fwd.c",
      "funcName": "dp_do_ipv6_fwd",
      "developer_inline_comments": [
        {
          "start_line": 386,
          "end_line": 388,
          "text": " If some pipeline block already set a redirect before this,     * we honor this and dont do further l3 processing     "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf",
        " void *fa_"
      ],
      "output": "staticvoid__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static void __always_inline dp_do_ipv6_fwd (void *ctx, struct xfi *xf, void *fa_)\n",
        "{\n",
        "    if (xf->pm.phit & LLB_DP_TMAC_HIT) {\n",
        "        if ((xf->pm.pipe_act & LLB_PIPE_RDR_MASK) == 0) {\n",
        "            dp_do_rtv6 (ctx, xf, fa_);\n",
        "        }\n",
        "    }\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_do_rtv6"
      ],
      "call_depth": 5,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_l3_fwd": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 395,
      "endLine": 414,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_l3fwd.c",
      "funcName": "dp_l3_fwd",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf",
        " void *fa"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_l3_fwd (void *ctx, struct xfi *xf, void *fa)\n",
        "{\n",
        "    if (xf->l2m.dl_type == bpf_htons (ETH_P_IP)) {\n",
        "        if (xf->pm.nf && xf->nm.nv6 != 0) {\n",
        "            xf->nm.xlate_proto = 1;\n",
        "            dp_do_ipv6_fwd (ctx, xf, fa);\n",
        "        }\n",
        "        else {\n",
        "            dp_do_ipv4_fwd (ctx, xf, fa);\n",
        "        }\n",
        "    }\n",
        "    else if (xf->l2m.dl_type == bpf_htons (ETH_P_IPV6)) {\n",
        "        if (xf->pm.nf && xf->nm.nv6 == 0) {\n",
        "            xf->nm.xlate_proto = 1;\n",
        "            dp_do_ipv4_fwd (ctx, xf, fa);\n",
        "        }\n",
        "        else {\n",
        "            dp_do_ipv6_fwd (ctx, xf, fa);\n",
        "        }\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_do_ipv6_fwd",
        "dp_do_ipv4_fwd"
      ],
      "call_depth": 6,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_ing_l3": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 416,
      "endLine": 431,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_l3fwd.c",
      "funcName": "dp_ing_l3",
      "developer_inline_comments": [
        {
          "start_line": 420,
          "end_line": 420,
          "text": " Check termination "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf",
        " void *fa"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_ing_l3 (void *ctx, struct xfi *xf, void *fa)\n",
        "{\n",
        "    if (xf->l2m.dl_type == bpf_htons (ETH_P_IP)) {\n",
        "        if (xf->tm.tunnel_id && (xf->tm.tun_type == LLB_TUN_GTP || xf->tm.tun_type == LLB_TUN_IPIP)) {\n",
        "            dp_do_sess4_lkup (ctx, xf);\n",
        "        }\n",
        "    }\n",
        "    dp_do_ing_ct (ctx, xf, fa);\n",
        "    dp_l3_fwd (ctx, xf, fa);\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_do_sess4_lkup",
        "dp_l3_fwd",
        "dp_do_ing_ct"
      ],
      "call_depth": 7,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "log_map_update": [
    {
      "capabilities": [
        {
          "capability": "read_sys_info",
          "read_sys_info": [
            {
              "Project": "bcc",
              "FunctionName": "bpf_get_current_pid_tgid",
              "Return Type": "u64",
              "Description": "u64 bpf_get_current_pid_tgid(void) Return: current->tgid << 32 | current->pid Returns the process ID in the lower 32 bits (kernel's view of the PID, which in user space is usually presented as the thread ID), and the thread group ID in the upper 32 bits (what user space often thinks of as the PID). By directly setting this to a u32, we discard the upper 32 bits. Examples in situ: \"https://github.com/iovisor/bcc/search?q=bpf_get_current_pid_tgid+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=bpf_get_current_pid_tgid+path%3Atools&type=Code search /tools ",
              "Return": "current->tgid << 32 | current->pid Returns the process ID in the lower 32 bits (kernel's view of the PID, which in user space is usually presented as the thread ID), and the thread group ID in the upper 32 bits (what user space often thinks of as the PID)",
              "Input Prameters": [],
              "compatible_hookpoints": [
                "kprobe",
                "tracepoint",
                "perf_event",
                "raw_tracepoint",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            },
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "For tracing programs , safely attempt to read <[ size ]>(IP: 1) bytes from address <[ src ]>(IP: 2) and store the data in dst. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_probe_read",
              "Input Params": [
                "{Type: void ,Var: *dst}",
                "{Type:  u32 ,Var: size}",
                "{Type:  const void ,Var: *src}"
              ],
              "compatible_hookpoints": [
                "kprobe",
                "tracepoint",
                "perf_event",
                "raw_tracepoint",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            },
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Copy a NUL terminated string from an unsafe address <[ unsafe_ptr ]>(IP: 2) to dst. The <[ size ]>(IP: 1) should include the terminating NUL byte. In case the string length is smaller than <[ size ]>(IP: 1) , the target is not padded with further NUL bytes. If the string length is larger than <[ size ]>(IP: 1) , just size-1 bytes are copied and the last byte is set to NUL. On success , the length of the copied string is returned. This makes this helper useful in tracing programs for reading strings , and more importantly to get its length at runtime. See the following snippet: SEC(\"kprobe / sys_open\") void bpf_sys_open(struct pt_regs *ctx) { char buf[PATHLEN]; // PATHLEN is defined to 256 int res = bpf_probe_read_str(buf , sizeof(buf) , ctx->di); // Consume buf , for example push it to // userspace via bpf_perf_event_output(); we // can use res (the string length) as event // <[ size ]>(IP: 1) , after checking its boundaries. } In comparison , using bpf_probe_read() helper here instead to read the string would require to estimate the length at compile time , and would often result in copying more memory than necessary. Another useful use case is when parsing individual process arguments or individual environment variables navigating current->mm->arg_start and current->mm->env_start: using this helper and the return value , one can quickly iterate at the right offset of the memory area. ",
              "Return": " On  success,  the  strictly  positive  length  of  the string, including the                     trailing NUL character. On error, a negative value.",
              "Function Name": "bpf_probe_read_str",
              "Input Params": [
                "{Type: void ,Var: *dst}",
                "{Type:  int ,Var: size}",
                "{Type:  const void ,Var: *unsafe_ptr}"
              ],
              "compatible_hookpoints": [
                "kprobe",
                "tracepoint",
                "perf_event",
                "raw_tracepoint",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 19,
      "endLine": 72,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_mon.c",
      "funcName": "log_map_update",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": " SPDX-License-Identifier: BSD-3-Clause"
        },
        {
          "start_line": 23,
          "end_line": 23,
          "text": " Get basic info about the map"
        },
        {
          "start_line": 30,
          "end_line": 30,
          "text": " Read the key and value into byte arrays"
        },
        {
          "start_line": 31,
          "end_line": 31,
          "text": " memset the whole struct to ensure verifier is happy"
        },
        {
          "start_line": 35,
          "end_line": 35,
          "text": " Parse the map name"
        },
        {
          "start_line": 45,
          "end_line": 45,
          "text": " Set basic data"
        },
        {
          "start_line": 52,
          "end_line": 52,
          "text": " Parse the Key"
        },
        {
          "start_line": 58,
          "end_line": 58,
          "text": " Parse the Value"
        },
        {
          "start_line": 69,
          "end_line": 69,
          "text": " Write data to be processed in userspace"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct pt_regs *ctx",
        " struct bpf_map *updated_map",
        " char *pKey",
        " char *pValue",
        " enum map_updater update_type"
      ],
      "output": "staticvoid__always_inline",
      "helper": [
        "bpf_get_current_pid_tgid",
        "bpf_probe_read",
        "bpf_probe_read_str",
        "bpf_perf_event_output"
      ],
      "compatibleHookpoints": [
        "raw_tracepoint",
        "raw_tracepoint_writable",
        "kprobe",
        "perf_event",
        "tracepoint"
      ],
      "source": [
        "static void __always_inline log_map_update (struct pt_regs *ctx, struct bpf_map *updated_map, char *pKey, char *pValue, enum map_updater update_type)\n",
        "{\n",
        "    uint32_t map_id = MEM_READ (updated_map -> id);\n",
        "    uint32_t key_size = MEM_READ (updated_map -> key_size);\n",
        "    uint32_t value_size = MEM_READ (updated_map -> value_size);\n",
        "    char filter [] = {'c', 't', '_', 'm', 'a', 'p', '\\0'};\n",
        "    int i;\n",
        "    struct map_update_data out_data;\n",
        "    __builtin_memset (&out_data, 0, sizeof (out_data));\n",
        "    bpf_probe_read_str (out_data.name, BPF_NAME_LEN, updated_map->name);\n",
        "\n",
        "#pragma unroll\n",
        "    for (i = 0; i < sizeof (filter); i++) {\n",
        "        if (out_data.name[i] != filter[i]) {\n",
        "            return;\n",
        "        }\n",
        "    }\n",
        "    out_data.key_size = key_size;\n",
        "    out_data.value_size = value_size;\n",
        "    out_data.map_id = map_id;\n",
        "    out_data.pid = (unsigned int) bpf_get_current_pid_tgid ();\n",
        "    out_data.updater = update_type;\n",
        "    if (key_size <= MAX_KEY_SIZE) {\n",
        "        bpf_probe_read (out_data.key, key_size, pKey);\n",
        "    }\n",
        "    else {\n",
        "        bpf_probe_read (out_data.key, MAX_KEY_SIZE, pKey);\n",
        "    }\n",
        "    if (pValue) {\n",
        "        if (value_size <= MAX_VALUE_SIZE) {\n",
        "            bpf_probe_read (out_data.value, value_size, pValue);\n",
        "        }\n",
        "        else {\n",
        "            bpf_probe_read (out_data.value, MAX_VALUE_SIZE, pValue);\n",
        "        }\n",
        "    }\n",
        "    else {\n",
        "        out_data.value_size = 0;\n",
        "    }\n",
        "    bpf_perf_event_output (ctx, &map_events, BPF_F_CURRENT_CPU, &out_data, sizeof (out_data));\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "bpf_prog_kern_hmapupdate": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 75,
      "endLine": 84,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_mon.c",
      "funcName": "bpf_prog_kern_hmapupdate",
      "developer_inline_comments": [
        {
          "start_line": 77,
          "end_line": 77,
          "text": " Parse functions params"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct pt_regs *ctx"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "int bpf_prog_kern_hmapupdate (struct pt_regs *ctx)\n",
        "{\n",
        "    struct bpf_map *updated_map = (struct bpf_map *) PT_REGS_PARM1 (ctx);\n",
        "    char *pKey = (char *) PT_REGS_PARM2 (ctx);\n",
        "    char *pValue = (char *) PT_REGS_PARM3 (ctx);\n",
        "    log_map_update (ctx, updated_map, pKey, pValue, UPDATER_KERNEL);\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "log_map_update"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ],
  "bpf_prog_kern_hmapdelete": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 87,
      "endLine": 96,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_mon.c",
      "funcName": "bpf_prog_kern_hmapdelete",
      "developer_inline_comments": [
        {
          "start_line": 89,
          "end_line": 89,
          "text": " Parse functions params"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct pt_regs *ctx"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "int bpf_prog_kern_hmapdelete (struct pt_regs *ctx)\n",
        "{\n",
        "    struct bpf_map *updated_map = (struct bpf_map *) PT_REGS_PARM1 (ctx);\n",
        "    char *pKey = (char *) PT_REGS_PARM2 (ctx);\n",
        "    char *pValue = NULL;\n",
        "    log_map_update (ctx, updated_map, pKey, pValue, DELETE_KERNEL);\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "log_map_update"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ],
  "bpf_prog_kern_hmaplkdelete": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 99,
      "endLine": 108,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_mon.c",
      "funcName": "bpf_prog_kern_hmaplkdelete",
      "developer_inline_comments": [
        {
          "start_line": 101,
          "end_line": 101,
          "text": " Parse functions params"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct pt_regs *ctx"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "int bpf_prog_kern_hmaplkdelete (struct pt_regs *ctx)\n",
        "{\n",
        "    struct bpf_map *updated_map = (struct bpf_map *) PT_REGS_PARM1 (ctx);\n",
        "    char *pKey = (char *) PT_REGS_PARM2 (ctx);\n",
        "    char *pValue = (char *) PT_REGS_PARM3 (ctx);\n",
        "    log_map_update (ctx, updated_map, pKey, pValue, DELETE_KERNEL);\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "log_map_update"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ],
  "bpf_prog_user_mapupdate": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 113,
      "endLine": 123,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_mon.c",
      "funcName": "bpf_prog_user_mapupdate",
      "developer_inline_comments": [
        {
          "start_line": 116,
          "end_line": 116,
          "text": " 'struct fd f' is PARAM2"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct pt_regs *ctx"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "int bpf_prog_user_mapupdate (struct pt_regs *ctx)\n",
        "{\n",
        "    struct bpf_map *updated_map = (struct bpf_map *) PT_REGS_PARM1 (ctx);\n",
        "    char *pKey = (char *) PT_REGS_PARM3 (ctx);\n",
        "    char *pValue = (char *) PT_REGS_PARM4 (ctx);\n",
        "    log_map_update (ctx, updated_map, pKey, pValue, UPDATER_USERMODE);\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "log_map_update"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ],
  "bpf_prog_kern_mapupdate": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 126,
      "endLine": 135,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_mon.c",
      "funcName": "bpf_prog_kern_mapupdate",
      "developer_inline_comments": [
        {
          "start_line": 128,
          "end_line": 128,
          "text": " Parse functions params"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct pt_regs *ctx"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "int bpf_prog_kern_mapupdate (struct pt_regs *ctx)\n",
        "{\n",
        "    struct bpf_map *updated_map = (struct bpf_map *) PT_REGS_PARM1 (ctx);\n",
        "    char *pKey = (char *) PT_REGS_PARM2 (ctx);\n",
        "    char *pValue = (char *) PT_REGS_PARM3 (ctx);\n",
        "    log_map_update (ctx, updated_map, pKey, pValue, UPDATER_KERNEL);\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "log_map_update"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ],
  "bpf_prog_syscall": [
    {
      "capabilities": [
        {
          "capability": "read_sys_info",
          "read_sys_info": [
            {
              "Project": "bcc",
              "FunctionName": "bpf_get_current_pid_tgid",
              "Return Type": "u64",
              "Description": "u64 bpf_get_current_pid_tgid(void) Return: current->tgid << 32 | current->pid Returns the process ID in the lower 32 bits (kernel's view of the PID, which in user space is usually presented as the thread ID), and the thread group ID in the upper 32 bits (what user space often thinks of as the PID). By directly setting this to a u32, we discard the upper 32 bits. Examples in situ: \"https://github.com/iovisor/bcc/search?q=bpf_get_current_pid_tgid+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=bpf_get_current_pid_tgid+path%3Atools&type=Code search /tools ",
              "Return": "current->tgid << 32 | current->pid Returns the process ID in the lower 32 bits (kernel's view of the PID, which in user space is usually presented as the thread ID), and the thread group ID in the upper 32 bits (what user space often thinks of as the PID)",
              "Input Prameters": [],
              "compatible_hookpoints": [
                "kprobe",
                "tracepoint",
                "perf_event",
                "raw_tracepoint",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            },
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "For tracing programs , safely attempt to read <[ size ]>(IP: 1) bytes from address <[ src ]>(IP: 2) and store the data in dst. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_probe_read",
              "Input Params": [
                "{Type: void ,Var: *dst}",
                "{Type:  u32 ,Var: size}",
                "{Type:  const void ,Var: *src}"
              ],
              "compatible_hookpoints": [
                "kprobe",
                "tracepoint",
                "perf_event",
                "raw_tracepoint",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 151,
      "endLine": 190,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_mon.c",
      "funcName": "bpf_prog_syscall",
      "developer_inline_comments": [
        {
          "start_line": 137,
          "end_line": 137,
          "text": " The bpf syscall has 3 arguments:"
        },
        {
          "start_line": 138,
          "end_line": 138,
          "text": "  1. cmd:   The command/action to take (get a map handle, load a program, etc.)"
        },
        {
          "start_line": 139,
          "end_line": 139,
          "text": "  2. uattr: A union of structs that hold the arguments for the action"
        },
        {
          "start_line": 140,
          "end_line": 140,
          "text": "  3. size:  The size of the union"
        },
        {
          "start_line": 145,
          "end_line": 145,
          "text": " bpf_attr contains the arguments to pass to the"
        },
        {
          "start_line": 146,
          "end_line": 146,
          "text": " various bpf commands"
        },
        {
          "start_line": 153,
          "end_line": 153,
          "text": " Get The Map ID"
        },
        {
          "start_line": 157,
          "end_line": 157,
          "text": " memset the whole struct to ensure verifier is happy"
        },
        {
          "start_line": 164,
          "end_line": 164,
          "text": " We don't know any key or value size, as we are just getting a handle"
        },
        {
          "start_line": 168,
          "end_line": 168,
          "text": " Write data to perf event"
        },
        {
          "start_line": 175,
          "end_line": 175,
          "text": " memset the whole struct to ensure verifier is happy"
        },
        {
          "start_line": 182,
          "end_line": 182,
          "text": " We don't know any key or value size, as we are just getting a handle"
        },
        {
          "start_line": 186,
          "end_line": 186,
          "text": " Write data to perf event"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct syscall_bpf_args *args"
      ],
      "output": "int",
      "helper": [
        "bpf_get_current_pid_tgid",
        "bpf_probe_read",
        "bpf_perf_event_output"
      ],
      "compatibleHookpoints": [
        "raw_tracepoint",
        "raw_tracepoint_writable",
        "kprobe",
        "perf_event",
        "tracepoint"
      ],
      "source": [
        "int bpf_prog_syscall (struct syscall_bpf_args *args)\n",
        "{\n",
        "    if (args->cmd == BPF_MAP_GET_FD_BY_ID) {\n",
        "        unsigned int map_id = 0;\n",
        "        bpf_probe_read (&map_id, sizeof (map_id), &args->uattr->map_id);\n",
        "        struct map_update_data out_data;\n",
        "        __builtin_memset (&out_data, 0, sizeof (out_data));\n",
        "        out_data.map_id = map_id;\n",
        "        out_data.pid = (unsigned int) bpf_get_current_pid_tgid ();\n",
        "        out_data.updater = UPDATER_SYSCALL_GET;\n",
        "        out_data.key_size = 0;\n",
        "        out_data.value_size = 0;\n",
        "        bpf_perf_event_output (args, &map_events, BPF_F_CURRENT_CPU, &out_data, sizeof (out_data));\n",
        "    }\n",
        "    else if (args->cmd == BPF_MAP_UPDATE_ELEM) {\n",
        "        int map_fd = 0;\n",
        "        bpf_probe_read (&map_fd, sizeof (map_fd), &args->uattr->map_fd);\n",
        "        struct map_update_data out_data;\n",
        "        __builtin_memset (&out_data, 0, sizeof (out_data));\n",
        "        out_data.map_id = map_fd;\n",
        "        out_data.pid = (unsigned int) bpf_get_current_pid_tgid ();\n",
        "        out_data.updater = UPDATER_SYSCALL_UPDATE;\n",
        "        out_data.key_size = 0;\n",
        "        out_data.value_size = 0;\n",
        "        bpf_perf_event_output (args, &map_events, BPF_F_CURRENT_CPU, &out_data, sizeof (out_data));\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ],
  "dp_parse_eth": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 8,
      "endLine": 39,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_compose.c",
      "funcName": "dp_parse_eth",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 6,
          "text": " *  llb_kern_composer.c: LoxiLB Kernel eBPF packet composer/decomposer *  Copyright (C) 2022,  NetLOX <www.netlox.io> *  * SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause) "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct parser *p",
        " void *md",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_parse_eth (struct parser *p, void *md, struct xfi *xf)\n",
        "{\n",
        "    struct ethhdr *eth;\n",
        "    eth = DP_TC_PTR (p -> dbegin);\n",
        "    if (eth + 1 > p->dend) {\n",
        "        return DP_PRET_FAIL;\n",
        "    }\n",
        "    if (p->inp) {\n",
        "        xf->il2m.valid = 1;\n",
        "        memcpy (xf->il2m.dl_dst, eth->h_dest, 2 * 6);\n",
        "        memcpy (xf->pm.lkup_dmac, eth->h_dest, 6);\n",
        "        xf->il2m.dl_type = eth->h_proto;\n",
        "    }\n",
        "    else {\n",
        "        xf->l2m.valid = 1;\n",
        "        memcpy (xf->l2m.dl_dst, eth->h_dest, 2 * 6);\n",
        "        memcpy (xf->pm.lkup_dmac, eth->h_dest, 6);\n",
        "        xf->l2m.dl_type = eth->h_proto;\n",
        "    }\n",
        "    if (!ETH_TYPE_ETH2(eth->h_proto)) {\n",
        "        return DP_PRET_PASS;\n",
        "    }\n",
        "    p->dbegin = DP_ADD_PTR (eth, sizeof (*eth));\n",
        "    return DP_PRET_OK;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_parse_vlan": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 41,
      "endLine": 72,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_compose.c",
      "funcName": "dp_parse_vlan",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct parser *p",
        " void *md",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_parse_vlan (struct parser *p, void *md, struct xfi *xf)\n",
        "{\n",
        "\n",
        "#ifndef LL_TC_EBPF\n",
        "    struct vlanhdr *vlh;\n",
        "    int vlan_depth;\n",
        "    vlh = DP_TC_PTR (p -> dbegin);\n",
        "\n",
        "#endif\n",
        "\n",
        "#ifndef LL_TC_EBPF\n",
        "\n",
        "#pragma unroll\n",
        "    for (vlan_depth = 0; vlan_depth < MAX_STACKED_VLANS; vlan_depth++) {\n",
        "        if (!proto_is_vlan (xf->l2m.dl_type))\n",
        "            break;\n",
        "        if (vlh + 1 > p->dend) {\n",
        "            return DP_PRET_FAIL;\n",
        "        }\n",
        "        xf->l2m.dl_type = vlh->h_vlan_encapsulated_proto;\n",
        "        xf->l2m.vlan[vlan_depth] = vlh->h_vlan_TCI & bpf_htons (VLAN_VID_MASK);\n",
        "        vlh++;\n",
        "    }\n",
        "    p->dbegin = DP_TC_PTR (vlh);\n",
        "\n",
        "#else\n",
        "    dp_vlan_info (xf, md);\n",
        "\n",
        "#endif\n",
        "    return DP_PRET_OK;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_vlan_info",
        "proto_is_vlan"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_parse_vlan_d1": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 74,
      "endLine": 97,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_compose.c",
      "funcName": "dp_parse_vlan_d1",
      "developer_inline_comments": [
        {
          "start_line": 83,
          "end_line": 83,
          "text": " Only one inner vlan is supported "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct parser *p",
        " void *md",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_parse_vlan_d1 (struct parser *p, void *md, struct xfi *xf)\n",
        "{\n",
        "    struct vlanhdr *vlh;\n",
        "    vlh = DP_TC_PTR (p -> dbegin);\n",
        "    if (proto_is_vlan (xf->il2m.dl_type)) {\n",
        "        if (vlh + 1 > p->dend) {\n",
        "            return DP_PRET_FAIL;\n",
        "        }\n",
        "        xf->il2m.dl_type = vlh->h_vlan_encapsulated_proto;\n",
        "        xf->il2m.vlan[0] = vlh->h_vlan_TCI & bpf_htons (VLAN_VID_MASK);\n",
        "        vlh++;\n",
        "        p->dbegin = DP_TC_PTR (vlh);\n",
        "    }\n",
        "    return DP_PRET_OK;\n",
        "}\n"
      ],
      "called_function_list": [
        "proto_is_vlan"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_parse_arp": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 99,
      "endLine": 127,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_compose.c",
      "funcName": "dp_parse_arp",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct parser *p",
        " void *md",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_parse_arp (struct parser *p, void *md, struct xfi *xf)\n",
        "{\n",
        "    struct arp_ethhdr *arp = DP_TC_PTR (p->dbegin);\n",
        "    if (arp + 1 > p->dend) {\n",
        "        return DP_PRET_FAIL;\n",
        "    }\n",
        "    if (p->inp) {\n",
        "        if (arp->ar_pro == bpf_htons (ETH_P_IP) && arp->ar_pln == 4) {\n",
        "            xf->il34m.saddr4 = arp->ar_spa;\n",
        "            xf->il34m.daddr4 = arp->ar_tpa;\n",
        "        }\n",
        "        xf->il34m.nw_proto = bpf_ntohs (arp->ar_op) & 0xff;\n",
        "    }\n",
        "    else {\n",
        "        if (arp->ar_pro == bpf_htons (ETH_P_IP) && arp->ar_pln == 4) {\n",
        "            xf->l34m.saddr4 = arp->ar_spa;\n",
        "            xf->l34m.daddr4 = arp->ar_tpa;\n",
        "        }\n",
        "        xf->l34m.nw_proto = bpf_ntohs (arp->ar_op) & 0xff;\n",
        "    }\n",
        "    return DP_PRET_TRAP;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_parse_tcp": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 129,
      "endLine": 176,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_compose.c",
      "funcName": "dp_parse_tcp",
      "developer_inline_comments": [
        {
          "start_line": 138,
          "end_line": 138,
          "text": " In case of fragmented packets "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct parser *p",
        " void *md",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_parse_tcp (struct parser *p, void *md, struct xfi *xf)\n",
        "{\n",
        "    struct tcphdr *tcp = DP_TC_PTR (p->dbegin);\n",
        "    __u8 tcp_flags = 0;\n",
        "    if (tcp + 1 > p->dend) {\n",
        "        return DP_PRET_OK;\n",
        "    }\n",
        "    if (tcp->fin)\n",
        "        tcp_flags = LLB_TCP_FIN;\n",
        "    if (tcp->rst)\n",
        "        tcp_flags |= LLB_TCP_RST;\n",
        "    if (tcp->syn)\n",
        "        tcp_flags |= LLB_TCP_SYN;\n",
        "    if (tcp->psh)\n",
        "        tcp_flags |= LLB_TCP_PSH;\n",
        "    if (tcp->ack)\n",
        "        tcp_flags |= LLB_TCP_ACK;\n",
        "    if (tcp->urg)\n",
        "        tcp_flags |= LLB_TCP_URG;\n",
        "    if (p->inp) {\n",
        "        if (tcp_flags & (LLB_TCP_FIN | LLB_TCP_RST)) {\n",
        "            xf->pm.il4fin = 1;\n",
        "        }\n",
        "        xf->il34m.source = tcp->source;\n",
        "        xf->il34m.dest = tcp->dest;\n",
        "        xf->il34m.seq = tcp->seq;\n",
        "        xf->pm.itcp_flags = tcp_flags;\n",
        "    }\n",
        "    else {\n",
        "        if (tcp_flags & (LLB_TCP_FIN | LLB_TCP_RST)) {\n",
        "            xf->pm.l4fin = 1;\n",
        "        }\n",
        "        xf->l34m.source = tcp->source;\n",
        "        xf->l34m.dest = tcp->dest;\n",
        "        xf->l34m.seq = tcp->seq;\n",
        "        xf->pm.tcp_flags = tcp_flags;\n",
        "    }\n",
        "    return DP_PRET_OK;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_parse_icmp": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 178,
      "endLine": 200,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_compose.c",
      "funcName": "dp_parse_icmp",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct parser *p",
        " void *md",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_parse_icmp (struct parser *p, void *md, struct xfi *xf)\n",
        "{\n",
        "    struct icmphdr *icmp = DP_TC_PTR (p->dbegin);\n",
        "    if (icmp + 1 > p->dend) {\n",
        "        return DP_PRET_OK;\n",
        "    }\n",
        "    if ((icmp->type == ICMP_ECHOREPLY || icmp->type == ICMP_ECHO)) {\n",
        "        if (p->inp) {\n",
        "            xf->il34m.source = icmp->un.echo.id;\n",
        "            xf->il34m.dest = icmp->un.echo.id;\n",
        "        }\n",
        "        else {\n",
        "            xf->l34m.source = icmp->un.echo.id;\n",
        "            xf->l34m.dest = icmp->un.echo.id;\n",
        "        }\n",
        "    }\n",
        "    return DP_PRET_OK;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_parse_iudp": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 202,
      "endLine": 217,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_compose.c",
      "funcName": "dp_parse_iudp",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct parser *p",
        " void *md",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_parse_iudp (struct parser *p, void *md, struct xfi *xf)\n",
        "{\n",
        "    struct udphdr *udp = DP_TC_PTR (p->dbegin);\n",
        "    if (udp + 1 > p->dend) {\n",
        "        return DP_PRET_OK;\n",
        "    }\n",
        "    xf->il34m.source = udp->source;\n",
        "    xf->il34m.dest = udp->dest;\n",
        "    return DP_PRET_OK;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_parse_sctp": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 219,
      "endLine": 260,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_compose.c",
      "funcName": "dp_parse_sctp",
      "developer_inline_comments": [
        {
          "start_line": 241,
          "end_line": 241,
          "text": " Chunks need not be present in all sctp packets "
        },
        {
          "start_line": 246,
          "end_line": 246,
          "text": " Parsing only one-level of chunk "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct parser *p",
        " void *md",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_parse_sctp (struct parser *p, void *md, struct xfi *xf)\n",
        "{\n",
        "    struct sctp_dch *c;\n",
        "    struct sctphdr *sctp = DP_TC_PTR (p->dbegin);\n",
        "    if (sctp + 1 > p->dend) {\n",
        "        return DP_PRET_OK;\n",
        "    }\n",
        "    if (p->inp) {\n",
        "        xf->il34m.source = sctp->source;\n",
        "        xf->il34m.dest = sctp->dest;\n",
        "    }\n",
        "    else {\n",
        "        xf->l34m.source = sctp->source;\n",
        "        xf->l34m.dest = sctp->dest;\n",
        "    }\n",
        "    c = DP_TC_PTR (DP_ADD_PTR (sctp, sizeof (* sctp)));\n",
        "    if (c + 1 > p->dend) {\n",
        "        return DP_PRET_OK;\n",
        "    }\n",
        "    if (c->type == SCTP_ERROR || c->type == SCTP_ABORT || c->type == SCTP_SHUT || c->type == SCTP_SHUT_ACK || c->type == SCTP_SHUT_COMPLETE) {\n",
        "        if (p->inp) {\n",
        "            xf->pm.il4fin = 1;\n",
        "        }\n",
        "        else {\n",
        "            xf->pm.l4fin = 1;\n",
        "        }\n",
        "    }\n",
        "    return DP_PRET_OK;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_parse_icmp6": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 262,
      "endLine": 288,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_compose.c",
      "funcName": "dp_parse_icmp6",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct parser *p",
        " void *md",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_parse_icmp6 (struct parser *p, void *md, struct xfi *xf)\n",
        "{\n",
        "    struct icmp6hdr *icmp6 = DP_TC_PTR (p->dbegin);\n",
        "    if (icmp6 + 1 > p->dend) {\n",
        "        return DP_PRET_OK;\n",
        "    }\n",
        "    if ((icmp6->icmp6_type == ICMPV6_ECHO_REPLY || icmp6->icmp6_type == ICMPV6_ECHO_REQUEST)) {\n",
        "        if (p->inp) {\n",
        "            xf->il34m.source = icmp6->icmp6_dataun.u_echo.identifier;\n",
        "            xf->il34m.dest = icmp6->icmp6_dataun.u_echo.identifier;\n",
        "        }\n",
        "        else {\n",
        "            xf->l34m.source = icmp6->icmp6_dataun.u_echo.identifier;\n",
        "            xf->l34m.dest = icmp6->icmp6_dataun.u_echo.identifier;\n",
        "        }\n",
        "    }\n",
        "    else if (icmp6->icmp6_type >= 133 && icmp6->icmp6_type <= 137) {\n",
        "        return DP_PRET_PASS;\n",
        "    }\n",
        "    return DP_PRET_OK;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_parse_ipv4_d1": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 290,
      "endLine": 343,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_compose.c",
      "funcName": "dp_parse_ipv4_d1",
      "developer_inline_comments": [
        {
          "start_line": 315,
          "end_line": 319,
          "text": " Earlier we used to have the following check here :   * !ip_is_fragment(iph) || ip_is_first_fragment(iph))   * But it seems to be unncessary as proper bound checking   * is already taken care by eBPF verifier   "
        },
        {
          "start_line": 333,
          "end_line": 333,
          "text": " Let xfrm handle it "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct parser *p",
        " void *md",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_parse_ipv4_d1 (struct parser *p, void *md, struct xfi *xf)\n",
        "{\n",
        "    struct iphdr *iph = DP_TC_PTR (p->dbegin);\n",
        "    int iphl = iph->ihl << 2;\n",
        "    if (iph + 1 > p->dend) {\n",
        "        return DP_PRET_FAIL;\n",
        "    }\n",
        "    if (DP_ADD_PTR (iph, iphl) > p->dend) {\n",
        "        return DP_PRET_FAIL;\n",
        "    }\n",
        "    xf->pm.il3_len = bpf_ntohs (iph->tot_len);\n",
        "    xf->pm.il3_plen = xf->pm.il3_len - iphl;\n",
        "    xf->il34m.valid = 1;\n",
        "    xf->il34m.tos = iph->tos & 0xfc;\n",
        "    xf->il34m.nw_proto = iph->protocol;\n",
        "    xf->il34m.saddr4 = iph->saddr;\n",
        "    xf->il34m.daddr4 = iph->daddr;\n",
        "    xf->pm.il4_off = DP_DIFF_PTR (DP_ADD_PTR (iph, iphl), p->start);\n",
        "    p->dbegin = DP_ADD_PTR (iph, iphl);\n",
        "    if (xf->il34m.nw_proto == IPPROTO_TCP) {\n",
        "        return dp_parse_tcp (p, md, xf);\n",
        "    }\n",
        "    else if (xf->il34m.nw_proto == IPPROTO_UDP) {\n",
        "        return dp_parse_iudp (p, md, xf);\n",
        "    }\n",
        "    else if (xf->il34m.nw_proto == IPPROTO_SCTP) {\n",
        "        return dp_parse_sctp (p, md, xf);\n",
        "    }\n",
        "    else if (xf->il34m.nw_proto == IPPROTO_ICMP) {\n",
        "        return dp_parse_icmp (p, md, xf);\n",
        "    }\n",
        "    else if (xf->il34m.nw_proto == IPPROTO_ESP || xf->il34m.nw_proto == IPPROTO_AH) {\n",
        "        return DP_PRET_PASS;\n",
        "    }\n",
        "    if (ip_is_fragment (iph)) {\n",
        "        xf->il34m.source = 0;\n",
        "        xf->il34m.dest = 0;\n",
        "    }\n",
        "    return DP_PRET_OK;\n",
        "}\n"
      ],
      "called_function_list": [
        "ip_is_fragment",
        "dp_parse_tcp",
        "dp_parse_sctp",
        "dp_parse_iudp",
        "dp_parse_icmp"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_parse_ipv6_d1": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 345,
      "endLine": 382,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_compose.c",
      "funcName": "dp_parse_ipv6_d1",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct parser *p",
        " void *md",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_parse_ipv6_d1 (struct parser *p, void *md, struct xfi *xf)\n",
        "{\n",
        "    struct ipv6hdr *ip6 = DP_TC_PTR (p->dbegin);\n",
        "    if (ip6 + 1 > p->dend) {\n",
        "        return DP_PRET_FAIL;\n",
        "    }\n",
        "    if (ipv6_addr_is_multicast (&ip6->daddr) || ipv6_addr_is_multicast (&ip6->saddr)) {\n",
        "        return DP_PRET_PASS;\n",
        "    }\n",
        "    xf->pm.il3_plen = bpf_ntohs (ip6->payload_len);\n",
        "    xf->pm.il3_len = xf->pm.il3_plen + sizeof (*ip6);\n",
        "    xf->il34m.valid = 1;\n",
        "    xf->il34m.tos = ((ip6->priority << 4) | ((ip6->flow_lbl[0] & 0xf0) >> 4)) & 0xfc;\n",
        "    xf->il34m.nw_proto = ip6->nexthdr;\n",
        "    memcpy (&xf->il34m.saddr, &ip6->saddr, sizeof (ip6->saddr));\n",
        "    memcpy (&xf->il34m.daddr, &ip6->daddr, sizeof (ip6->daddr));\n",
        "    xf->pm.il4_off = DP_DIFF_PTR (DP_ADD_PTR (ip6, sizeof (*ip6)), p->start);\n",
        "    p->dbegin = DP_ADD_PTR (ip6, sizeof (*ip6));\n",
        "    if (xf->il34m.nw_proto == IPPROTO_TCP) {\n",
        "        return dp_parse_tcp (p, md, xf);\n",
        "    }\n",
        "    else if (xf->il34m.nw_proto == IPPROTO_UDP) {\n",
        "        return dp_parse_iudp (p, md, xf);\n",
        "    }\n",
        "    else if (xf->l34m.nw_proto == IPPROTO_ICMPV6) {\n",
        "        return dp_parse_icmp6 (p, md, xf);\n",
        "    }\n",
        "    return DP_PRET_OK;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_parse_tcp",
        "dp_parse_icmp6",
        "dp_parse_iudp",
        "ipv6_addr_is_multicast"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_parse_d1": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 384,
      "endLine": 418,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_compose.c",
      "funcName": "dp_parse_d1",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct parser *p",
        " void *md",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_parse_d1 (struct parser *p, void *md, struct xfi *xf)\n",
        "{\n",
        "    int ret = 0;\n",
        "    if (p->skip_l2) {\n",
        "        if (xf->il2m.dl_type == 0)\n",
        "            return DP_PRET_TRAP;\n",
        "        goto proc_inl3;\n",
        "    }\n",
        "    if ((ret = dp_parse_eth (p, md, xf))) {\n",
        "        return ret;\n",
        "    }\n",
        "    if ((ret = dp_parse_vlan_d1 (p, md, xf))) {\n",
        "        return ret;\n",
        "    }\n",
        "proc_inl3 :\n",
        "    xf->pm.il3_off = DP_DIFF_PTR (p->dbegin, p->start);\n",
        "    if (xf->il2m.dl_type == bpf_htons (ETH_P_ARP)) {\n",
        "        ret = dp_parse_arp (p, md, xf);\n",
        "    }\n",
        "    else if (xf->il2m.dl_type == bpf_htons (ETH_P_IP)) {\n",
        "        ret = dp_parse_ipv4_d1 (p, md, xf);\n",
        "    }\n",
        "    else if (xf->il2m.dl_type == bpf_htons (ETH_P_IPV6)) {\n",
        "        if (p->skip_v6 == 0)\n",
        "            ret = dp_parse_ipv6_d1 (p, md, xf);\n",
        "    }\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_parse_ipv4_d1",
        "dp_parse_ipv6_d1",
        "dp_parse_eth",
        "dp_parse_arp",
        "dp_parse_vlan_d1"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_parse_gtp_ehdr": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 420,
      "endLine": 442,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_compose.c",
      "funcName": "dp_parse_gtp_ehdr",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *nh",
        " void *dend"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_parse_gtp_ehdr (void *nh, void *dend)\n",
        "{\n",
        "    uint8_t *nhl = DP_TC_PTR (nh);\n",
        "    uint8_t *neh;\n",
        "    int elen;\n",
        "    if (nhl + 1 > dend) {\n",
        "        return DP_PRET_FAIL;\n",
        "    }\n",
        "    elen = *nhl << 2;\n",
        "    if (nhl + elen > dend) {\n",
        "        return DP_PRET_FAIL;\n",
        "    }\n",
        "    neh = nhl + (elen - 1);\n",
        "    if (*neh)\n",
        "        return elen;\n",
        "    return DP_PRET_OK;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ],
  "dp_parse_gtp": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 460,
      "endLine": 597,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_compose.c",
      "funcName": "dp_parse_gtp",
      "developer_inline_comments": [
        {
          "start_line": 447,
          "end_line": 447,
          "text": " Index CPU idx "
        },
        {
          "start_line": 499,
          "end_line": 499,
          "text": " PDU session container is always first "
        },
        {
          "start_line": 544,
          "end_line": 544,
          "text": " Parse maximum GTP_MAX_EXTH  gtp extension headers "
        }
      ],
      "updateMaps": [],
      "readMaps": [
        "  gparser"
      ],
      "input": [
        "struct parser *p",
        " void *md",
        " void *inp",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_parse_gtp (struct parser *p, void *md, void *inp, struct xfi *xf)\n",
        "{\n",
        "    int var = 0;\n",
        "    struct gtp_parser *gp;\n",
        "    gp = bpf_map_lookup_elem (& gparser, & var);\n",
        "    if (!gp) {\n",
        "        goto drop;\n",
        "    }\n",
        "    gp->hlen = GTP_HDR_LEN;\n",
        "    gp->gh = DP_TC_PTR (inp);\n",
        "    if (gp->gh + 1 > p->dend) {\n",
        "        goto drop;\n",
        "    }\n",
        "    if (gp->gh->ver != GTP_VER_1) {\n",
        "        return DP_PRET_OK;\n",
        "    }\n",
        "    if (gp->gh->espn)\n",
        "        gp->hlen += sizeof (struct gtp_v1_ehdr);\n",
        "    xf->tm.tunnel_id = bpf_ntohl (gp->gh->teid);\n",
        "    xf->tm.tun_type = LLB_TUN_GTP;\n",
        "    if (gp->gh->espn & GTP_EXT_FM) {\n",
        "        gp->geh = DP_ADD_PTR (gp->gh, sizeof (struct gtp_v1_hdr));\n",
        "        if (gp->geh + 1 > p->dend) {\n",
        "            goto drop;\n",
        "        }\n",
        "        gp->nh = DP_ADD_PTR (gp->geh, sizeof (struct gtp_v1_ehdr));\n",
        "        if (gp->geh->next_hdr == GTP_NH_PDU_SESS) {\n",
        "            struct gtp_pdu_sess_cmnhdr *pch = DP_TC_PTR (gp->nh);\n",
        "            if (pch + 1 > p->dend) {\n",
        "                goto drop;\n",
        "            }\n",
        "            if (pch->len != 1) {\n",
        "                goto drop;\n",
        "            }\n",
        "            if (pch->pdu_type == GTP_PDU_SESS_UL) {\n",
        "                struct gtp_ul_pdu_sess_hdr *pul = DP_TC_PTR (pch);\n",
        "                if (pul + 1 > p->dend) {\n",
        "                    goto drop;\n",
        "                }\n",
        "                gp->hlen += sizeof (*pul);\n",
        "                xf->qm.qfi = pul->qfi;\n",
        "                gp->nh = pul + 1;\n",
        "                if (pul->next_hdr == 0)\n",
        "                    goto done;\n",
        "            }\n",
        "            else if (pch->pdu_type == GTP_PDU_SESS_DL) {\n",
        "                struct gtp_dl_pdu_sess_hdr *pdl = DP_TC_PTR (pch);\n",
        "                if (pdl + 1 > p->dend) {\n",
        "                    goto drop;\n",
        "                }\n",
        "                gp->hlen += sizeof (*pdl);\n",
        "                xf->qm.qfi = pdl->qfi;\n",
        "                gp->nh = pdl + 1;\n",
        "                if (pdl->next_hdr == 0)\n",
        "                    goto done;\n",
        "            }\n",
        "            else {\n",
        "                goto drop;\n",
        "            }\n",
        "        }\n",
        "        gp->nhl = DP_TC_PTR (gp->nh);\n",
        "        for (var = 0; var < GTP_MAX_EXTH; var++) {\n",
        "            if (gp->nhl + 1 > p->dend) {\n",
        "                goto drop;\n",
        "            }\n",
        "            gp->elen = *(gp->nhl) << 2;\n",
        "            gp->neh = gp->nhl + (gp->elen - 1);\n",
        "            if (gp->neh + 1 > p->dend) {\n",
        "                goto drop;\n",
        "            }\n",
        "            gp->hlen += gp->elen;\n",
        "            if (*(gp->neh) == 0)\n",
        "                break;\n",
        "            gp->nhl = DP_ADD_PTR (gp->nhl, gp->elen);\n",
        "        }\n",
        "        if (var >= GTP_MAX_EXTH) {\n",
        "            goto pass;\n",
        "        }\n",
        "    }\n",
        "done :\n",
        "    gp->gtp_next = DP_ADD_PTR (gp->gh, gp->hlen);\n",
        "    xf->pm.tun_off = DP_DIFF_PTR (gp->gtp_next, DP_PDATA (md));\n",
        "    gp->neh = DP_TC_PTR (gp->gtp_next);\n",
        "    if (gp->neh + 1 > p->dend) {\n",
        "        return 0;\n",
        "    }\n",
        "    var = ((*(gp->neh) & 0xf0) >> 4);\n",
        "    if (var == 4) {\n",
        "        xf->il2m.dl_type = bpf_htons (ETH_P_IP);\n",
        "    }\n",
        "    else if (var == 6) {\n",
        "        xf->il2m.dl_type = bpf_htons (ETH_P_IPV6);\n",
        "    }\n",
        "    else {\n",
        "        return DP_PRET_OK;\n",
        "    }\n",
        "    p->inp = 1;\n",
        "    p->skip_l2 = 1;\n",
        "    p->dbegin = gp->gtp_next;\n",
        "    return dp_parse_d1 (p, md, xf);\n",
        "drop :\n",
        "    return DP_PRET_FAIL;\n",
        "pass :\n",
        "    return DP_PRET_PASS;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_parse_d1"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_parse_outer_udp": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 599,
      "endLine": 643,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_compose.c",
      "funcName": "dp_parse_outer_udp",
      "developer_inline_comments": [
        {
          "start_line": 641,
          "end_line": 641,
          "text": " Not reached "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct parser *p",
        " void *md",
        " void *udp_next",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_parse_outer_udp (struct parser *p, void *md, void *udp_next, struct xfi *xf)\n",
        "{\n",
        "    struct vxlanhdr *vx;\n",
        "    struct gtp_v1_hdr *gh;\n",
        "    void *dend = DP_TC_PTR (DP_PDATA_END (md));\n",
        "    void *vx_next;\n",
        "    switch (xf->l34m.dest) {\n",
        "    case bpf_htons (VXLAN_OUDP_DPORT) :\n",
        "        vx = DP_TC_PTR (udp_next);\n",
        "        if (vx + 1 > dend) {\n",
        "            return DP_PRET_FAIL;\n",
        "        }\n",
        "        xf->tm.tunnel_id = (bpf_ntohl (vx->vx_vni)) >> 8 & 0xfffffff;\n",
        "        xf->tm.tun_type = LLB_TUN_VXLAN;\n",
        "        vx_next = vx + 1;\n",
        "        xf->pm.tun_off = DP_DIFF_PTR (vx_next, DP_PDATA (md));\n",
        "        LL_DBG_PRINTK (\"[PRSR] UDP VXLAN %u\\n\", xf->tm.tunnel_id);\n",
        "        p->inp = 1;\n",
        "        p->skip_l2 = 0;\n",
        "        p->dbegin = vx_next;\n",
        "        return dp_parse_d1 (p, md, xf);\n",
        "        break;\n",
        "    case bpf_htons (GTPU_UDP_DPORT) :\n",
        "    case bpf_htons (GTPC_UDP_DPORT) :\n",
        "        gh = DP_TC_PTR (udp_next);\n",
        "        if (gh + 1 > dend) {\n",
        "            return DP_PRET_FAIL;\n",
        "        }\n",
        "        return dp_parse_gtp (p, md, gh, xf);\n",
        "        break;\n",
        "    default :\n",
        "        return DP_PRET_OK;\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_parse_gtp",
        "dp_parse_d1"
      ],
      "call_depth": 4,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_parse_llb": [
    {
      "capabilities": [
        {
          "capability": "update_pkt",
          "update_pkt": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Adjust the address pointed by xdp_md->data_meta by <[ delta ]>(IP: 1) (which can be positive or negative). Note that this operation modifies the address stored in xdp_md->data , so the latter must be loaded only after the helper has been called. The use of xdp_md->data_meta is optional and programs are not required to use it. The rationale is that when the packet is processed with XDP (e. g. as DoS filter) , it is possible to push further meta data along with it before passing to the stack , and to give the guarantee that an ingress eBPF program attached as a TC classifier on the same device can pick this up for further post-processing. Since TC works with socket buffers , it remains possible to set from XDP the mark or priority pointers , or other pointers for the socket buffer. Having this scratch space generic and programmable allows for more flexibility as the user is free to store whatever meta data they need. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_xdp_adjust_meta",
              "Input Params": [
                "{Type: struct xdp_buff ,Var: *xdp_md}",
                "{Type:  int ,Var: delta}"
              ],
              "compatible_hookpoints": [
                "xdp"
              ],
              "capabilities": [
                "update_pkt"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 645,
      "endLine": 696,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_compose.c",
      "funcName": "dp_parse_llb",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct parser *p",
        " void *md",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_xdp_adjust_meta"
      ],
      "compatibleHookpoints": [
        "xdp"
      ],
      "source": [
        "static int __always_inline dp_parse_llb (struct parser *p, void *md, struct xfi *xf)\n",
        "{\n",
        "    struct ethhdr *eth;\n",
        "    struct llb_ethhdr *llb = DP_TC_PTR (p->dbegin);\n",
        "    LL_DBG_PRINTK (\"[PRSR] LLB \\n\");\n",
        "\n",
        "#ifdef LL_TC_EBPF\n",
        "    return DP_PRET_FAIL;\n",
        "\n",
        "#endif\n",
        "    if (DP_TC_PTR (p->dbegin) + (sizeof (struct ethhdr) + sizeof (*llb)) > p->dend) {\n",
        "        return DP_PRET_FAIL;\n",
        "    }\n",
        "    llb = DP_ADD_PTR (p -> dbegin, sizeof (struct ethhdr));\n",
        "    xf->pm.oport = (llb->oport);\n",
        "    xf->pm.iport = (llb->iport);\n",
        "    eth = DP_ADD_PTR (p -> dbegin, (int) sizeof (struct llb_ethhdr));\n",
        "    memcpy (eth->h_dest, xf->l2m.dl_dst, 6);\n",
        "    memcpy (eth->h_source, xf->l2m.dl_src, 6);\n",
        "    eth->h_proto = llb->ntype;\n",
        "    if (dp_remove_l2 (md, (int) sizeof (*llb))) {\n",
        "        return DP_PRET_FAIL;\n",
        "    }\n",
        "\n",
        "#ifndef LL_TC_EBPF\n",
        "    if (1) {\n",
        "        struct ll_xmdi *xm;\n",
        "        if (bpf_xdp_adjust_meta (md, -(int) sizeof (*xm)) < 0) {\n",
        "            LL_DBG_PRINTK (\"[PRSR] adjust meta fail\\n\");\n",
        "            return DP_PRET_FAIL;\n",
        "        }\n",
        "        p->dbegin = DP_TC_PTR (DP_PDATA (md));\n",
        "        xm = DP_TC_PTR (DP_MDATA (md));\n",
        "        if (xm + 1 > p->dbegin) {\n",
        "            return DP_PRET_FAIL;\n",
        "        }\n",
        "        xm->pi.oport = xf->pm.oport;\n",
        "        xm->pi.iport = xf->pm.iport;\n",
        "        xm->pi.skip = 0;\n",
        "    }\n",
        "\n",
        "#endif\n",
        "    return DP_PRET_OK;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_remove_l2"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_parse_udp": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 698,
      "endLine": 717,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_compose.c",
      "funcName": "dp_parse_udp",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct parser *p",
        " void *md",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_parse_udp (struct parser *p, void *md, struct xfi *xf)\n",
        "{\n",
        "    struct udphdr *udp = DP_TC_PTR (p->dbegin);\n",
        "    if (udp + 1 > p->dend) {\n",
        "        return DP_PRET_OK;\n",
        "    }\n",
        "    xf->l34m.source = udp->source;\n",
        "    xf->l34m.dest = udp->dest;\n",
        "    if (dp_pkt_is_l2mcbc (xf, md) == 1) {\n",
        "        LLBS_PPLN_TRAP (xf);\n",
        "    }\n",
        "    return dp_parse_outer_udp (p, md, udp + 1, xf);\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_pkt_is_l2mcbc",
        "dp_parse_outer_udp"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_parse_ipip": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 719,
      "endLine": 748,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_compose.c",
      "funcName": "dp_parse_ipip",
      "developer_inline_comments": [
        {
          "start_line": 741,
          "end_line": 741,
          "text": " No real use"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct parser *p",
        " void *md",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_parse_ipip (struct parser *p, void *md, struct xfi *xf)\n",
        "{\n",
        "    struct iphdr *ip = DP_TC_PTR (p->dbegin);\n",
        "    int iphl = ip->ihl << 2;\n",
        "    if (ip + 1 > p->dend) {\n",
        "        return DP_PRET_OK;\n",
        "    }\n",
        "    if (DP_ADD_PTR (ip, iphl) > p->dend) {\n",
        "        return DP_PRET_FAIL;\n",
        "    }\n",
        "    if (ip->version == 4) {\n",
        "        xf->il2m.dl_type = bpf_htons (ETH_P_IP);\n",
        "    }\n",
        "    else {\n",
        "        return DP_PRET_OK;\n",
        "    }\n",
        "    xf->tm.tunnel_id = 1;\n",
        "    xf->tm.tun_type = LLB_TUN_IPIP;\n",
        "    p->inp = 1;\n",
        "    p->skip_l2 = 1;\n",
        "    p->dbegin = ip;\n",
        "    return dp_parse_d1 (p, md, xf);\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_parse_d1"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_parse_ipv4": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 750,
      "endLine": 805,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_compose.c",
      "funcName": "dp_parse_ipv4",
      "developer_inline_comments": [
        {
          "start_line": 775,
          "end_line": 779,
          "text": " Earlier we used to have the following check here :   * !ip_is_fragment(iph) || ip_is_first_fragment(iph))   * But it seems to be unncessary as proper bound checking   * is already taken care by eBPF verifier   "
        },
        {
          "start_line": 795,
          "end_line": 795,
          "text": " Let xfrm handle it "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct parser *p",
        " void *md",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_parse_ipv4 (struct parser *p, void *md, struct xfi *xf)\n",
        "{\n",
        "    struct iphdr *iph = DP_TC_PTR (p->dbegin);\n",
        "    int iphl = iph->ihl << 2;\n",
        "    if (iph + 1 > p->dend) {\n",
        "        return DP_PRET_FAIL;\n",
        "    }\n",
        "    if (DP_ADD_PTR (iph, iphl) > p->dend) {\n",
        "        return DP_PRET_FAIL;\n",
        "    }\n",
        "    xf->pm.l3_len = bpf_ntohs (iph->tot_len);\n",
        "    xf->pm.l3_plen = xf->pm.l3_len - iphl;\n",
        "    xf->l34m.valid = 1;\n",
        "    xf->l34m.tos = iph->tos & 0xfc;\n",
        "    xf->l34m.nw_proto = iph->protocol;\n",
        "    xf->l34m.saddr4 = iph->saddr;\n",
        "    xf->l34m.daddr4 = iph->daddr;\n",
        "    xf->pm.l4_off = DP_DIFF_PTR (DP_ADD_PTR (iph, iphl), p->start);\n",
        "    p->dbegin = DP_ADD_PTR (iph, iphl);\n",
        "    if (xf->l34m.nw_proto == IPPROTO_TCP) {\n",
        "        return dp_parse_tcp (p, md, xf);\n",
        "    }\n",
        "    else if (xf->l34m.nw_proto == IPPROTO_UDP) {\n",
        "        return dp_parse_udp (p, md, xf);\n",
        "    }\n",
        "    else if (xf->l34m.nw_proto == IPPROTO_SCTP) {\n",
        "        return dp_parse_sctp (p, md, xf);\n",
        "    }\n",
        "    else if (xf->l34m.nw_proto == IPPROTO_ICMP) {\n",
        "        return dp_parse_icmp (p, md, xf);\n",
        "    }\n",
        "    else if (xf->l34m.nw_proto == IPPROTO_IPIP) {\n",
        "        return dp_parse_ipip (p, md, xf);\n",
        "    }\n",
        "    else if (xf->l34m.nw_proto == IPPROTO_ESP || xf->l34m.nw_proto == IPPROTO_AH) {\n",
        "        return DP_PRET_PASS;\n",
        "    }\n",
        "    if (ip_is_fragment (iph)) {\n",
        "        xf->l34m.source = 0;\n",
        "        xf->l34m.dest = 0;\n",
        "    }\n",
        "    return DP_PRET_OK;\n",
        "}\n"
      ],
      "called_function_list": [
        "ip_is_fragment",
        "dp_parse_ipip",
        "dp_parse_tcp",
        "dp_parse_sctp",
        "dp_parse_udp",
        "dp_parse_icmp"
      ],
      "call_depth": 4,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_parse_ipv6": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 807,
      "endLine": 850,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_compose.c",
      "funcName": "dp_parse_ipv6",
      "developer_inline_comments": [
        {
          "start_line": 846,
          "end_line": 846,
          "text": " Let xfrm handle it "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct parser *p",
        " void *md",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_parse_ipv6 (struct parser *p, void *md, struct xfi *xf)\n",
        "{\n",
        "    struct ipv6hdr *ip6 = DP_TC_PTR (p->dbegin);\n",
        "    if (ip6 + 1 > p->dend) {\n",
        "        return DP_PRET_FAIL;\n",
        "    }\n",
        "    if (ipv6_addr_is_multicast (&ip6->daddr) || ipv6_addr_is_multicast (&ip6->saddr)) {\n",
        "        return DP_PRET_PASS;\n",
        "    }\n",
        "    xf->pm.l3_plen = bpf_ntohs (ip6->payload_len);\n",
        "    xf->pm.l3_len = xf->pm.l3_plen + sizeof (*ip6);\n",
        "    xf->l34m.valid = 1;\n",
        "    xf->l34m.tos = ((ip6->priority << 4) | ((ip6->flow_lbl[0] & 0xf0) >> 4)) & 0xfc;\n",
        "    xf->l34m.nw_proto = ip6->nexthdr;\n",
        "    memcpy (&xf->l34m.saddr, &ip6->saddr, sizeof (ip6->saddr));\n",
        "    memcpy (&xf->l34m.daddr, &ip6->daddr, sizeof (ip6->daddr));\n",
        "    xf->pm.l4_off = DP_DIFF_PTR (DP_ADD_PTR (ip6, sizeof (*ip6)), p->start);\n",
        "    p->dbegin = DP_ADD_PTR (ip6, sizeof (*ip6));\n",
        "    if (xf->l34m.nw_proto == IPPROTO_TCP) {\n",
        "        return dp_parse_tcp (p, md, xf);\n",
        "    }\n",
        "    else if (xf->l34m.nw_proto == IPPROTO_UDP) {\n",
        "        return dp_parse_udp (p, md, xf);\n",
        "    }\n",
        "    else if (xf->l34m.nw_proto == IPPROTO_SCTP) {\n",
        "        return dp_parse_sctp (p, md, xf);\n",
        "    }\n",
        "    else if (xf->l34m.nw_proto == IPPROTO_ICMPV6) {\n",
        "        return dp_parse_icmp6 (p, md, xf);\n",
        "    }\n",
        "    else if (xf->l34m.nw_proto == IPPROTO_ESP || xf->l34m.nw_proto == IPPROTO_AH) {\n",
        "        return DP_PRET_PASS;\n",
        "    }\n",
        "    return DP_PRET_OK;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_parse_tcp",
        "dp_parse_icmp6",
        "dp_parse_sctp",
        "dp_parse_udp",
        "ipv6_addr_is_multicast"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_parse_d0": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 852,
      "endLine": 923,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_compose.c",
      "funcName": "dp_parse_d0",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *md",
        " struct xfi *xf",
        " int skip_v6"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_parse_d0 (void *md, struct xfi *xf, int skip_v6)\n",
        "{\n",
        "    int ret = 0;\n",
        "    struct parser p;\n",
        "    p.inp = 0;\n",
        "    p.skip_l2 = 0;\n",
        "    p.skip_v6 = skip_v6;\n",
        "    p.start = DP_TC_PTR (DP_PDATA (md));\n",
        "    p.dbegin = DP_TC_PTR (p.start);\n",
        "    p.dend = DP_TC_PTR (DP_PDATA_END (md));\n",
        "    xf->pm.py_bytes = DP_DIFF_PTR (p.dend, p.dbegin);\n",
        "    if ((ret = dp_parse_eth (&p, md, xf))) {\n",
        "        goto handle_excp;\n",
        "    }\n",
        "    if (DP_NEED_MIRR (md)) {\n",
        "        xf->pm.mirr = DP_GET_MIRR (md);\n",
        "        LL_DBG_PRINTK (\"[PRSR] LB %d %d\\n\", xf->pm.mirr, DP_IFI (md));\n",
        "    }\n",
        "\n",
        "#ifdef HAVE_DP_IPC\n",
        "    if (xdp2tc_has_xmd (md, xf)) {\n",
        "        return 1;\n",
        "    }\n",
        "\n",
        "#endif\n",
        "    if ((ret = dp_parse_vlan (&p, md, xf))) {\n",
        "        goto handle_excp;\n",
        "    }\n",
        "    xf->pm.l3_off = DP_DIFF_PTR (p.dbegin, p.start);\n",
        "    if (xf->l2m.dl_type == bpf_htons (ETH_P_ARP)) {\n",
        "        ret = dp_parse_arp (& p, md, xf);\n",
        "    }\n",
        "    else if (xf->l2m.dl_type == bpf_htons (ETH_P_IP)) {\n",
        "        ret = dp_parse_ipv4 (& p, md, xf);\n",
        "    }\n",
        "    else if (xf->l2m.dl_type == bpf_htons (ETH_P_IPV6)) {\n",
        "        if (p.skip_v6 == 1) {\n",
        "            return 0;\n",
        "        }\n",
        "        ret = dp_parse_ipv6 (& p, md, xf);\n",
        "    }\n",
        "    else if (xf->l2m.dl_type == bpf_htons (ETH_TYPE_LLB)) {\n",
        "        ret = dp_parse_llb (& p, md, xf);\n",
        "    }\n",
        "    if (ret != 0) {\n",
        "        goto handle_excp;\n",
        "    }\n",
        "    if (dp_pkt_is_l2mcbc (xf, md) == 1) {\n",
        "        LLBS_PPLN_PASS (xf);\n",
        "    }\n",
        "    return 0;\n",
        "handle_excp :\n",
        "    if (ret > DP_PRET_OK) {\n",
        "        if (ret == DP_PRET_PASS) {\n",
        "            LLBS_PPLN_PASS (xf);\n",
        "        }\n",
        "        else {\n",
        "            LLBS_PPLN_TRAPC (xf, LLB_PIPE_RC_PARSER);\n",
        "        }\n",
        "    }\n",
        "    else if (ret < DP_PRET_OK) {\n",
        "        LLBS_PPLN_DROP (xf);\n",
        "    }\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_parse_ipv4",
        "dp_parse_ipv6",
        "dp_parse_arp",
        "dp_parse_eth",
        "dp_parse_llb",
        "dp_pkt_is_l2mcbc",
        "dp_parse_vlan",
        "xdp2tc_has_xmd"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_unparse_packet_always_slow": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 925,
      "endLine": 987,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_compose.c",
      "funcName": "dp_unparse_packet_always_slow",
      "developer_inline_comments": [
        {
          "start_line": 930,
          "end_line": 930,
          "text": " If packet is v6 "
        },
        {
          "start_line": 937,
          "end_line": 937,
          "text": " TODO "
        },
        {
          "start_line": 940,
          "end_line": 940,
          "text": " If packet is v4 "
        },
        {
          "start_line": 959,
          "end_line": 959,
          "text": " If packet is v6 "
        },
        {
          "start_line": 970,
          "end_line": 970,
          "text": " If packet is v4 "
        },
        {
          "start_line": 976,
          "end_line": 976,
          "text": " TODO "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_unparse_packet_always_slow (void *ctx, struct xfi *xf)\n",
        "{\n",
        "    if (xf->pm.nf & LLB_NAT_SRC) {\n",
        "        LL_DBG_PRINTK (\"[DEPR] LL_SNAT 0x%lx:%x\\n\", xf->nm.nxip4, xf->nm.nxport);\n",
        "        if (xf->l2m.dl_type == bpf_ntohs (ETH_P_IPV6)) {\n",
        "            if (xf->nm.nv6) {\n",
        "                if (dp_do_snat6 (ctx, xf, xf->nm.nxip, xf->nm.nxport) != 0) {\n",
        "                    return DP_DROP;\n",
        "                }\n",
        "            }\n",
        "            else {\n",
        "                return DP_DROP;\n",
        "            }\n",
        "        }\n",
        "        else {\n",
        "            if (xf->nm.nv6 == 0) {\n",
        "                if (dp_do_snat (ctx, xf, xf->nm.nxip4, xf->nm.nxport) != 0) {\n",
        "                    return DP_DROP;\n",
        "                }\n",
        "            }\n",
        "            else {\n",
        "                if (dp_do_snat46 (ctx, xf) != 0) {\n",
        "                    return DP_DROP;\n",
        "                }\n",
        "                if (xf->pm.pipe_act & (LLB_PIPE_TRAP | LLB_PIPE_PASS)) {\n",
        "                    xf->pm.oport = xf->pm.iport;\n",
        "                    return dp_rewire_port (&tx_intf_map, xf);\n",
        "                }\n",
        "            }\n",
        "        }\n",
        "    }\n",
        "    else if (xf->pm.nf & LLB_NAT_DST) {\n",
        "        LL_DBG_PRINTK (\"[DEPR] LL_DNAT 0x%x\\n\", xf->nm.nxip4, xf->nm.nxport);\n",
        "        if (xf->l2m.dl_type == bpf_ntohs (ETH_P_IPV6)) {\n",
        "            if (xf->nm.nv6 == 1) {\n",
        "                if (dp_do_dnat6 (ctx, xf, xf->nm.nxip, xf->nm.nxport) != 0) {\n",
        "                    return DP_DROP;\n",
        "                }\n",
        "            }\n",
        "            else {\n",
        "                if (dp_do_dnat64 (ctx, xf)) {\n",
        "                    return DP_DROP;\n",
        "                }\n",
        "            }\n",
        "        }\n",
        "        else {\n",
        "            if (xf->nm.nv6 == 0) {\n",
        "                if (dp_do_dnat (ctx, xf, xf->nm.nxip4, xf->nm.nxport) != 0) {\n",
        "                    return DP_DROP;\n",
        "                }\n",
        "            }\n",
        "            else {\n",
        "                return DP_DROP;\n",
        "            }\n",
        "        }\n",
        "    }\n",
        "    xf->pm.nf = 0;\n",
        "    RETURN_TO_MP_OUT ();\n",
        "    return DP_DROP;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_do_snat46",
        "dp_do_dnat64",
        "dp_do_snat",
        "dp_do_dnat6",
        "dp_do_snat6",
        "dp_do_dnat",
        "dp_rewire_port"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_unparse_packet_always": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 989,
      "endLine": 1036,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_compose.c",
      "funcName": "dp_unparse_packet_always",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_unparse_packet_always (void *ctx, struct xfi *xf)\n",
        "{\n",
        "    if (xf->pm.nf & LLB_NAT_SRC && xf->nm.dsr == 0) {\n",
        "        LL_DBG_PRINTK (\"[DEPR] LL_SNAT 0x%lx:%x\\n\", xf->nm.nxip4, xf->nm.nxport);\n",
        "        if (xf->l2m.dl_type == bpf_ntohs (ETH_P_IPV6) || xf->nm.nv6) {\n",
        "            dp_sunp_tcall (ctx, xf);\n",
        "        }\n",
        "        else {\n",
        "            if (dp_do_snat (ctx, xf, xf->nm.nxip4, xf->nm.nxport) != 0) {\n",
        "                return DP_DROP;\n",
        "            }\n",
        "        }\n",
        "    }\n",
        "    else if (xf->pm.nf & LLB_NAT_DST && xf->nm.dsr == 0) {\n",
        "        LL_DBG_PRINTK (\"[DEPR] LL_DNAT 0x%x\\n\", xf->nm.nxip4, xf->nm.nxport);\n",
        "        if (xf->l2m.dl_type == bpf_ntohs (ETH_P_IPV6)) {\n",
        "            dp_sunp_tcall (ctx, xf);\n",
        "        }\n",
        "        else {\n",
        "            if (dp_do_dnat (ctx, xf, xf->nm.nxip4, xf->nm.nxport) != 0) {\n",
        "                return DP_DROP;\n",
        "            }\n",
        "        }\n",
        "    }\n",
        "    if (xf->tm.tun_decap) {\n",
        "        if (xf->tm.tun_type == LLB_TUN_GTP) {\n",
        "            LL_DBG_PRINTK (\"[DEPR] LL STRIP-GTP\\n\");\n",
        "            if (dp_do_strip_gtp (ctx, xf, xf->pm.tun_off) != 0) {\n",
        "                return DP_DROP;\n",
        "            }\n",
        "        }\n",
        "    }\n",
        "    else if (xf->tm.new_tunnel_id) {\n",
        "        if (xf->tm.tun_type == LLB_TUN_GTP) {\n",
        "            if (dp_do_ins_gtp (ctx, xf, xf->tm.tun_rip, xf->tm.tun_sip, xf->tm.new_tunnel_id, xf->qm.qfi, 1)) {\n",
        "                return DP_DROP;\n",
        "            }\n",
        "        }\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_do_strip_gtp",
        "dp_sunp_tcall",
        "dp_do_ins_gtp",
        "dp_do_snat",
        "dp_do_dnat"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_unparse_packet": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1038,
      "endLine": 1078,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_compose.c",
      "funcName": "dp_unparse_packet",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_unparse_packet (void *ctx, struct xfi *xf)\n",
        "{\n",
        "    if (xf->tm.tun_decap) {\n",
        "        if (xf->tm.tun_type == LLB_TUN_VXLAN) {\n",
        "            LL_DBG_PRINTK (\"[DEPR] LL STRIP-VXLAN\\n\");\n",
        "            if (dp_do_strip_vxlan (ctx, xf, xf->pm.tun_off) != 0) {\n",
        "                return DP_DROP;\n",
        "            }\n",
        "        }\n",
        "        else if (xf->tm.tun_type == LLB_TUN_IPIP) {\n",
        "            LL_DBG_PRINTK (\"[DEPR] LL STRIP-IPIP\\n\");\n",
        "            if (dp_do_strip_ipip (ctx, xf) != 0) {\n",
        "                return DP_DROP;\n",
        "            }\n",
        "        }\n",
        "    }\n",
        "    else if (xf->tm.new_tunnel_id) {\n",
        "        LL_DBG_PRINTK (\"[DEPR] LL_NEW-TUN 0x%x\\n\", bpf_ntohl (xf->tm.new_tunnel_id));\n",
        "        if (xf->tm.tun_type == LLB_TUN_VXLAN) {\n",
        "            if (dp_do_ins_vxlan (ctx, xf, xf->tm.tun_rip, xf->tm.tun_sip, xf->tm.new_tunnel_id, 1)) {\n",
        "                return DP_DROP;\n",
        "            }\n",
        "        }\n",
        "        else if (xf->tm.tun_type == LLB_TUN_IPIP) {\n",
        "            LL_DBG_PRINTK (\"[DEPR] LL_NEW-IPTUN 0x%x\\n\", bpf_ntohl (xf->tm.new_tunnel_id));\n",
        "            if (dp_do_ins_ipip (ctx, xf, xf->tm.tun_rip, xf->tm.tun_sip, xf->tm.new_tunnel_id, 1)) {\n",
        "                return DP_DROP;\n",
        "            }\n",
        "        }\n",
        "    }\n",
        "    return dp_do_out_vlan (ctx, xf);\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_do_ins_ipip",
        "dp_do_out_vlan",
        "dp_do_strip_ipip",
        "dp_do_ins_vxlan",
        "dp_do_strip_vxlan"
      ],
      "call_depth": 4,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_do_fw4_main": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 23,
      "endLine": 128,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_fw.c",
      "funcName": "dp_do_fw4_main",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 6,
          "text": " *  llb_kern_fw.c: LoxiLB Kernel eBPF firewall Implementation *  Copyright (C) 2022,  NetLOX <www.netlox.io> *  * SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause) "
        },
        {
          "start_line": 60,
          "end_line": 60,
          "text": " End of lookup "
        },
        {
          "start_line": 77,
          "end_line": 77,
          "text": " End of lookup "
        },
        {
          "start_line": 85,
          "end_line": 85,
          "text": " No match in this iteration "
        },
        {
          "start_line": 89,
          "end_line": 89,
          "text": " End of lookup "
        },
        {
          "start_line": 99,
          "end_line": 99,
          "text": " This condition should never hit "
        },
        {
          "start_line": 116,
          "end_line": 116,
          "text": " Same for DP_SET_DROP "
        }
      ],
      "updateMaps": [],
      "readMaps": [
        "  fw_v4_map"
      ],
      "input": [
        "void *ctx",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_do_fw4_main (void *ctx, struct xfi *xf)\n",
        "{\n",
        "    __u32 idx = 0;\n",
        "    int i = 0;\n",
        "    struct dp_fwv4_ent *fwe;\n",
        "    struct pdi_key key;\n",
        "    struct dp_fwv4_tact *act = NULL;\n",
        "    memset (&key, 0, sizeof (key));\n",
        "    PDI_VAL_INIT (&key.inport, xf->pm.iport);\n",
        "    PDI_VAL_INIT (&key.zone, xf->pm.zone);\n",
        "    PDI_VAL_INIT (&key.bd, xf->pm.bd);\n",
        "    PDI_VAL_INIT (&key.dest, bpf_ntohl (xf->l34m.daddr4));\n",
        "    PDI_VAL_INIT (&key.source, bpf_ntohl (xf->l34m.saddr4));\n",
        "    PDI_RVAL_INIT (&key.dport, bpf_htons (xf->l34m.dest));\n",
        "    PDI_RVAL_INIT (&key.sport, bpf_htons (xf->l34m.source));\n",
        "    PDI_VAL_INIT (&key.protocol, xf->l34m.nw_proto);\n",
        "    LL_DBG_PRINTK (\"[FW4] -- Lookup\\n\");\n",
        "    LL_DBG_PRINTK (\"[FW4] key-sz %d\\n\", sizeof (key));\n",
        "    LL_DBG_PRINTK (\"[FW4] port %x\\n\", key.inport);\n",
        "    LL_DBG_PRINTK (\"[FW4] daddr %x\\n\", key.dest);\n",
        "    LL_DBG_PRINTK (\"[FW4] saddr %d\\n\", key.source);\n",
        "    LL_DBG_PRINTK (\"[FW4] sport %d\\n\", key.sport);\n",
        "    LL_DBG_PRINTK (\"[FW4] dport %d\\n\", key.dport);\n",
        "    LL_DBG_PRINTK (\"[FW4] l4proto %d\\n\", key.protocol);\n",
        "    xf->pm.table_id = LL_DP_FW4_MAP;\n",
        "    idx = xf->pm.fw_lid;\n",
        "    for (i = 0; i < DP_MAX_LOOPS_PER_FWLKUP; i++) {\n",
        "        fwe = bpf_map_lookup_elem (& fw_v4_map, & idx);\n",
        "        if (!fwe) {\n",
        "            LL_DBG_PRINTK (\"[FW4] miss\");\n",
        "            xf->pm.fw_lid = LLB_FW4_MAP_ENTRIES;\n",
        "            RETURN_TO_MP ();\n",
        "            return DP_DROP;\n",
        "        }\n",
        "        else {\n",
        "            if (idx == 0) {\n",
        "                xf->pm.fw_mid = fwe->k.nr.val;\n",
        "            }\n",
        "            else if (i + xf->pm.fw_lid >= xf->pm.fw_mid) {\n",
        "                i = DP_MAX_LOOPS_PER_FWLKUP;\n",
        "                break;\n",
        "            }\n",
        "            idx++;\n",
        "            if (fwe->k.zone.val != 0 && PDI_PKEY_EQ (&key, &fwe->k)) {\n",
        "                xf->pm.fw_lid = LLB_FW4_MAP_ENTRIES;\n",
        "                break;\n",
        "            }\n",
        "        }\n",
        "    }\n",
        "    if (i >= DP_MAX_LOOPS_PER_FWLKUP) {\n",
        "        xf->pm.fw_lid += DP_MAX_LOOPS_PER_FWLKUP;\n",
        "        if (xf->pm.fw_lid >= LLB_FW4_MAP_ENTRIES || xf->pm.fw_lid > xf->pm.fw_mid) {\n",
        "            xf->pm.fw_lid = LLB_FW4_MAP_ENTRIES;\n",
        "        }\n",
        "        LL_DBG_PRINTK (\"[FW4] done\");\n",
        "        RETURN_TO_MP ();\n",
        "        return DP_DROP;\n",
        "    }\n",
        "    xf->pm.phit |= LLB_DP_FW_HIT;\n",
        "    if (!fwe)\n",
        "        return 0;\n",
        "    act = &fwe->fwa;\n",
        "    xf->pm.dp_mark = act->ca.mark;\n",
        "    xf->pm.dp_rec = act->ca.record;\n",
        "    if (act->ca.act_type == DP_SET_NOP) {\n",
        "        goto done;\n",
        "    }\n",
        "    else if (act->ca.act_type == DP_SET_RDR_PORT) {\n",
        "        struct dp_rdr_act *ar = &act->port_act;\n",
        "        LLBS_PPLN_RDR_PRIO (xf);\n",
        "        xf->pm.oport = ar->oport;\n",
        "    }\n",
        "    else if (act->ca.act_type == DP_SET_TOCP) {\n",
        "        LLBS_PPLN_TRAPC (xf, LLB_PIPE_RC_FW_RDR);\n",
        "    }\n",
        "    else {\n",
        "        LLBS_PPLN_DROP (xf);\n",
        "    }\n",
        "    xf->pm.phit |= LLB_DP_RES_HIT;\n",
        "done :\n",
        "    dp_do_map_stats (ctx, xf, LL_DP_FW4_STATS_MAP, act->ca.cidx);\n",
        "    xf->pm.fw_rid = act->ca.cidx;\n",
        "    RETURN_TO_MP ();\n",
        "    return DP_DROP;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_do_map_stats"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_do_fw_main": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 130,
      "endLine": 134,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_fw.c",
      "funcName": "dp_do_fw_main",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_do_fw_main (void *ctx, struct xfi *xf)\n",
        "{\n",
        "    return dp_do_fw4_main (ctx, xf);\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_do_fw4_main"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_sel_nat_ep": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 7,
      "endLine": 53,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_natlbfwd.c",
      "funcName": "dp_sel_nat_ep",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 6,
          "text": " *  llb_kern_nat.c: LoxiLB Kernel eBPF Stateful NAT/LB Processing *  Copyright (C) 2022,  NetLOX <www.netlox.io> *  * SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause) "
        },
        {
          "start_line": 38,
          "end_line": 38,
          "text": " Fall back if hash selection gives us a deadend "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct dp_nat_tacts *act"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_spin_lock",
        "bpf_spin_unlock"
      ],
      "compatibleHookpoints": [
        "socket_filter",
        "sock_ops",
        "xdp",
        "sched_act",
        "sk_reuseport",
        "lwt_seg6local",
        "lwt_in",
        "sk_skb",
        "cgroup_skb",
        "lwt_xmit",
        "cgroup_sock",
        "lwt_out",
        "sched_cls",
        "flow_dissector",
        "sk_msg",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_sel_nat_ep (void *ctx, struct dp_nat_tacts *act)\n",
        "{\n",
        "    int sel = -1;\n",
        "    uint8_t n = 0;\n",
        "    uint16_t i = 0;\n",
        "    struct mf_xfrm_inf *nxfrm_act;\n",
        "    if (act->sel_type == NAT_LB_SEL_RR) {\n",
        "        bpf_spin_lock (&act->lock);\n",
        "        i = act->sel_hint;\n",
        "        while (n < LLB_MAX_NXFRMS) {\n",
        "            if (i >= 0 && i < LLB_MAX_NXFRMS) {\n",
        "                nxfrm_act = &act->nxfrms[i];\n",
        "                if (nxfrm_act < act + 1) {\n",
        "                    if (nxfrm_act->inactive == 0) {\n",
        "                        act->sel_hint = (i + 1) % act->nxfrm;\n",
        "                        sel = i;\n",
        "                        break;\n",
        "                    }\n",
        "                }\n",
        "            }\n",
        "            i++;\n",
        "            i = i % act->nxfrm;\n",
        "            n++;\n",
        "        }\n",
        "        bpf_spin_unlock (&act->lock);\n",
        "    }\n",
        "    else if (act->sel_type == NAT_LB_SEL_HASH) {\n",
        "        sel = dp_get_pkt_hash (ctx) % act->nxfrm;\n",
        "        if (sel >= 0 && sel < LLB_MAX_NXFRMS) {\n",
        "            if (act->nxfrms[sel].inactive) {\n",
        "                for (i = 0; i < LLB_MAX_NXFRMS; i++) {\n",
        "                    if (act->nxfrms[i].inactive == 0) {\n",
        "                        sel = i;\n",
        "                        break;\n",
        "                    }\n",
        "                }\n",
        "            }\n",
        "        }\n",
        "    }\n",
        "    LL_DBG_PRINTK (\"lb-sel %d\", sel);\n",
        "    return sel;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_get_pkt_hash"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_do_nat": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 55,
      "endLine": 126,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_natlbfwd.c",
      "funcName": "dp_do_nat",
      "developer_inline_comments": [
        {
          "start_line": 83,
          "end_line": 83,
          "text": " Default action - Nothing to do "
        },
        {
          "start_line": 98,
          "end_line": 100,
          "text": " FIXME - Do not select inactive end-points      * Need multi-passes for selection     "
        },
        {
          "start_line": 113,
          "end_line": 113,
          "text": " Special case related to host-dnat "
        }
      ],
      "updateMaps": [],
      "readMaps": [
        "  nat_map"
      ],
      "input": [
        "void *ctx",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_do_nat (void *ctx, struct xfi *xf)\n",
        "{\n",
        "    struct dp_nat_key key;\n",
        "    struct mf_xfrm_inf *nxfrm_act;\n",
        "    struct dp_nat_tacts *act;\n",
        "    __u32 sel;\n",
        "    memset (&key, 0, sizeof (key));\n",
        "    DP_XADDR_CP (key.daddr, xf->l34m.daddr);\n",
        "    if (xf->l34m.nw_proto != IPPROTO_ICMP) {\n",
        "        key.dport = xf->l34m.dest;\n",
        "    }\n",
        "    else {\n",
        "        key.dport = 0;\n",
        "    }\n",
        "    key.zone = xf->pm.zone;\n",
        "    key.l4proto = xf->l34m.nw_proto;\n",
        "    key.mark = (__u16) (xf->pm.dp_mark & 0xffff);\n",
        "    if (xf->l2m.dl_type == bpf_ntohs (ETH_P_IPV6)) {\n",
        "        key.v6 = 1;\n",
        "    }\n",
        "    LL_DBG_PRINTK (\"[NAT] --Lookup\\n\");\n",
        "    xf->pm.table_id = LL_DP_NAT_MAP;\n",
        "    act = bpf_map_lookup_elem (& nat_map, & key);\n",
        "    if (!act) {\n",
        "        xf->pm.nf &= ~LLB_NAT_SRC;\n",
        "        return 0;\n",
        "    }\n",
        "    LL_DBG_PRINTK (\"[NAT] action %d pipe %x\\n\", act->ca.act_type, xf->pm.pipe_act);\n",
        "    if (act->ca.act_type == DP_SET_SNAT || act->ca.act_type == DP_SET_DNAT) {\n",
        "        sel = dp_sel_nat_ep (ctx, act);\n",
        "        xf->nm.dsr = act->ca.oaux ? 1 : 0;\n",
        "        xf->pm.nf = act->ca.act_type == DP_SET_SNAT ? LLB_NAT_SRC : LLB_NAT_DST;\n",
        "        if (sel >= 0 && sel < LLB_MAX_NXFRMS) {\n",
        "            nxfrm_act = &act->nxfrms[sel];\n",
        "            if (nxfrm_act < act + 1) {\n",
        "                DP_XADDR_CP (xf->nm.nxip, nxfrm_act->nat_xip);\n",
        "                DP_XADDR_CP (xf->nm.nrip, nxfrm_act->nat_rip);\n",
        "                xf->nm.nxport = nxfrm_act->nat_xport;\n",
        "                xf->nm.nv6 = nxfrm_act->nv6 ? 1 : 0;\n",
        "                xf->nm.sel_aid = sel;\n",
        "                xf->nm.ito = act->ito;\n",
        "                xf->pm.rule_id = act->ca.cidx;\n",
        "                LL_DBG_PRINTK (\"[NAT] ACT %x\\n\", xf->pm.nf);\n",
        "                if (xf->l34m.saddr4 == xf->nm.nxip4 && xf->pm.nf == LLB_NAT_DST) {\n",
        "                    xf->nm.nxip4 = 0;\n",
        "                }\n",
        "            }\n",
        "        }\n",
        "        else {\n",
        "            xf->pm.nf = 0;\n",
        "        }\n",
        "    }\n",
        "    else {\n",
        "        LLBS_PPLN_DROP (xf);\n",
        "    }\n",
        "    return 1;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_sel_nat_ep"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "bpf_num_possible_cpus": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 102,
      "endLine": 110,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "bpf_num_possible_cpus",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 6,
          "text": " * loxilb_libdp.c: LoxiLB DP config library  * Copyright (C) 2022,  NetLOX <www.netlox.io> * * SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause) "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void"
      ],
      "output": "staticinlineunsignedint",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static inline unsigned int bpf_num_possible_cpus (void)\n",
        "{\n",
        "    int possible_cpus = libbpf_num_possible_cpus ();\n",
        "    if (possible_cpus < 0) {\n",
        "        return 0;\n",
        "    }\n",
        "    return possible_cpus;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "ll_pretty_hex": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 112,
      "endLine": 134,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "ll_pretty_hex",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ptr",
        " int len"
      ],
      "output": "staticvoid",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static void ll_pretty_hex (void *ptr, int len)\n",
        "{\n",
        "    int i = 0, idx = 0;\n",
        "    unsigned char tmp_buf [64] = {0};\n",
        "    for (i = 0; i < len; i++) {\n",
        "        idx += snprintf ((void *) (tmp_buf + idx), 3, \"%02x\", *((unsigned char *) ptr + i));\n",
        "        if (idx >= 32) {\n",
        "            printf (\"0x%s\\r\\n\", tmp_buf);\n",
        "            memset (tmp_buf, 0, 32);\n",
        "            idx = 0;\n",
        "        }\n",
        "    }\n",
        "    if (idx) {\n",
        "        printf (\"0x%s\\r\\n\", tmp_buf);\n",
        "    }\n",
        "    return;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "libbpf_print_fn": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 136,
      "endLine": 145,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "libbpf_print_fn",
      "developer_inline_comments": [
        {
          "start_line": 141,
          "end_line": 141,
          "text": " Ignore debug-level libbpf logs "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "enum libbpf_print_level level",
        " const char *format",
        " va_list args"
      ],
      "output": "staticint",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int libbpf_print_fn (enum libbpf_print_level level, const char *format, va_list args)\n",
        "{\n",
        "    if (level > LIBBPF_INFO)\n",
        "        return 0;\n",
        "    return vfprintf (stderr, format, args);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ],
  "llb_handle_pkt_event": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 147,
      "endLine": 167,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "llb_handle_pkt_event",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " int cpu",
        " void *data",
        " unsigned int data_sz"
      ],
      "output": "staticvoid",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static void llb_handle_pkt_event (void *ctx, int cpu, void *data, unsigned int data_sz)\n",
        "{\n",
        "    struct ll_dp_pmdi *pmd = data;\n",
        "    struct tm *tm;\n",
        "    char ts [32];\n",
        "    time_t t;\n",
        "    time (&t);\n",
        "    tm = localtime (& t);\n",
        "    strftime (ts, sizeof (ts), \"%H:%M:%S\", tm);\n",
        "    printf (\"%-8s %-5s %-7d %-16d %-3d %-16d %-8d\\n\", ts, \"PKT\", pmd->ifindex, pmd->xdp_inport, pmd->table_id, pmd->rcode, pmd->pkt_len);\n",
        "    ll_pretty_hex (pmd->data, pmd->pkt_len);\n",
        "}\n"
      ],
      "called_function_list": [
        "ll_pretty_hex"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ],
  "llb_pkt_proc_main": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 169,
      "endLine": 180,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "llb_pkt_proc_main",
      "developer_inline_comments": [
        {
          "start_line": 175,
          "end_line": 175,
          "text": " timeout, ms "
        },
        {
          "start_line": 178,
          "end_line": 178,
          "text": " NOT REACHED "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *arg"
      ],
      "output": "staticvoid",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static void *llb_pkt_proc_main (void *arg)\n",
        "{\n",
        "    struct perf_buffer *pb = arg;\n",
        "    while (1) {\n",
        "        perf_buffer__poll (pb, 100);\n",
        "    }\n",
        "    return NULL;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ],
  "": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 182,
      "endLine": 207,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "",
      "developer_inline_comments": [
        {
          "start_line": 191,
          "end_line": 191,
          "text": " Set up ring buffer polling "
        },
        {
          "start_line": 194,
          "end_line": 194,
          "text": " 32KB per CPU "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "unused"
      ],
      "output": "NA",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int llb_setup_pkt_ring (struct bpf_object * bpf_obj __attribute__ ((unused)))\n",
        "{\n",
        "    struct perf_buffer *pb = NULL;\n",
        "    struct perf_buffer_opts pb_opts = {0}\n",
        "    ;\n",
        "    int pkt_fd = xh->maps[LL_DP_PKT_PERF_RING].map_fd;\n",
        "    if (pkt_fd < 0)\n",
        "        return -1;\n",
        "    pb_opts.sample_cb = llb_handle_pkt_event;\n",
        "    pb = perf_buffer__new (pkt_fd, 8, & pb_opts);\n",
        "    if (libbpf_get_error (pb)) {\n",
        "        fprintf (stderr, \"Failed to create perf buffer\\n\");\n",
        "        goto cleanup;\n",
        "    }\n",
        "    pthread_create (&xh->pkt_thr, NULL, llb_pkt_proc_main, pb);\n",
        "    return 0;\n",
        "cleanup :\n",
        "    perf_buffer__free (pb);\n",
        "    return -1;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ],
  "goMapNotiHandler": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 212,
      "endLine": 215,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "goMapNotiHandler",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct ll_dp_map_notif *mn"
      ],
      "output": "weak))",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "void  __attribute__ ((weak)) goMapNotiHandler (struct ll_dp_map_notif *mn)\n",
        "{\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "llb_maptrace_output": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 217,
      "endLine": 275,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "llb_maptrace_output",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " int cpu",
        " void *data",
        " __u32 size"
      ],
      "output": "staticvoid",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static void llb_maptrace_output (void *ctx, int cpu, void *data, __u32 size)\n",
        "{\n",
        "    struct map_update_data *map_data = (struct map_update_data *) data;\n",
        "    struct ll_dp_map_notif noti;\n",
        "\n",
        "#if 0\n",
        "    char out_val;\n",
        "    if (map_data->updater == UPDATER_KERNEL) {\n",
        "        printf (\"Map Updated From Kernel:\\n\");\n",
        "    }\n",
        "    else if (map_data->updater == UPDATER_USERMODE) {\n",
        "        printf (\"Map Updated From User:\\n\");\n",
        "    }\n",
        "    else if (map_data->updater == UPDATER_SYSCALL_GET) {\n",
        "        printf (\"Syscall used to get a map handle:\\n\");\n",
        "    }\n",
        "    else if (map_data->updater == UPDATER_SYSCALL_UPDATE) {\n",
        "        printf (\"Syscall used to get a update map using handle:\\n\");\n",
        "    }\n",
        "    else if (map_data->updater == DELETE_KERNEL) {\n",
        "        printf (\"Map Deleted From Kernel:\\n\");\n",
        "    }\n",
        "    printf (\"  PID:   %d\\n\", map_data->pid);\n",
        "    if (map_data->updater == UPDATER_SYSCALL_UPDATE) {\n",
        "        printf (\"  FD:    %d\\n\", map_data->map_id);\n",
        "    }\n",
        "    else {\n",
        "        printf (\"  ID:    %d\\n\", map_data->map_id);\n",
        "    }\n",
        "    if (map_data->name[0] != '\\x00')\n",
        "        printf (\"  Name:  %s\\n\", map_data->name);\n",
        "    if (map_data->key_size > 0) {\n",
        "        printf (\"  Key:   \");\n",
        "        for (int i = 0; i < map_data->key_size; i++) {\n",
        "            out_val = map_data->key[i];\n",
        "            printf (\"%02x \", out_val);\n",
        "        }\n",
        "        printf (\"\\n\");\n",
        "    }\n",
        "    if (map_data->value_size > 0 && map_data->updater != DELETE_KERNEL) {\n",
        "        printf (\"  Value: \");\n",
        "        for (int i = 0; i < map_data->value_size; i++) {\n",
        "            out_val = map_data->value[i];\n",
        "            printf (\"%02x \", out_val);\n",
        "        }\n",
        "        printf (\"\\n\");\n",
        "    }\n",
        "\n",
        "#endif\n",
        "    memset (&noti, 0, sizeof (noti));\n",
        "    if (map_data->updater == UPDATER_KERNEL) {\n",
        "        noti.addop = 1;\n",
        "    }\n",
        "    else if (map_data->updater == DELETE_KERNEL) {\n",
        "        noti.addop = 0;\n",
        "    }\n",
        "    else\n",
        "        return;\n",
        "    noti.key = map_data->key;\n",
        "    noti.key_len = map_data->key_size;\n",
        "    noti.val = map_data->value;\n",
        "    noti.val_len = map_data->value_size;\n",
        "    goMapNotiHandler (&noti);\n",
        "}\n"
      ],
      "called_function_list": [
        "goMapNotiHandler"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "llb_maptrace_uhook": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 277,
      "endLine": 305,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "llb_maptrace_uhook",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "int tid",
        " int addop",
        " void *key",
        " int key_sz",
        " void *val",
        " int val_sz"
      ],
      "output": "staticvoid",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static void llb_maptrace_uhook (int tid, int addop, void *key, int key_sz, void *val, int val_sz)\n",
        "{\n",
        "    map_update_data ud;\n",
        "    if (!xh->have_mtrace) {\n",
        "        return;\n",
        "    }\n",
        "    if (tid != LL_DP_CT_MAP) {\n",
        "        return;\n",
        "    }\n",
        "    memset (&ud, 0, sizeof (ud));\n",
        "    strcpy (ud.name, \"ct_map\");\n",
        "    ud.updater = DELETE_KERNEL;\n",
        "    if (key_sz) {\n",
        "        memcpy (ud.key, key, key_sz > MAX_KEY_SIZE ? MAX_KEY_SIZE : key_sz);\n",
        "    }\n",
        "    ud.key_size = key_sz;\n",
        "    if (val_sz) {\n",
        "        memcpy (ud.value, val, val_sz > MAX_VALUE_SIZE ? MAX_VALUE_SIZE : val_sz);\n",
        "    }\n",
        "    ud.value_size = val_sz;\n",
        "    llb_maptrace_output (NULL, 0, &ud, sizeof (ud));\n",
        "}\n"
      ],
      "called_function_list": [
        "llb_maptrace_output"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 368,
      "endLine": 374,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "llb_maptrace_uhook",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "int tid",
        " int addop",
        " void *key",
        " int key_sz",
        " void *val",
        " int val_sz"
      ],
      "output": "staticvoid",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static void llb_maptrace_uhook (int tid, int addop, void *key, int key_sz, void *val, int val_sz)\n",
        "{\n",
        "    return;\n",
        "}\n"
      ],
      "called_function_list": [
        "llb_maptrace_output"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "llb_maptrace_main": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 307,
      "endLine": 318,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "llb_maptrace_main",
      "developer_inline_comments": [
        {
          "start_line": 313,
          "end_line": 313,
          "text": " timeout, ms "
        },
        {
          "start_line": 316,
          "end_line": 316,
          "text": " NOT REACHED "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *arg"
      ],
      "output": "staticvoid",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static void *llb_maptrace_main (void *arg)\n",
        "{\n",
        "    struct perf_buffer *pb = arg;\n",
        "    while (1) {\n",
        "        perf_buffer__poll (pb, 100);\n",
        "    }\n",
        "    return NULL;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ],
  "llb_setup_kern_mon": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 320,
      "endLine": 364,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "llb_setup_kern_mon",
      "developer_inline_comments": [
        {
          "start_line": 326,
          "end_line": 326,
          "text": " Open and load eBPF Program"
        },
        {
          "start_line": 338,
          "end_line": 338,
          "text": " Attach the various kProbes"
        },
        {
          "start_line": 345,
          "end_line": 345,
          "text": " Setup Pef buffer to process events from kernel"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void"
      ],
      "output": "staticint",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int llb_setup_kern_mon (void)\n",
        "{\n",
        "    struct llb_kern_mon *prog;\n",
        "    int err;\n",
        "    prog = llb_kern_mon__open ();\n",
        "    if (!prog) {\n",
        "        printf (\"Failed to open and load BPF skeleton\\n\");\n",
        "        return 1;\n",
        "    }\n",
        "    err = llb_kern_mon__load (prog);\n",
        "    if (err) {\n",
        "        printf (\"Failed to load and verify BPF skeleton\\n\");\n",
        "        goto cleanup;\n",
        "    }\n",
        "    err = llb_kern_mon__attach (prog);\n",
        "    if (err) {\n",
        "        printf (\"Failed to attach BPF skeleton\\n\");\n",
        "        goto cleanup;\n",
        "    }\n",
        "    struct perf_buffer_opts pb_opts = {0}\n",
        "    ;\n",
        "    struct perf_buffer *pb;\n",
        "    pb_opts.sample_cb = llb_maptrace_output;\n",
        "    pb = perf_buffer__new (bpf_map__fd (prog -> maps.map_events), 8, & pb_opts);\n",
        "    err = libbpf_get_error (pb);\n",
        "    if (err) {\n",
        "        printf (\"failed to setup perf_buffer: %d\\n\", err);\n",
        "        goto cleanup;\n",
        "    }\n",
        "    pthread_create (&xh->mon_thr, NULL, llb_maptrace_main, pb);\n",
        "    return 0;\n",
        "cleanup :\n",
        "    llb_kern_mon__destroy (prog);\n",
        "    return err < 0 ? -err : 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 376,
      "endLine": 380,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "llb_setup_kern_mon",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void"
      ],
      "output": "staticint",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int llb_setup_kern_mon (void)\n",
        "{\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "llb_objmap2fd": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 383,
      "endLine": 399,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "llb_objmap2fd",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct bpf_object *bpf_obj",
        " const char *mapname"
      ],
      "output": "staticint",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int llb_objmap2fd (struct bpf_object *bpf_obj, const char *mapname)\n",
        "{\n",
        "    struct bpf_map *map;\n",
        "    int map_fd = -1;\n",
        "    map = bpf_object__find_map_by_name (bpf_obj, mapname);\n",
        "    if (!map) {\n",
        "        goto out;\n",
        "    }\n",
        "    map_fd = bpf_map__fd (map);\n",
        "    printf (\"%s: %d\\n\", mapname, map_fd);\n",
        "out :\n",
        "    return map_fd;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "llb_setup_crc32c_map": [
    {
      "capabilities": [
        {
          "capability": "map_update",
          "map_update": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_map_update_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}",
                "{Type:  const void ,Var: *value}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_update"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 401,
      "endLine": 420,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "llb_setup_crc32c_map",
      "developer_inline_comments": [
        {
          "start_line": 407,
          "end_line": 407,
          "text": " Generate crc32c table"
        }
      ],
      "updateMaps": [
        " mapfd"
      ],
      "readMaps": [],
      "input": [
        "int mapfd"
      ],
      "output": "staticvoid",
      "helper": [
        "bpf_map_update_elem"
      ],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static void llb_setup_crc32c_map (int mapfd)\n",
        "{\n",
        "    int i;\n",
        "    uint32_t crc;\n",
        "    for (i = 0; i < 256; i++) {\n",
        "        crc = i;\n",
        "        crc = crc & 1 ? (crc >> 1) ^ 0x82f63b78 : crc >> 1;\n",
        "        crc = crc & 1 ? (crc >> 1) ^ 0x82f63b78 : crc >> 1;\n",
        "        crc = crc & 1 ? (crc >> 1) ^ 0x82f63b78 : crc >> 1;\n",
        "        crc = crc & 1 ? (crc >> 1) ^ 0x82f63b78 : crc >> 1;\n",
        "        crc = crc & 1 ? (crc >> 1) ^ 0x82f63b78 : crc >> 1;\n",
        "        crc = crc & 1 ? (crc >> 1) ^ 0x82f63b78 : crc >> 1;\n",
        "        crc = crc & 1 ? (crc >> 1) ^ 0x82f63b78 : crc >> 1;\n",
        "        crc = crc & 1 ? (crc >> 1) ^ 0x82f63b78 : crc >> 1;\n",
        "        bpf_map_update_elem (mapfd, &i, &crc, BPF_ANY);\n",
        "    }\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "llb_setup_ctctr_map": [
    {
      "capabilities": [
        {
          "capability": "map_update",
          "map_update": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_map_update_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}",
                "{Type:  const void ,Var: *value}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_update"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 422,
      "endLine": 433,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "llb_setup_ctctr_map",
      "developer_inline_comments": [],
      "updateMaps": [
        " mapfd"
      ],
      "readMaps": [],
      "input": [
        "int mapfd"
      ],
      "output": "staticvoid",
      "helper": [
        "bpf_map_update_elem"
      ],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static void llb_setup_ctctr_map (int mapfd)\n",
        "{\n",
        "    uint32_t k = 0;\n",
        "    struct dp_ct_ctrtact ctr;\n",
        "    memset (&ctr, 0, sizeof (ctr));\n",
        "    ctr.start = (LLB_CT_MAP_ENTRIES / LLB_MAX_LB_NODES) * xh->nodenum;\n",
        "    ctr.counter = ctr.start;\n",
        "    ctr.entries = ctr.start + (LLB_CT_MAP_ENTRIES / LLB_MAX_LB_NODES);\n",
        "    bpf_map_update_elem (mapfd, &k, &ctr, BPF_ANY);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "llb_dflt_sec_map2fd_all": [
    {
      "capabilities": [
        {
          "capability": "map_update",
          "map_update": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_map_update_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}",
                "{Type:  const void ,Var: *value}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_update"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 435,
      "endLine": 501,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "llb_dflt_sec_map2fd_all",
      "developer_inline_comments": [
        {
          "start_line": 486,
          "end_line": 486,
          "text": " Clean previous pins "
        },
        {
          "start_line": 491,
          "end_line": 491,
          "text": " This will pin all maps in our bpf_object "
        },
        {
          "start_line": 495,
          "end_line": 495,
          "text": "assert(0);"
        }
      ],
      "updateMaps": [
        " fd"
      ],
      "readMaps": [],
      "input": [
        "struct bpf_object *bpf_obj"
      ],
      "output": "staticint",
      "helper": [
        "bpf_map_update_elem"
      ],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int llb_dflt_sec_map2fd_all (struct bpf_object *bpf_obj)\n",
        "{\n",
        "    int i = 0;\n",
        "    int fd;\n",
        "    int bfd;\n",
        "    int err;\n",
        "    int key = 0;\n",
        "    struct bpf_program *prog;\n",
        "    const char *section;\n",
        "    for (; i < LL_DP_MAX_MAP; i++) {\n",
        "        fd = llb_objmap2fd (bpf_obj, xh -> maps [i].map_name);\n",
        "        if (fd < 0) {\n",
        "            printf (\"BPF: map2fd failed %s\\n\", xh->maps[i].map_name);\n",
        "            continue;\n",
        "        }\n",
        "        xh->maps[i].map_fd = fd;\n",
        "        if (i == LL_DP_PGM_MAP) {\n",
        "            bpf_object__for_each_program (prog, bpf_obj) {\n",
        "                bfd = bpf_program__fd (prog);\n",
        "                section = bpf_program__section_name (prog);\n",
        "                if (strcmp (section, \"tc_packet_hook0\") == 0) {\n",
        "                    key = 0;\n",
        "                }\n",
        "                else if (strcmp (section, \"tc_packet_hook1\") == 0) {\n",
        "                    key = 1;\n",
        "                }\n",
        "                else if (strcmp (section, \"tc_packet_hook2\") == 0) {\n",
        "                    key = 2;\n",
        "                }\n",
        "                else if (strcmp (section, \"tc_packet_hook3\") == 0) {\n",
        "                    key = 3;\n",
        "                }\n",
        "                else if (strcmp (section, \"tc_packet_hook4\") == 0) {\n",
        "                    key = 4;\n",
        "                }\n",
        "                else if (strcmp (section, \"tc_packet_hook5\") == 0) {\n",
        "                    key = 5;\n",
        "                }\n",
        "                else if (strcmp (section, \"tc_packet_hook6\") == 0) {\n",
        "                    key = 6;\n",
        "                }\n",
        "                else if (strcmp (section, \"tc_packet_hook7\") == 0) {\n",
        "                    key = 7;\n",
        "                }\n",
        "                else\n",
        "                    key = -1;\n",
        "                if (key >= 0) {\n",
        "                    bpf_map_update_elem (fd, &key, &bfd, BPF_ANY);\n",
        "                }\n",
        "            }\n",
        "        }\n",
        "        else if (i == LL_DP_CRC32C_MAP) {\n",
        "            llb_setup_crc32c_map (fd);\n",
        "        }\n",
        "        else if (i == LL_DP_CTCTR_MAP) {\n",
        "            llb_setup_ctctr_map (fd);\n",
        "        }\n",
        "    }\n",
        "    if (bpf_object__unpin_maps (bpf_obj, xh->ll_dp_pdir) != 0) {\n",
        "        printf (\"%s: Unpin maps failed\\n\", xh->ll_dp_pdir);\n",
        "    }\n",
        "    err = bpf_object__pin_maps (bpf_obj, xh -> ll_dp_pdir);\n",
        "    if (err) {\n",
        "        printf (\"BPF: Object pin failed\\n\");\n",
        "    }\n",
        "    llb_setup_pkt_ring (bpf_obj);\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "llb_setup_ctctr_map",
        "llb_objmap2fd",
        "llb_setup_crc32c_map"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ],
  "llb_set_dev_up": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 503,
      "endLine": 537,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "llb_set_dev_up",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "char *ifname",
        " bool up"
      ],
      "output": "staticint",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int llb_set_dev_up (char *ifname, bool up)\n",
        "{\n",
        "    struct ifreq ifr;\n",
        "    int fd;\n",
        "    if ((fd = socket (AF_INET, SOCK_DGRAM, 0)) < 0) {\n",
        "        return -1;\n",
        "    }\n",
        "    memset (&ifr, 0, sizeof (ifr));\n",
        "    memcpy (ifr.ifr_name, ifname, IFNAMSIZ);\n",
        "    ifr.ifr_ifindex = if_nametoindex (ifname);\n",
        "    if (ioctl (fd, SIOCGIFFLAGS, &ifr) < 0) {\n",
        "        close (fd);\n",
        "        return -1;\n",
        "    }\n",
        "    if (up && !(ifr.ifr_flags & IFF_UP)) {\n",
        "        ifr.ifr_flags |= IFF_UP;\n",
        "    }\n",
        "    else if (!up && ifr.ifr_flags & IFF_UP) {\n",
        "        ifr.ifr_flags &= ~IFF_UP;\n",
        "    }\n",
        "    else {\n",
        "        close (fd);\n",
        "        return 0;\n",
        "    }\n",
        "    if (ioctl (fd, SIOCSIFFLAGS, &ifr) < 0) {\n",
        "        close (fd);\n",
        "        return -1;\n",
        "    }\n",
        "    close (fd);\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "llb_mgmt_ch_init": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 539,
      "endLine": 593,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "llb_mgmt_ch_init",
      "developer_inline_comments": [
        {
          "start_line": 569,
          "end_line": 569,
          "text": " First unload eBPF/XDP "
        },
        {
          "start_line": 576,
          "end_line": 576,
          "text": " Now load eBPF/XDP "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "llb_dp_struct_t *xh"
      ],
      "output": "staticint",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int llb_mgmt_ch_init (llb_dp_struct_t *xh)\n",
        "{\n",
        "    int fd;\n",
        "    int ret;\n",
        "    struct ifreq ifr;\n",
        "    char *dev = \"/dev/net/tun\";\n",
        "    if ((fd = open (dev, O_RDWR)) < 0) {\n",
        "        return fd;\n",
        "    }\n",
        "    memset (&ifr, 0, sizeof (ifr));\n",
        "    ifr.ifr_flags = IFF_TAP | IFF_NO_PI;\n",
        "    strncpy (ifr.ifr_name, LLB_MGMT_CHANNEL, IFNAMSIZ);\n",
        "    if ((ret = ioctl (fd, TUNSETIFF, (void *) &ifr)) < 0) {\n",
        "        close (fd);\n",
        "        return ret;\n",
        "    }\n",
        "    if ((ret = ioctl (fd, TUNSETPERSIST, 1)) < 0) {\n",
        "        close (fd);\n",
        "        return ret;\n",
        "    }\n",
        "    xh->mgmt_ch_fd = fd;\n",
        "    llb_set_dev_up (LLB_MGMT_CHANNEL, 1);\n",
        "    llb_dp_link_attach (LLB_MGMT_CHANNEL, XDP_LL_SEC_DEFAULT, LL_BPF_MOUNT_XDP, 1);\n",
        "    llb_dp_link_attach (LLB_MGMT_CHANNEL, TC_LL_SEC_DEFAULT, LL_BPF_MOUNT_TC, 1);\n",
        "    ret = llb_dp_link_attach (LLB_MGMT_CHANNEL, XDP_LL_SEC_DEFAULT, LL_BPF_MOUNT_XDP, 0);\n",
        "    if (ret != 0) {\n",
        "        close (fd);\n",
        "        return ret;\n",
        "    }\n",
        "    ret = llb_dp_link_attach (LLB_MGMT_CHANNEL, TC_LL_SEC_DEFAULT, LL_BPF_MOUNT_TC, 0);\n",
        "    if (ret != 0) {\n",
        "        close (fd);\n",
        "        return ret;\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "llb_dp_link_attach",
        "llb_set_dev_up"
      ],
      "call_depth": 6,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "llb_xh_init": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 595,
      "endLine": 784,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "llb_xh_init",
      "developer_inline_comments": [
        {
          "start_line": 731,
          "end_line": 731,
          "text": " MAX_CPUS "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "llb_dp_struct_t *xh"
      ],
      "output": "staticvoid",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static void llb_xh_init (llb_dp_struct_t *xh)\n",
        "{\n",
        "    xh->ll_dp_fname = LLB_FP_IMG_DEFAULT;\n",
        "    xh->ll_tc_fname = LLB_FP_IMG_BPF;\n",
        "    xh->ll_dp_dfl_sec = XDP_LL_SEC_DEFAULT;\n",
        "    xh->ll_dp_pdir = LLB_DB_MAP_PDIR;\n",
        "    xh->maps[LL_DP_INTF_MAP].map_name = \"intf_map\";\n",
        "    xh->maps[LL_DP_INTF_MAP].has_pb = 0;\n",
        "    xh->maps[LL_DP_INTF_MAP].max_entries = LLB_INTF_MAP_ENTRIES;\n",
        "    xh->maps[LL_DP_INTF_STATS_MAP].map_name = \"intf_stats_map\";\n",
        "    xh->maps[LL_DP_INTF_STATS_MAP].has_pb = 1;\n",
        "    xh->maps[LL_DP_INTF_STATS_MAP].max_entries = LLB_INTERFACES;\n",
        "    xh->maps[LL_DP_INTF_STATS_MAP].pbs = calloc (LLB_INTERFACES, sizeof (struct dp_pbc_stats));\n",
        "    xh->maps[LL_DP_BD_STATS_MAP].map_name = \"bd_stats_map\";\n",
        "    xh->maps[LL_DP_BD_STATS_MAP].has_pb = 1;\n",
        "    xh->maps[LL_DP_BD_STATS_MAP].max_entries = LLB_INTF_MAP_ENTRIES;\n",
        "    xh->maps[LL_DP_BD_STATS_MAP].pbs = calloc (LLB_INTF_MAP_ENTRIES, sizeof (struct dp_pbc_stats));\n",
        "    xh->maps[LL_DP_SMAC_MAP].map_name = \"smac_map\";\n",
        "    xh->maps[LL_DP_SMAC_MAP].has_pb = 0;\n",
        "    xh->maps[LL_DP_SMAC_MAP].max_entries = LLB_SMAC_MAP_ENTRIES;\n",
        "    xh->maps[LL_DP_TMAC_MAP].map_name = \"tmac_map\";\n",
        "    xh->maps[LL_DP_TMAC_MAP].has_pb = 1;\n",
        "    xh->maps[LL_DP_TMAC_MAP].pb_xtid = LL_DP_TMAC_STATS_MAP;\n",
        "    xh->maps[LL_DP_TMAC_MAP].max_entries = LLB_TMAC_MAP_ENTRIES;\n",
        "    xh->maps[LL_DP_TMAC_STATS_MAP].map_name = \"tmac_stats_map\";\n",
        "    xh->maps[LL_DP_TMAC_STATS_MAP].has_pb = 1;\n",
        "    xh->maps[LL_DP_TMAC_STATS_MAP].max_entries = LLB_TMAC_MAP_ENTRIES;\n",
        "    xh->maps[LL_DP_TMAC_STATS_MAP].pbs = calloc (LLB_TMAC_MAP_ENTRIES, sizeof (struct dp_pbc_stats));\n",
        "    xh->maps[LL_DP_CT_MAP].map_name = \"ct_map\";\n",
        "    xh->maps[LL_DP_CT_MAP].has_pb = 0;\n",
        "    xh->maps[LL_DP_CT_MAP].max_entries = LLB_CT_MAP_ENTRIES;\n",
        "    xh->maps[LL_DP_CT_STATS_MAP].map_name = \"ct_stats_map\";\n",
        "    xh->maps[LL_DP_CT_STATS_MAP].has_pb = 1;\n",
        "    xh->maps[LL_DP_CT_STATS_MAP].max_entries = LLB_CT_MAP_ENTRIES;\n",
        "    xh->maps[LL_DP_CT_STATS_MAP].pbs = calloc (LLB_CT_MAP_ENTRIES, sizeof (struct dp_pbc_stats));\n",
        "    assert (xh->maps[LL_DP_CT_STATS_MAP].pbs);\n",
        "    xh->maps[LL_DP_RTV4_MAP].map_name = \"rt_v4_map\";\n",
        "    xh->maps[LL_DP_RTV4_MAP].has_pb = 1;\n",
        "    xh->maps[LL_DP_RTV4_MAP].pb_xtid = LL_DP_RTV4_STATS_MAP;\n",
        "    xh->maps[LL_DP_RTV4_MAP].max_entries = LLB_RTV4_MAP_ENTRIES;\n",
        "    xh->maps[LL_DP_RTV4_STATS_MAP].map_name = \"rt_v4_stats_map\";\n",
        "    xh->maps[LL_DP_RTV4_STATS_MAP].has_pb = 1;\n",
        "    xh->maps[LL_DP_RTV4_STATS_MAP].max_entries = LLB_RTV4_MAP_ENTRIES;\n",
        "    xh->maps[LL_DP_RTV4_STATS_MAP].pbs = calloc (LLB_RTV4_MAP_ENTRIES, sizeof (struct dp_pbc_stats));\n",
        "    xh->maps[LL_DP_RTV6_MAP].map_name = \"rt_v6_map\";\n",
        "    xh->maps[LL_DP_RTV6_MAP].has_pb = 1;\n",
        "    xh->maps[LL_DP_RTV6_MAP].pb_xtid = LL_DP_RTV6_STATS_MAP;\n",
        "    xh->maps[LL_DP_RTV6_MAP].max_entries = LLB_RTV6_MAP_ENTRIES;\n",
        "    xh->maps[LL_DP_RTV6_STATS_MAP].map_name = \"rt_v6_stats_map\";\n",
        "    xh->maps[LL_DP_RTV6_STATS_MAP].has_pb = 1;\n",
        "    xh->maps[LL_DP_RTV6_STATS_MAP].max_entries = LLB_RTV6_MAP_ENTRIES;\n",
        "    xh->maps[LL_DP_RTV6_STATS_MAP].pbs = calloc (LLB_RTV6_MAP_ENTRIES, sizeof (struct dp_pbc_stats));\n",
        "    xh->maps[LL_DP_NH_MAP].map_name = \"nh_map\";\n",
        "    xh->maps[LL_DP_NH_MAP].has_pb = 0;\n",
        "    xh->maps[LL_DP_NH_MAP].max_entries = LLB_NH_MAP_ENTRIES;\n",
        "    xh->maps[LL_DP_DMAC_MAP].map_name = \"dmac_map\";\n",
        "    xh->maps[LL_DP_DMAC_MAP].has_pb = 0;\n",
        "    xh->maps[LL_DP_DMAC_MAP].max_entries = LLB_DMAC_MAP_ENTRIES;\n",
        "    xh->maps[LL_DP_TX_INTF_MAP].map_name = \"tx_intf_map\";\n",
        "    xh->maps[LL_DP_TX_INTF_MAP].has_pb = 0;\n",
        "    xh->maps[LL_DP_TX_INTF_MAP].max_entries = LLB_INTF_MAP_ENTRIES;\n",
        "    xh->maps[LL_DP_MIRROR_MAP].map_name = \"mirr_map\";\n",
        "    xh->maps[LL_DP_MIRROR_MAP].has_pb = 0;\n",
        "    xh->maps[LL_DP_MIRROR_MAP].max_entries = LLB_MIRR_MAP_ENTRIES;\n",
        "    xh->maps[LL_DP_TX_INTF_STATS_MAP].map_name = \"tx_intf_stats_map\";\n",
        "    xh->maps[LL_DP_TX_INTF_STATS_MAP].has_pb = 1;\n",
        "    xh->maps[LL_DP_TX_INTF_STATS_MAP].max_entries = LLB_INTERFACES;\n",
        "    xh->maps[LL_DP_TX_INTF_STATS_MAP].pbs = calloc (LLB_INTERFACES, sizeof (struct dp_pbc_stats));\n",
        "    xh->maps[LL_DP_TX_BD_STATS_MAP].map_name = \"tx_bd_stats_map\";\n",
        "    xh->maps[LL_DP_TX_BD_STATS_MAP].has_pb = 1;\n",
        "    xh->maps[LL_DP_TX_BD_STATS_MAP].max_entries = LLB_INTF_MAP_ENTRIES;\n",
        "    xh->maps[LL_DP_TX_BD_STATS_MAP].pbs = calloc (LLB_INTF_MAP_ENTRIES, sizeof (struct dp_pbc_stats));\n",
        "    xh->maps[LL_DP_FCV4_MAP].map_name = \"fc_v4_map\";\n",
        "    xh->maps[LL_DP_FCV4_MAP].has_pb = 0;\n",
        "    xh->maps[LL_DP_FCV4_MAP].max_entries = LLB_FCV4_MAP_ENTRIES;\n",
        "    xh->maps[LL_DP_FCV4_STATS_MAP].map_name = \"fc_v4_stats_map\";\n",
        "    xh->maps[LL_DP_FCV4_STATS_MAP].has_pb = 1;\n",
        "    xh->maps[LL_DP_FCV4_STATS_MAP].max_entries = LLB_FCV4_MAP_ENTRIES;\n",
        "    xh->maps[LL_DP_FCV4_STATS_MAP].pbs = calloc (LLB_FCV4_MAP_ENTRIES, sizeof (struct dp_pbc_stats));\n",
        "    xh->maps[LL_DP_PGM_MAP].map_name = \"pgm_tbl\";\n",
        "    xh->maps[LL_DP_PGM_MAP].has_pb = 0;\n",
        "    xh->maps[LL_DP_PGM_MAP].max_entries = LLB_PGM_MAP_ENTRIES;\n",
        "    xh->maps[LL_DP_POL_MAP].map_name = \"polx_map\";\n",
        "    xh->maps[LL_DP_POL_MAP].has_pb = 0;\n",
        "    xh->maps[LL_DP_POL_MAP].has_pol = 1;\n",
        "    xh->maps[LL_DP_POL_MAP].max_entries = LLB_POL_MAP_ENTRIES;\n",
        "    xh->maps[LL_DP_FCV4_MAP].map_name = \"fc_v4_map\";\n",
        "    xh->maps[LL_DP_FCV4_MAP].has_pb = 0;\n",
        "    xh->maps[LL_DP_FCV4_MAP].max_entries = LLB_FCV4_MAP_ENTRIES;\n",
        "    xh->maps[LL_DP_NAT_MAP].map_name = \"nat_map\";\n",
        "    xh->maps[LL_DP_NAT_MAP].has_pb = 1;\n",
        "    xh->maps[LL_DP_NAT_MAP].pb_xtid = LL_DP_NAT_STATS_MAP;\n",
        "    xh->maps[LL_DP_NAT_MAP].max_entries = LLB_NATV4_MAP_ENTRIES;\n",
        "    xh->maps[LL_DP_NAT_STATS_MAP].map_name = \"nat_stats_map\";\n",
        "    xh->maps[LL_DP_NAT_STATS_MAP].has_pb = 1;\n",
        "    xh->maps[LL_DP_NAT_STATS_MAP].max_entries = LLB_NATV4_STAT_MAP_ENTRIES;\n",
        "    xh->maps[LL_DP_NAT_STATS_MAP].pbs = calloc (LLB_NATV4_STAT_MAP_ENTRIES, sizeof (struct dp_pbc_stats));\n",
        "    xh->maps[LL_DP_PKT_PERF_RING].map_name = \"pkt_ring\";\n",
        "    xh->maps[LL_DP_PKT_PERF_RING].has_pb = 0;\n",
        "    xh->maps[LL_DP_PKT_PERF_RING].max_entries = 128;\n",
        "    xh->maps[LL_DP_SESS4_MAP].map_name = \"sess_v4_map\";\n",
        "    xh->maps[LL_DP_SESS4_MAP].has_pb = 1;\n",
        "    xh->maps[LL_DP_SESS4_MAP].pb_xtid = LL_DP_SESS4_STATS_MAP;\n",
        "    xh->maps[LL_DP_SESS4_MAP].max_entries = LLB_SESS_MAP_ENTRIES;\n",
        "    xh->maps[LL_DP_SESS4_STATS_MAP].map_name = \"sess_v4_stats_map\";\n",
        "    xh->maps[LL_DP_SESS4_STATS_MAP].has_pb = 1;\n",
        "    xh->maps[LL_DP_SESS4_STATS_MAP].max_entries = LLB_SESS_MAP_ENTRIES;\n",
        "    xh->maps[LL_DP_SESS4_STATS_MAP].pbs = calloc (LLB_SESS_MAP_ENTRIES, sizeof (struct dp_pbc_stats));\n",
        "    xh->maps[LL_DP_FW4_MAP].map_name = \"fw_v4_map\";\n",
        "    xh->maps[LL_DP_FW4_MAP].has_pb = 1;\n",
        "    xh->maps[LL_DP_FW4_MAP].pb_xtid = LL_DP_FW4_STATS_MAP;\n",
        "    xh->maps[LL_DP_FW4_MAP].max_entries = LLB_FW4_MAP_ENTRIES;\n",
        "    xh->maps[LL_DP_FW4_STATS_MAP].map_name = \"fw_v4_stats_map\";\n",
        "    xh->maps[LL_DP_FW4_STATS_MAP].has_pb = 1;\n",
        "    xh->maps[LL_DP_FW4_STATS_MAP].max_entries = LLB_FW4_MAP_ENTRIES;\n",
        "    xh->maps[LL_DP_FW4_STATS_MAP].pbs = calloc (LLB_FW4_MAP_ENTRIES, sizeof (struct dp_pbc_stats));\n",
        "    xh->maps[LL_DP_CRC32C_MAP].map_name = \"crc32c_map\";\n",
        "    xh->maps[LL_DP_CRC32C_MAP].has_pb = 0;\n",
        "    xh->maps[LL_DP_CRC32C_MAP].max_entries = LLB_CRC32C_ENTRIES;\n",
        "    xh->maps[LL_DP_CTCTR_MAP].map_name = \"ct_ctr\";\n",
        "    xh->maps[LL_DP_CTCTR_MAP].has_pb = 0;\n",
        "    xh->maps[LL_DP_CTCTR_MAP].max_entries = 1;\n",
        "    strcpy (xh->psecs[0].name, LLB_SECTION_PASS);\n",
        "    strcpy (xh->psecs[1].name, XDP_LL_SEC_DEFAULT);\n",
        "    xh->psecs[1].setup = llb_dflt_sec_map2fd_all;\n",
        "    xh->ufw4 = pdi_map_alloc (\"ufw4\", NULL, NULL);\n",
        "    assert (xh->ufw4);\n",
        "    xh->ufw6 = pdi_map_alloc (\"ufw6\", NULL, NULL);\n",
        "    assert (xh->ufw6);\n",
        "    if (llb_mgmt_ch_init (xh) != 0) {\n",
        "        assert (0);\n",
        "    }\n",
        "    if (xh->have_mtrace) {\n",
        "        if (llb_setup_kern_mon () != 0) {\n",
        "            assert (0);\n",
        "        }\n",
        "    }\n",
        "    return;\n",
        "}\n"
      ],
      "called_function_list": [
        "llb_mgmt_ch_init",
        "pdi_map_alloc",
        "llb_setup_kern_mon"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "llb_clear_stats_pcpu_arr": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        },
        {
          "capability": "map_update",
          "map_update": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_map_update_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}",
                "{Type:  const void ,Var: *value}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_update"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 786,
      "endLine": 798,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "llb_clear_stats_pcpu_arr",
      "developer_inline_comments": [],
      "updateMaps": [
        " mfd"
      ],
      "readMaps": [
        " failed idx:0x%X\\n\""
      ],
      "input": [
        "int mfd",
        " __u32 idx"
      ],
      "output": "staticvoid",
      "helper": [
        "bpf_map_lookup_elem",
        "bpf_map_update_elem"
      ],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "cgroup_device",
        "lwt_xmit",
        "cgroup_sock",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "cgroup_sysctl",
        "sk_msg",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "perf_event",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static void llb_clear_stats_pcpu_arr (int mfd, __u32 idx)\n",
        "{\n",
        "    unsigned int nr_cpus = bpf_num_possible_cpus ();\n",
        "    struct dp_pb_stats values [nr_cpus];\n",
        "    memset (values, 0, sizeof (values));\n",
        "    if (bpf_map_update_elem (mfd, &idx, values, 0) != 0) {\n",
        "        fprintf (stderr, \"ERR: bpf_map_lookup_elem failed idx:0x%X\\n\", idx);\n",
        "        return;\n",
        "    }\n",
        "}\n"
      ],
      "called_function_list": [
        "bpf_num_possible_cpus"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "ll_get_stats_pcpu_arr": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 800,
      "endLine": 843,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "ll_get_stats_pcpu_arr",
      "developer_inline_comments": [
        {
          "start_line": 805,
          "end_line": 805,
          "text": " For percpu maps, userspace gets a value per possible CPU "
        },
        {
          "start_line": 821,
          "end_line": 821,
          "text": " Sum values from each CPU "
        }
      ],
      "updateMaps": [],
      "readMaps": [
        " failed idx:0x%X\\n\"",
        " mfd"
      ],
      "input": [
        "int mfd",
        " __u32 idx",
        " struct dp_pbc_stats *s",
        " dp_ts_cb_t cb"
      ],
      "output": "staticvoid",
      "helper": [
        "bpf_map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static void ll_get_stats_pcpu_arr (int mfd, __u32 idx, struct dp_pbc_stats *s, dp_ts_cb_t cb)\n",
        "{\n",
        "    unsigned int nr_cpus = bpf_num_possible_cpus ();\n",
        "    struct dp_pb_stats values [nr_cpus];\n",
        "    __u64 sum_bytes = 0;\n",
        "    __u64 sum_pkts = 0;\n",
        "    __u64 opc = 0;\n",
        "    int i;\n",
        "    if ((bpf_map_lookup_elem (mfd, &idx, values)) != 0) {\n",
        "        fprintf (stderr, \"ERR: bpf_map_lookup_elem failed idx:0x%X\\n\", idx);\n",
        "        return;\n",
        "    }\n",
        "    opc = s->st.packets;\n",
        "    for (i = 0; i < nr_cpus; i++) {\n",
        "        sum_pkts += values[i].packets;\n",
        "        sum_bytes += values[i].bytes;\n",
        "    }\n",
        "    s->st.packets = sum_pkts;\n",
        "    s->st.bytes = sum_bytes;\n",
        "    if (s->st.packets || s->st.bytes) {\n",
        "\n",
        "#ifdef LLB_DP_STAT_DEBUG\n",
        "        printf (\"IDX %d: %llu:%llu\\n\", idx, (unsigned long long) (s->st.packets), (unsigned long long) (s->st.bytes));\n",
        "\n",
        "#endif\n",
        "        if (s->st.packets > opc) {\n",
        "            s->used = 1;\n",
        "        }\n",
        "        if (cb) {\n",
        "            cb (idx, s->st.bytes, s->st.packets);\n",
        "        }\n",
        "    }\n",
        "}\n"
      ],
      "called_function_list": [
        "bpf_num_possible_cpus"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "llb_fetch_map_stats_raw": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 845,
      "endLine": 871,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "llb_fetch_map_stats_raw",
      "developer_inline_comments": [
        {
          "start_line": 861,
          "end_line": 861,
          "text": " FIXME : Handle non-pcpu "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "int tid",
        " dp_ts_cb_t cb",
        " dp_tiv_cb_t vcb"
      ],
      "output": "staticvoid",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static void llb_fetch_map_stats_raw (int tid, dp_ts_cb_t cb, dp_tiv_cb_t vcb)\n",
        "{\n",
        "    int e = 0;\n",
        "    llb_dp_map_t *t;\n",
        "    if (tid < 0 || tid >= LL_DP_MAX_MAP)\n",
        "        return;\n",
        "    t = &xh->maps[tid];\n",
        "    if (t->pb_xtid)\n",
        "        return;\n",
        "    if (t->has_pb) {\n",
        "        pthread_rwlock_wrlock (&t->stat_lock);\n",
        "        for (e = 0; e < t->max_entries; e++) {\n",
        "            if (vcb && vcb (tid, e) == 0) {\n",
        "                continue;\n",
        "            }\n",
        "            ll_get_stats_pcpu_arr (t->map_fd, e, &t->pbs[e], cb);\n",
        "        }\n",
        "        pthread_rwlock_unlock (&t->stat_lock);\n",
        "    }\n",
        "}\n"
      ],
      "called_function_list": [
        "ll_get_stats_pcpu_arr"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "llb_fetch_map_stats_cached": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 873,
      "endLine": 903,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "llb_fetch_map_stats_cached",
      "developer_inline_comments": [
        {
          "start_line": 890,
          "end_line": 890,
          "text": " FIXME : Handle non-pcpu "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "int tbl",
        " uint32_t e",
        " int raw",
        " void *bytes",
        " void *packets"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "int llb_fetch_map_stats_cached (int tbl, uint32_t e, int raw, void *bytes, void *packets)\n",
        "{\n",
        "    llb_dp_map_t *t;\n",
        "    if (tbl < 0 || tbl >= LL_DP_MAX_MAP)\n",
        "        return -1;\n",
        "    t = &xh->maps[tbl];\n",
        "    if (t->has_pb && t->pb_xtid > 0) {\n",
        "        if (t->pb_xtid < 0 || t->pb_xtid >= LL_DP_MAX_MAP)\n",
        "            return -1;\n",
        "        t = &xh->maps[t->pb_xtid];\n",
        "    }\n",
        "    pthread_rwlock_wrlock (&t->stat_lock);\n",
        "    if (raw) {\n",
        "        ll_get_stats_pcpu_arr (t->map_fd, e, &t->pbs[e], NULL);\n",
        "    }\n",
        "    if (e < t->max_entries) {\n",
        "        *(uint64_t*) bytes = t->pbs[e].st.bytes;\n",
        "        *(uint64_t*) packets = t->pbs[e].st.packets;\n",
        "    }\n",
        "    pthread_rwlock_unlock (&t->stat_lock);\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "ll_get_stats_pcpu_arr"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ],
  "llb_fetch_map_stats_used": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 905,
      "endLine": 934,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "llb_fetch_map_stats_used",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "int tbl",
        " uint32_t e",
        " int clr",
        " int *used"
      ],
      "output": "staticint",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int llb_fetch_map_stats_used (int tbl, uint32_t e, int clr, int *used)\n",
        "{\n",
        "    llb_dp_map_t *t;\n",
        "    if (tbl < 0 || tbl >= LL_DP_MAX_MAP)\n",
        "        return -1;\n",
        "    t = &xh->maps[tbl];\n",
        "    if (t->has_pb && t->pb_xtid > 0) {\n",
        "        if (t->pb_xtid < 0 || t->pb_xtid >= LL_DP_MAX_MAP)\n",
        "            return -1;\n",
        "        t = &xh->maps[t->pb_xtid];\n",
        "    }\n",
        "    pthread_rwlock_wrlock (&t->stat_lock);\n",
        "    if (used) {\n",
        "        *used = t->pbs[e].used;\n",
        "    }\n",
        "    if (clr) {\n",
        "        t->pbs[e].used = 0;\n",
        "    }\n",
        "    pthread_rwlock_unlock (&t->stat_lock);\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "llb_collect_map_stats": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 936,
      "endLine": 940,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "llb_collect_map_stats",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "int tid"
      ],
      "output": "void",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "void llb_collect_map_stats (int tid)\n",
        "{\n",
        "    return llb_fetch_map_stats_raw (tid, NULL, NULL);\n",
        "}\n"
      ],
      "called_function_list": [
        "llb_fetch_map_stats_raw"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ],
  "llb_fetch_pol_map_stats": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 942,
      "endLine": 972,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "llb_fetch_pol_map_stats",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [
        " failed idx:0x%X\\n\"",
        " t->map_fd"
      ],
      "input": [
        "int tid",
        " uint32_t e",
        " void *ppass",
        " void *pdrop"
      ],
      "output": "int",
      "helper": [
        "bpf_map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "int llb_fetch_pol_map_stats (int tid, uint32_t e, void *ppass, void *pdrop)\n",
        "{\n",
        "    llb_dp_map_t *t;\n",
        "    struct dp_pol_tact pa;\n",
        "    if (tid < 0 || tid >= LL_DP_MAX_MAP)\n",
        "        return -1;\n",
        "    t = &xh->maps[tid];\n",
        "    if (t->has_pol) {\n",
        "        pthread_rwlock_wrlock (&t->stat_lock);\n",
        "        if ((bpf_map_lookup_elem (t->map_fd, &e, &pa)) != 0) {\n",
        "            fprintf (stderr, \"ERR: bpf_map_lookup_elem failed idx:0x%X\\n\", e);\n",
        "            pthread_rwlock_unlock (&t->stat_lock);\n",
        "            return -1;\n",
        "        }\n",
        "        *(uint64_t*) ppass = pa.pol.ps.pass_packets;\n",
        "        *(uint64_t*) pdrop = pa.pol.ps.drop_packets;\n",
        "        pthread_rwlock_unlock (&t->stat_lock);\n",
        "        return 0;\n",
        "    }\n",
        "    return -1;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ],
  "llb_map_loop_and_delete": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        },
        {
          "capability": "map_update",
          "map_update": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Delete entry with <[ key ]>(IP: 1) from map. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_map_delete_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_update"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 974,
      "endLine": 1007,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "llb_map_loop_and_delete",
      "developer_inline_comments": [],
      "updateMaps": [
        " t->map_fd"
      ],
      "readMaps": [
        " t->map_fd"
      ],
      "input": [
        "int tid",
        " dp_map_walker_t cb",
        " dp_map_ita_t *it"
      ],
      "output": "void",
      "helper": [
        "bpf_map_lookup_elem",
        "bpf_map_delete_elem"
      ],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "cgroup_device",
        "lwt_xmit",
        "cgroup_sock",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "cgroup_sysctl",
        "sk_msg",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "perf_event",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "void llb_map_loop_and_delete (int tid, dp_map_walker_t cb, dp_map_ita_t *it)\n",
        "{\n",
        "    void *key = NULL;\n",
        "    llb_dp_map_t *t;\n",
        "    int n = 0;\n",
        "    if (!cb)\n",
        "        return;\n",
        "    if (tid < 0 || tid >= LL_DP_MAX_MAP)\n",
        "        return;\n",
        "    t = &xh->maps[tid];\n",
        "    while (bpf_map_get_next_key (t->map_fd, key, it->next_key) == 0) {\n",
        "        if (n >= t->max_entries)\n",
        "            break;\n",
        "        if (bpf_map_lookup_elem (t->map_fd, it->next_key, it->val) != 0) {\n",
        "            goto next;\n",
        "        }\n",
        "        if (cb (tid, it->next_key, it)) {\n",
        "            llb_maptrace_uhook (tid, 0, it->next_key, it->key_sz, NULL, 0);\n",
        "            bpf_map_delete_elem (t->map_fd, it->next_key);\n",
        "        }\n",
        "    next :\n",
        "        key = it->next_key;\n",
        "        n++;\n",
        "    }\n",
        "    return;\n",
        "}\n"
      ],
      "called_function_list": [
        "llb_maptrace_uhook"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "llb_clear_map_stats": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1009,
      "endLine": 1041,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "llb_clear_map_stats",
      "developer_inline_comments": [
        {
          "start_line": 1020,
          "end_line": 1020,
          "text": " FIXME : Handle non-pcpu "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "int tid",
        " __u32 idx"
      ],
      "output": "void",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "void llb_clear_map_stats (int tid, __u32 idx)\n",
        "{\n",
        "    int e = 0;\n",
        "    llb_dp_map_t *t;\n",
        "    if (tid < 0 || tid >= LL_DP_MAX_MAP)\n",
        "        return;\n",
        "    t = &xh->maps[tid];\n",
        "    if (t->has_pb && t->pb_xtid <= 0) {\n",
        "        if (idx >= 0) {\n",
        "            llb_clear_stats_pcpu_arr (t->map_fd, idx);\n",
        "        }\n",
        "        else {\n",
        "            for (e = 0; e < t->max_entries; e++) {\n",
        "                llb_clear_stats_pcpu_arr (t->map_fd, e);\n",
        "            }\n",
        "        }\n",
        "    }\n",
        "    else if (t->has_pb && t->pb_xtid > 0) {\n",
        "        if (t->pb_xtid < 0 || t->pb_xtid >= LL_DP_MAX_MAP)\n",
        "            return;\n",
        "        t = &xh->maps[t->pb_xtid];\n",
        "        if (!t->has_pb || t->pb_xtid > 0) {\n",
        "            return;\n",
        "        }\n",
        "        if (idx >= 0) {\n",
        "            llb_clear_stats_pcpu_arr (t->map_fd, idx);\n",
        "        }\n",
        "    }\n",
        "}\n"
      ],
      "called_function_list": [
        "llb_clear_stats_pcpu_arr"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "llb_map2fd": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1043,
      "endLine": 1047,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "llb_map2fd",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "int t"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "int llb_map2fd (int t)\n",
        "{\n",
        "    return xh->maps[t].map_fd;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "llb_add_map_elem_nat_post_proc": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1051,
      "endLine": 1076,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "llb_add_map_elem_nat_post_proc",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *k",
        " void *v"
      ],
      "output": "staticint",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int llb_add_map_elem_nat_post_proc (void *k, void *v)\n",
        "{\n",
        "    struct dp_nat_tacts *na = v;\n",
        "    struct mf_xfrm_inf *ep_arm;\n",
        "    uint32_t inact_aids [LLB_MAX_NXFRMS];\n",
        "    int i = 0;\n",
        "    int j = 0;\n",
        "    memset (inact_aids, 0, sizeof (inact_aids));\n",
        "    for (i = 0; i < na->nxfrm && i < LLB_MAX_NXFRMS; i++) {\n",
        "        ep_arm = &na->nxfrms[i];\n",
        "        if (ep_arm->inactive) {\n",
        "            inact_aids[j++] = i;\n",
        "        }\n",
        "    }\n",
        "    if (j > 0) {\n",
        "        ll_map_ct_rm_related (na->ca.cidx, inact_aids, j);\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "ll_map_ct_rm_related"
      ],
      "call_depth": 5,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "llb_dp_pdik2_ufw4": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1078,
      "endLine": 1090,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "llb_dp_pdik2_ufw4",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct pdi_rule *new",
        " struct pdi_key *k"
      ],
      "output": "staticvoid",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static void llb_dp_pdik2_ufw4 (struct pdi_rule *new, struct pdi_key *k)\n",
        "{\n",
        "    memset (k, 0, sizeof (struct pdi_key));\n",
        "    PDI_MATCH_COPY (&k->dest, &new->key.dest);\n",
        "    PDI_MATCH_COPY (&k->source, &new->key.source);\n",
        "    PDI_RMATCH_COPY (&k->sport, &new->key.sport);\n",
        "    PDI_RMATCH_COPY (&k->dport, &new->key.dport);\n",
        "    PDI_MATCH_COPY (&k->inport, &new->key.inport);\n",
        "    PDI_MATCH_COPY (&k->protocol, &new->key.protocol);\n",
        "    PDI_MATCH_COPY (&k->zone, &new->key.zone);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "llb_dp_ufw42_pdik": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1092,
      "endLine": 1102,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "llb_dp_ufw42_pdik",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct pdi_rule *new",
        " struct pdi_key *k"
      ],
      "output": "staticvoid",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static void llb_dp_ufw42_pdik (struct pdi_rule *new, struct pdi_key *k)\n",
        "{\n",
        "    PDI_MATCH_COPY (&new->key.dest, &k->dest);\n",
        "    PDI_MATCH_COPY (&new->key.source, &k->source);\n",
        "    PDI_RMATCH_COPY (&new->key.sport, &k->sport);\n",
        "    PDI_RMATCH_COPY (&new->key.dport, &k->dport);\n",
        "    PDI_MATCH_COPY (&new->key.inport, &k->inport);\n",
        "    PDI_MATCH_COPY (&new->key.protocol, &k->protocol);\n",
        "    PDI_MATCH_COPY (&new->key.zone, &k->zone);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "llb_dp_pdiop2_ufw4": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1104,
      "endLine": 1129,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "llb_dp_pdiop2_ufw4",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct pdi_rule *new",
        " struct dp_fwv4_ent *e"
      ],
      "output": "staticvoid",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static void llb_dp_pdiop2_ufw4 (struct pdi_rule *new, struct dp_fwv4_ent *e)\n",
        "{\n",
        "    memset (&e->fwa, 0, sizeof (e->fwa));\n",
        "    e->fwa.ca.cidx = new->data.rid;\n",
        "    e->fwa.ca.mark = new->data.opts.mark;\n",
        "    e->fwa.ca.record = new->data.opts.record;\n",
        "    switch (new->data.op) {\n",
        "    case PDI_SET_DROP :\n",
        "        e->fwa.ca.act_type = DP_SET_DROP;\n",
        "        break;\n",
        "    case PDI_SET_TRAP :\n",
        "        e->fwa.ca.act_type = DP_SET_TOCP;\n",
        "        break;\n",
        "    case PDI_SET_RDR :\n",
        "        e->fwa.ca.act_type = DP_SET_RDR_PORT;\n",
        "        e->fwa.port_act.oport = new->data.opts.port;\n",
        "        break;\n",
        "    case PDI_SET_FWD :\n",
        "        e->fwa.ca.act_type = DP_SET_NOP;\n",
        "        break;\n",
        "    default :\n",
        "        break;\n",
        "    }\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "llb_dp_ufw42_pdiop": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1131,
      "endLine": 1155,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "llb_dp_ufw42_pdiop",
      "developer_inline_comments": [
        {
          "start_line": 1135,
          "end_line": 1135,
          "text": " Overloaded field"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct pdi_rule *new",
        " struct dp_fwv4_ent *e"
      ],
      "output": "staticvoid",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static void llb_dp_ufw42_pdiop (struct pdi_rule *new, struct dp_fwv4_ent *e)\n",
        "{\n",
        "    new->data.rid = e->fwa.ca.cidx;\n",
        "    new->data.pref = e->fwa.ca.oaux;\n",
        "    new->data.opts.mark = e->fwa.ca.mark;\n",
        "    new->data.opts.record = e->fwa.ca.record;\n",
        "    switch (e->fwa.ca.act_type) {\n",
        "    case DP_SET_DROP :\n",
        "        new->data.op = PDI_SET_DROP;\n",
        "        break;\n",
        "    case DP_SET_TOCP :\n",
        "        new->data.op = PDI_SET_TRAP;\n",
        "        break;\n",
        "    case DP_SET_RDR_PORT :\n",
        "        new->data.op = PDI_SET_RDR;\n",
        "        new->data.opts.port = e->fwa.port_act.oport;\n",
        "        break;\n",
        "    case DP_SET_NOP :\n",
        "        new->data.op = PDI_SET_FWD;\n",
        "    default :\n",
        "        break;\n",
        "    }\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "llb_add_mf_map_elem__": [
    {
      "capabilities": [
        {
          "capability": "map_update",
          "map_update": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_map_update_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}",
                "{Type:  const void ,Var: *value}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_update"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1157,
      "endLine": 1199,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "llb_add_mf_map_elem__",
      "developer_inline_comments": [],
      "updateMaps": [
        " llb_map2fd tbl)"
      ],
      "readMaps": [],
      "input": [
        "int tbl",
        " void *k",
        " void *v"
      ],
      "output": "int",
      "helper": [
        "bpf_map_update_elem"
      ],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "int llb_add_mf_map_elem__ (int tbl, void *k, void *v)\n",
        "{\n",
        "    int ret = 0;\n",
        "    int n = 0;\n",
        "    int nr = 0;\n",
        "    struct dp_fwv4_ent p = {0}\n",
        "    ;\n",
        "    if (tbl == LL_DP_FW4_MAP) {\n",
        "        struct dp_fwv4_ent *e = k;\n",
        "        struct pdi_rule *new = calloc (1, sizeof (struct pdi_rule));\n",
        "        if (!new)\n",
        "            return -1;\n",
        "        llb_dp_ufw42_pdik (new, &e->k);\n",
        "        llb_dp_ufw42_pdiop (new, e);\n",
        "        ret = pdi_rule_insert (xh -> ufw4, new, & nr);\n",
        "        if (ret != 0) {\n",
        "            free (new);\n",
        "            return -1;\n",
        "        }\n",
        "        PDI_MAP_LOCK (xh->ufw4);\n",
        "        FOR_EACH_PDI_ENT (xh -> ufw4, new) {\n",
        "            if (n == 0 || n >= nr) {\n",
        "                memset (&p, 0, sizeof (p));\n",
        "                llb_dp_pdik2_ufw4 (new, &p.k);\n",
        "                llb_dp_pdiop2_ufw4 (new, &p);\n",
        "                if (n == 0) {\n",
        "                    PDI_VAL_INIT (&p.k.nr, xh->ufw4->nr);\n",
        "                }\n",
        "                ret = bpf_map_update_elem (llb_map2fd (tbl), & n, & p, 0);\n",
        "                if (ret != 0) {\n",
        "                    ret = -EFAULT;\n",
        "                }\n",
        "            }\n",
        "            n++;\n",
        "        }\n",
        "\n",
        "        PDI_MAP_ULOCK (xh->ufw4);\n",
        "    }\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "llb_dp_pdiop2_ufw4",
        "pdi_rule_insert",
        "llb_dp_ufw42_pdiop",
        "llb_dp_ufw42_pdik",
        "llb_dp_pdik2_ufw4",
        "llb_map2fd"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "llb_add_map_elem": [
    {
      "capabilities": [
        {
          "capability": "map_update",
          "map_update": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_map_update_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}",
                "{Type:  const void ,Var: *value}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_update"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1201,
      "endLine": 1246,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "llb_add_map_elem",
      "developer_inline_comments": [
        {
          "start_line": 1211,
          "end_line": 1211,
          "text": " Any table which has stats pb needs to get stats cleared before use "
        },
        {
          "start_line": 1238,
          "end_line": 1238,
          "text": " Need some post-processing for certain maps "
        }
      ],
      "updateMaps": [
        " llb_map2fd tbl)"
      ],
      "readMaps": [],
      "input": [
        "int tbl",
        " void *k",
        " void *v"
      ],
      "output": "int",
      "helper": [
        "bpf_map_update_elem"
      ],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "int llb_add_map_elem (int tbl, void *k, void *v)\n",
        "{\n",
        "    int ret = -EINVAL;\n",
        "    if (tbl < 0 || tbl >= LL_DP_MAX_MAP) {\n",
        "        return ret;\n",
        "    }\n",
        "    XH_LOCK ();\n",
        "    if (tbl == LL_DP_NAT_MAP || tbl == LL_DP_TMAC_MAP || tbl == LL_DP_TMAC_MAP || tbl == LL_DP_FW4_MAP || tbl == LL_DP_RTV4_MAP) {\n",
        "        __u32 cidx = 0;\n",
        "        if (tbl == LL_DP_FW4_MAP) {\n",
        "            struct dp_fwv4_ent *e = k;\n",
        "            cidx = e->fwa.ca.cidx;\n",
        "        }\n",
        "        else {\n",
        "            struct dp_cmn_act *ca = v;\n",
        "            cidx = ca->cidx;\n",
        "        }\n",
        "        llb_clear_map_stats (tbl, cidx);\n",
        "    }\n",
        "    if (tbl == LL_DP_FW4_MAP) {\n",
        "        ret = llb_add_mf_map_elem__ (tbl, k, v);\n",
        "    }\n",
        "    else {\n",
        "        ret = bpf_map_update_elem (llb_map2fd (tbl), k, v, 0);\n",
        "    }\n",
        "    if (ret != 0) {\n",
        "        ret = -EFAULT;\n",
        "    }\n",
        "    else {\n",
        "        if (tbl == LL_DP_NAT_MAP) {\n",
        "            llb_add_map_elem_nat_post_proc (k, v);\n",
        "        }\n",
        "    }\n",
        "    XH_UNLOCK ();\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "llb_add_mf_map_elem__",
        "llb_clear_map_stats",
        "llb_map2fd",
        "llb_add_map_elem_nat_post_proc"
      ],
      "call_depth": 6,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ],
  "ll_map_elem_cmp_cidx": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1248,
      "endLine": 1266,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "ll_map_elem_cmp_cidx",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "int tid",
        " void *k",
        " void *ita"
      ],
      "output": "staticint",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int ll_map_elem_cmp_cidx (int tid, void *k, void *ita)\n",
        "{\n",
        "    dp_map_ita_t *it = ita;\n",
        "    uint32_t cidx;\n",
        "    if (!it || !it->uarg || !it->val)\n",
        "        return 0;\n",
        "    cidx = *(uint32_t*) it->uarg;\n",
        "    if (tid == LL_DP_CT_MAP || tid == LL_DP_TMAC_MAP || tid == LL_DP_RTV4_MAP) {\n",
        "        struct dp_cmn_act *ca = it->val;\n",
        "        if (ca->cidx == cidx)\n",
        "            return 1;\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ],
  "llb_del_map_elem_with_cidx": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1268,
      "endLine": 1284,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "llb_del_map_elem_with_cidx",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "int tbl",
        " uint32_t cidx"
      ],
      "output": "staticvoid",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static void llb_del_map_elem_with_cidx (int tbl, uint32_t cidx)\n",
        "{\n",
        "    dp_map_ita_t it;\n",
        "    uint8_t skey [1024];\n",
        "    uint8_t sval [1024];\n",
        "    memset (&it, 0, sizeof (it));\n",
        "    memset (&skey, 0, sizeof (skey));\n",
        "    memset (&sval, 0, sizeof (sval));\n",
        "    it.next_key = &skey;\n",
        "    it.val = &sval;\n",
        "    it.uarg = &cidx;\n",
        "    llb_map_loop_and_delete (tbl, ll_map_elem_cmp_cidx, &it);\n",
        "}\n"
      ],
      "called_function_list": [
        "llb_map_loop_and_delete"
      ],
      "call_depth": 4,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "llb_del_mf_map_elem__": [
    {
      "capabilities": [
        {
          "capability": "map_update",
          "map_update": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_map_update_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}",
                "{Type:  const void ,Var: *value}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_update"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1286,
      "endLine": 1336,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "llb_del_mf_map_elem__",
      "developer_inline_comments": [],
      "updateMaps": [
        " llb_map2fd tbl)"
      ],
      "readMaps": [],
      "input": [
        "int tbl",
        " void *k"
      ],
      "output": "int",
      "helper": [
        "bpf_map_update_elem"
      ],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "int llb_del_mf_map_elem__ (int tbl, void *k)\n",
        "{\n",
        "    int ret = 0;\n",
        "    int n = 0;\n",
        "    int nr = 0;\n",
        "    struct dp_fwv4_ent p = {0}\n",
        "    ;\n",
        "    if (tbl == LL_DP_FW4_MAP) {\n",
        "        struct dp_fwv4_ent *e = k;\n",
        "        struct pdi_rule *new = calloc (1, sizeof (struct pdi_rule));\n",
        "        if (!new)\n",
        "            return -1;\n",
        "        llb_dp_ufw42_pdik (new, &e->k);\n",
        "        llb_dp_ufw42_pdiop (new, e);\n",
        "        ret = pdi_rule_delete (xh -> ufw4, & new -> key, new -> data.pref, & nr);\n",
        "        if (ret != 0) {\n",
        "            free (new);\n",
        "            return -1;\n",
        "        }\n",
        "        free (new);\n",
        "        PDI_MAP_LOCK (xh->ufw4);\n",
        "        FOR_EACH_PDI_ENT (xh -> ufw4, new) {\n",
        "            if (n == 0 || n >= nr) {\n",
        "                memset (&p, 0, sizeof (p));\n",
        "                llb_dp_pdik2_ufw4 (new, &p.k);\n",
        "                llb_dp_pdiop2_ufw4 (new, &p);\n",
        "                if (n == 0) {\n",
        "                    PDI_VAL_INIT (&p.k.nr, xh->ufw4->nr);\n",
        "                }\n",
        "                ret = bpf_map_update_elem (llb_map2fd (tbl), & n, & p, 0);\n",
        "                if (ret != 0) {\n",
        "                    ret = -EFAULT;\n",
        "                }\n",
        "            }\n",
        "            n++;\n",
        "        }\n",
        "\n",
        "        PDI_MAP_ULOCK (xh->ufw4);\n",
        "        while (n < LLB_FW4_MAP_ENTRIES) {\n",
        "            memset (&p, 0, sizeof (p));\n",
        "            bpf_map_update_elem (llb_map2fd (tbl), &n, &p, 0);\n",
        "            n++;\n",
        "        }\n",
        "    }\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "llb_dp_pdiop2_ufw4",
        "pdi_rule_delete",
        "llb_dp_ufw42_pdiop",
        "llb_dp_ufw42_pdik",
        "llb_dp_pdik2_ufw4",
        "llb_map2fd"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "llb_del_map_elem": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        },
        {
          "capability": "map_update",
          "map_update": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Delete entry with <[ key ]>(IP: 1) from map. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_map_delete_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_update"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1338,
      "endLine": 1380,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "llb_del_map_elem",
      "developer_inline_comments": [
        {
          "start_line": 1349,
          "end_line": 1349,
          "text": " Need some pre-processing for certain maps "
        },
        {
          "start_line": 1369,
          "end_line": 1369,
          "text": " Need some post-processing for certain maps "
        }
      ],
      "updateMaps": [
        " llb_map2fd tbl)"
      ],
      "readMaps": [
        " llb_map2fd tbl)"
      ],
      "input": [
        "int tbl",
        " void *k"
      ],
      "output": "int",
      "helper": [
        "bpf_map_lookup_elem",
        "bpf_map_delete_elem"
      ],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "cgroup_device",
        "lwt_xmit",
        "cgroup_sock",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "cgroup_sysctl",
        "sk_msg",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "perf_event",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "int llb_del_map_elem (int tbl, void *k)\n",
        "{\n",
        "    int ret = -EINVAL;\n",
        "    uint32_t cidx = 0;\n",
        "    if (tbl < 0 || tbl >= LL_DP_MAX_MAP) {\n",
        "        return ret;\n",
        "    }\n",
        "    XH_LOCK ();\n",
        "    if (tbl == LL_DP_NAT_MAP) {\n",
        "        struct dp_nat_tacts t = {0}\n",
        "        ;\n",
        "        ret = bpf_map_lookup_elem (llb_map2fd (tbl), k, & t);\n",
        "        if (ret != 0) {\n",
        "            XH_UNLOCK ();\n",
        "            return -EINVAL;\n",
        "        }\n",
        "        cidx = t.ca.cidx;\n",
        "    }\n",
        "    if (tbl == LL_DP_FW4_MAP) {\n",
        "        ret = llb_del_mf_map_elem__ (tbl, k);\n",
        "    }\n",
        "    else {\n",
        "        ret = bpf_map_delete_elem (llb_map2fd (tbl), k);\n",
        "    }\n",
        "    if (ret != 0) {\n",
        "        ret = -EFAULT;\n",
        "    }\n",
        "    if (tbl == LL_DP_NAT_MAP) {\n",
        "        if (cidx > 0) {\n",
        "            llb_del_map_elem_with_cidx (LL_DP_CT_MAP, cidx);\n",
        "            llb_clear_map_stats (LL_DP_CT_STATS_MAP, cidx);\n",
        "        }\n",
        "    }\n",
        "    XH_UNLOCK ();\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "llb_del_mf_map_elem__",
        "llb_del_map_elem_with_cidx",
        "llb_clear_map_stats",
        "llb_map2fd"
      ],
      "call_depth": 5,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ],
  "get_os_usecs": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1382,
      "endLine": 1388,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "get_os_usecs",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void"
      ],
      "output": "unsignedlonglong",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "unsigned long long get_os_usecs (void)\n",
        "{\n",
        "    struct timespec ts;\n",
        "    clock_gettime (CLOCK_MONOTONIC, &ts);\n",
        "    return ((unsigned long long) ts.tv_sec * 1000000UL) + ts.tv_nsec / 1000;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ],
  "get_os_nsecs": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1390,
      "endLine": 1397,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "get_os_nsecs",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void"
      ],
      "output": "unsignedlonglong",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "unsigned long long get_os_nsecs (void)\n",
        "{\n",
        "    struct timespec ts;\n",
        "    clock_gettime (CLOCK_MONOTONIC, &ts);\n",
        "    return ts.tv_sec * 1000000000UL + ts.tv_nsec;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "ll_fcmap_ent_has_aged": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1399,
      "endLine": 1417,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "ll_fcmap_ent_has_aged",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "int tid",
        " void *k",
        " void *ita"
      ],
      "output": "staticint",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int ll_fcmap_ent_has_aged (int tid, void *k, void *ita)\n",
        "{\n",
        "    dp_map_ita_t *it = ita;\n",
        "    struct dp_fc_tacts *fc_val;\n",
        "    uint64_t curr_ns;\n",
        "    if (!it || !it->uarg || !it->val)\n",
        "        return 0;\n",
        "    curr_ns = *(uint64_t*) it->uarg;\n",
        "    fc_val = it->val;\n",
        "    if (fc_val->its && curr_ns - fc_val->its > FC_V4_CPTO) {\n",
        "        return 1;\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ],
  "ll_age_fcmap": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1419,
      "endLine": 1437,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "ll_age_fcmap",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void"
      ],
      "output": "staticvoid",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static void ll_age_fcmap (void)\n",
        "{\n",
        "    dp_map_ita_t it;\n",
        "    struct dp_fcv4_key next_key;\n",
        "    struct dp_fc_tacts *fc_val;\n",
        "    uint64_t ns = get_os_nsecs ();\n",
        "    fc_val = calloc (1, sizeof (* fc_val));\n",
        "    if (!fc_val)\n",
        "        return;\n",
        "    memset (&it, 0, sizeof (it));\n",
        "    it.next_key = &next_key;\n",
        "    it.val = fc_val;\n",
        "    it.uarg = &ns;\n",
        "    llb_map_loop_and_delete (LL_DP_FCV4_MAP, ll_fcmap_ent_has_aged, &it);\n",
        "    if (fc_val)\n",
        "        free (fc_val);\n",
        "}\n"
      ],
      "called_function_list": [
        "get_os_nsecs",
        "llb_map_loop_and_delete"
      ],
      "call_depth": 4,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "ctm_proto_xfk_init": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1448,
      "endLine": 1508,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "ctm_proto_xfk_init",
      "developer_inline_comments": [
        {
          "start_line": 1465,
          "end_line": 1465,
          "text": " Apply NAT xfrm if needed "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct dp_ct_key *key",
        " nxfrm_inf_t *xi",
        " struct dp_ct_key *xkey"
      ],
      "output": "staticint",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int ctm_proto_xfk_init (struct dp_ct_key *key, nxfrm_inf_t *xi, struct dp_ct_key *xkey)\n",
        "{\n",
        "    DP_XADDR_CP (xkey->daddr, key->saddr);\n",
        "    DP_XADDR_CP (xkey->saddr, key->daddr);\n",
        "    xkey->sport = key->dport;\n",
        "    xkey->dport = key->sport;\n",
        "    xkey->l4proto = key->l4proto;\n",
        "    xkey->zone = key->zone;\n",
        "    xkey->v6 = key->v6;\n",
        "    if (xi->dsr) {\n",
        "        return 0;\n",
        "    }\n",
        "    if (xi->nat_flags & LLB_NAT_DST) {\n",
        "        xkey->v6 = xi->nv6;\n",
        "        DP_XADDR_CP (xkey->saddr, xi->nat_xip);\n",
        "        if (!DP_XADDR_ISZR(xi->nat_rip)) {\n",
        "            DP_XADDR_CP (xkey->daddr, xi->nat_rip);\n",
        "        }\n",
        "        if (key->l4proto != IPPROTO_ICMP) {\n",
        "            if (xi->nat_xport)\n",
        "                xkey->sport = xi->nat_xport;\n",
        "        }\n",
        "    }\n",
        "    if (xi->nat_flags & LLB_NAT_SRC) {\n",
        "        xkey->v6 = xi->nv6;\n",
        "        DP_XADDR_CP (xkey->daddr, xi->nat_xip);\n",
        "        if (!DP_XADDR_ISZR(xi->nat_rip)) {\n",
        "            DP_XADDR_CP (xkey->saddr, xi->nat_rip);\n",
        "        }\n",
        "        if (key->l4proto != IPPROTO_ICMP) {\n",
        "            if (xi->nat_xport)\n",
        "                xkey->dport = xi->nat_xport;\n",
        "        }\n",
        "    }\n",
        "    if (xi->nat_flags & LLB_NAT_HDST) {\n",
        "        DP_XADDR_CP (xkey->saddr, key->saddr);\n",
        "        DP_XADDR_CP (xkey->daddr, key->daddr);\n",
        "        if (key->l4proto != IPPROTO_ICMP) {\n",
        "            if (xi->nat_xport)\n",
        "                xkey->sport = xi->nat_xport;\n",
        "        }\n",
        "    }\n",
        "    if (xi->nat_flags & LLB_NAT_HSRC) {\n",
        "        DP_XADDR_CP (xkey->saddr, key->saddr);\n",
        "        DP_XADDR_CP (xkey->daddr, key->daddr);\n",
        "        if (key->l4proto != IPPROTO_ICMP) {\n",
        "            if (xi->nat_xport)\n",
        "                xkey->dport = xi->nat_xport;\n",
        "        }\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "ll_send_ctep_reset": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1510,
      "endLine": 1541,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "ll_send_ctep_reset",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct dp_ct_key *ep",
        " struct dp_ct_tact *adat"
      ],
      "output": "staticvoid",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static void ll_send_ctep_reset (struct dp_ct_key *ep, struct dp_ct_tact *adat)\n",
        "{\n",
        "    struct mkr_args r;\n",
        "    ct_tcp_pinf_t *ts = &adat->ctd.pi.t;\n",
        "    if (ep->l4proto != IPPROTO_TCP) {\n",
        "        return;\n",
        "    }\n",
        "    if (ts->state != CT_TCP_EST) {\n",
        "        return;\n",
        "    }\n",
        "    memset (&r, 0, sizeof (r));\n",
        "    if (ep->v6 == 0) {\n",
        "        r.sip[0] = ntohl (ep->daddr[0]);\n",
        "        r.dip[0] = ntohl (ep->saddr[0]);\n",
        "    }\n",
        "    else {\n",
        "        memcpy (r.sip, ep->daddr, 16);\n",
        "        memcpy (r.dip, ep->saddr, 16);\n",
        "        r.v6 = 1;\n",
        "    }\n",
        "    r.sport = ntohs (ep->dport);\n",
        "    r.dport = ntohs (ep->sport);\n",
        "    r.protocol = ep->l4proto;\n",
        "    r.t.seq = ntohl (adat->ctd.pi.t.tcp_cts[CT_DIR_IN].pack);\n",
        "    r.t.rst = 1;\n",
        "    create_xmit_raw_tcp (&r);\n",
        "}\n"
      ],
      "called_function_list": [
        "create_xmit_raw_tcp"
      ],
      "call_depth": 4,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "ll_ct_map_ent_has_aged": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1543,
      "endLine": 1669,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "ll_ct_map_ent_has_aged",
      "developer_inline_comments": [
        {
          "start_line": 1653,
          "end_line": 1653,
          "text": " CT is allocated both for current and reverse direction "
        }
      ],
      "updateMaps": [],
      "readMaps": [
        " t->map_fd"
      ],
      "input": [
        "int tid",
        " void *k",
        " void *ita"
      ],
      "output": "staticint",
      "helper": [
        "bpf_map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int ll_ct_map_ent_has_aged (int tid, void *k, void *ita)\n",
        "{\n",
        "    dp_map_ita_t *it = ita;\n",
        "    struct dp_ct_key *key = k;\n",
        "    struct dp_ct_key xkey;\n",
        "    struct dp_ct_dat *dat;\n",
        "    struct dp_ct_tact *adat;\n",
        "    struct dp_ct_tact axdat;\n",
        "    ct_arg_struct_t *as;\n",
        "    uint64_t curr_ns;\n",
        "    uint64_t latest_ns;\n",
        "    int used1 = 0;\n",
        "    int used2 = 0;\n",
        "    bool est = false;\n",
        "    bool has_nat = false;\n",
        "    uint64_t to = CT_V4_CPTO;\n",
        "    char dstr [INET6_ADDRSTRLEN];\n",
        "    char sstr [INET6_ADDRSTRLEN];\n",
        "    llb_dp_map_t *t;\n",
        "    if (!it || !it->uarg || !it->val)\n",
        "        return 0;\n",
        "    as = it->uarg;\n",
        "    curr_ns = as->curr_ns;\n",
        "    adat = it->val;\n",
        "    dat = &adat->ctd;\n",
        "    if (key->v6 == 0) {\n",
        "        inet_ntop (AF_INET, key->saddr, sstr, INET_ADDRSTRLEN);\n",
        "        inet_ntop (AF_INET, key->daddr, dstr, INET_ADDRSTRLEN);\n",
        "    }\n",
        "    else {\n",
        "        inet_ntop (AF_INET6, key->saddr, sstr, INET6_ADDRSTRLEN);\n",
        "        inet_ntop (AF_INET6, key->daddr, dstr, INET6_ADDRSTRLEN);\n",
        "    }\n",
        "    if (adat->ctd.xi.nat_flags) {\n",
        "        has_nat = true;\n",
        "    }\n",
        "    ctm_proto_xfk_init (key, &adat->ctd.xi, &xkey);\n",
        "    t = &xh->maps[LL_DP_CT_MAP];\n",
        "    if (bpf_map_lookup_elem (t->map_fd, &xkey, &axdat) != 0) {\n",
        "        printf (\"rdir ct4 not found %s:%d -> %s:%d (%d)\\n\", dstr, ntohs (xkey.sport), sstr, ntohs (xkey.dport), xkey.l4proto);\n",
        "        llb_clear_map_stats (LL_DP_CT_STATS_MAP, adat->ca.cidx);\n",
        "        return 1;\n",
        "    }\n",
        "    if (adat->lts > axdat.lts) {\n",
        "        latest_ns = adat->lts;\n",
        "    }\n",
        "    else {\n",
        "        latest_ns = axdat.lts;\n",
        "    }\n",
        "    if (dat->dir == CT_DIR_OUT) {\n",
        "        return 0;\n",
        "    }\n",
        "    if (key->l4proto == IPPROTO_TCP) {\n",
        "        ct_tcp_pinf_t *ts = &dat->pi.t;\n",
        "        if (ts->state & CT_TCP_FIN_MASK || ts->state & CT_TCP_ERR || ts->state & CT_TCP_SYNC_MASK || ts->state == CT_TCP_CLOSED) {\n",
        "            to = CT_TCP_FN_CPTO;\n",
        "        }\n",
        "        else if (ts->state == CT_TCP_EST) {\n",
        "            est = true;\n",
        "        }\n",
        "    }\n",
        "    else if (key->l4proto == IPPROTO_UDP) {\n",
        "        ct_udp_pinf_t *us = &dat->pi.u;\n",
        "        if (us->state & (CT_UDP_UEST | CT_UDP_EST)) {\n",
        "            to = CT_UDP_EST_CPTO;\n",
        "            est = true;\n",
        "        }\n",
        "        else {\n",
        "            to = CT_UDP_FN_CPTO;\n",
        "        }\n",
        "    }\n",
        "    else if (key->l4proto == IPPROTO_ICMP || key->l4proto == IPPROTO_ICMPV6) {\n",
        "        ct_icmp_pinf_t *is = &dat->pi.i;\n",
        "        if (is->state == CT_ICMP_REPS) {\n",
        "            est = true;\n",
        "            to = CT_ICMP_EST_CPTO;\n",
        "        }\n",
        "        else {\n",
        "            to = CT_ICMP_FN_CPTO;\n",
        "        }\n",
        "    }\n",
        "    else if (key->l4proto == IPPROTO_SCTP) {\n",
        "        ct_sctp_pinf_t *ss = &dat->pi.s;\n",
        "        if (ss->state & CT_SCTP_FIN_MASK || ss->state & CT_SCTP_ERR || (ss->state & CT_SCTP_INIT_MASK && ss->state != CT_SCTP_EST) || ss->state == CT_SCTP_CLOSED) {\n",
        "            to = CT_SCTP_FN_CPTO;\n",
        "        }\n",
        "        else if (ss->state == CT_SCTP_EST) {\n",
        "            est = true;\n",
        "        }\n",
        "    }\n",
        "    if (curr_ns < latest_ns)\n",
        "        return 0;\n",
        "    if (est && adat->ito != 0) {\n",
        "        to = adat->ito;\n",
        "    }\n",
        "    llb_fetch_map_stats_used (LL_DP_CT_STATS_MAP, adat->ca.cidx, 1, &used1);\n",
        "    llb_fetch_map_stats_used (LL_DP_CT_STATS_MAP, adat->ca.cidx + 1, 1, &used2);\n",
        "    if (curr_ns - latest_ns > to && !used1 && !used2) {\n",
        "        printf (\"##%s:%d -> %s:%d (%d):%u (Aged:%d:%d:%d)\\n\", sstr, ntohs (key->sport), dstr, ntohs (key->dport), key->l4proto, dat->rid, est, has_nat, used1 || used2);\n",
        "        ll_send_ctep_reset (key, adat);\n",
        "        ll_send_ctep_reset (&xkey, &axdat);\n",
        "        llb_clear_map_stats (LL_DP_CT_STATS_MAP, adat->ca.cidx);\n",
        "        return 1;\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "llb_fetch_map_stats_used",
        "ll_send_ctep_reset",
        "llb_clear_map_stats",
        "ctm_proto_xfk_init"
      ],
      "call_depth": 5,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ],
  "ll_age_ctmap": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1671,
      "endLine": 1700,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "ll_age_ctmap",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void"
      ],
      "output": "staticvoid",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static void ll_age_ctmap (void)\n",
        "{\n",
        "    dp_map_ita_t it;\n",
        "    struct dp_ct_key next_key;\n",
        "    struct dp_ct_tact *adat;\n",
        "    ct_arg_struct_t *as;\n",
        "    uint64_t ns = get_os_nsecs ();\n",
        "    adat = calloc (1, sizeof (* adat));\n",
        "    if (!adat)\n",
        "        return;\n",
        "    as = calloc (1, sizeof (* as));\n",
        "    if (!as) {\n",
        "        free (adat);\n",
        "        return;\n",
        "    }\n",
        "    as->curr_ns = ns;\n",
        "    memset (&it, 0, sizeof (it));\n",
        "    it.next_key = &next_key;\n",
        "    it.key_sz = sizeof (next_key);\n",
        "    it.val = adat;\n",
        "    it.uarg = as;\n",
        "    llb_map_loop_and_delete (LL_DP_CT_MAP, ll_ct_map_ent_has_aged, &it);\n",
        "    if (adat)\n",
        "        free (adat);\n",
        "    if (as)\n",
        "        free (as);\n",
        "}\n"
      ],
      "called_function_list": [
        "get_os_nsecs",
        "llb_map_loop_and_delete"
      ],
      "call_depth": 4,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "llb_age_map_entries": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1702,
      "endLine": 1717,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "llb_age_map_entries",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "int tbl"
      ],
      "output": "void",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "void llb_age_map_entries (int tbl)\n",
        "{\n",
        "    switch (tbl) {\n",
        "    case LL_DP_FCV4_MAP :\n",
        "        ll_age_fcmap ();\n",
        "        break;\n",
        "    case LL_DP_CT_MAP :\n",
        "        ll_age_ctmap ();\n",
        "        break;\n",
        "    default :\n",
        "        break;\n",
        "    }\n",
        "    return;\n",
        "}\n"
      ],
      "called_function_list": [
        "ll_age_ctmap",
        "ll_age_fcmap"
      ],
      "call_depth": 5,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ],
  "ll_ct_map_ent_rm_related": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1719,
      "endLine": 1760,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "ll_ct_map_ent_rm_related",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "int tid",
        " void *k",
        " void *ita"
      ],
      "output": "staticint",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int ll_ct_map_ent_rm_related (int tid, void *k, void *ita)\n",
        "{\n",
        "    int i = 0;\n",
        "    struct dp_ct_key *key = k;\n",
        "    dp_map_ita_t *it = ita;\n",
        "    struct dp_ct_tact *adat;\n",
        "    ct_arg_struct_t *as;\n",
        "    char dstr [INET6_ADDRSTRLEN];\n",
        "    char sstr [INET6_ADDRSTRLEN];\n",
        "    if (!it || !it->uarg || !it->val)\n",
        "        return 0;\n",
        "    as = it->uarg;\n",
        "    adat = it->val;\n",
        "    if (adat->ctd.rid != as->rid) {\n",
        "        return 0;\n",
        "    }\n",
        "    for (i = 0; i < as->n_aids; i++) {\n",
        "        if (adat->ctd.aid == as->aid[i]) {\n",
        "            if (!key->v6) {\n",
        "                inet_ntop (AF_INET, &key->saddr[0], sstr, INET_ADDRSTRLEN);\n",
        "                inet_ntop (AF_INET, &key->daddr[0], dstr, INET_ADDRSTRLEN);\n",
        "            }\n",
        "            else {\n",
        "                inet_ntop (AF_INET6, &key->saddr[0], sstr, INET6_ADDRSTRLEN);\n",
        "                inet_ntop (AF_INET6, &key->daddr[0], dstr, INET6_ADDRSTRLEN);\n",
        "            }\n",
        "            printf (\"related ct rm %s:%d -> %s:%d (%d)\\n\", sstr, ntohs (key->sport), dstr, ntohs (key->dport), key->l4proto);\n",
        "            llb_clear_map_stats (LL_DP_CT_STATS_MAP, adat->ca.cidx);\n",
        "            return 1;\n",
        "        }\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "llb_clear_map_stats"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ],
  "ll_map_ct_rm_related": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1762,
      "endLine": 1797,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "ll_map_ct_rm_related",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "uint32_t rid",
        " uint32_t *aids",
        " int naid"
      ],
      "output": "staticvoid",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static void ll_map_ct_rm_related (uint32_t rid, uint32_t *aids, int naid)\n",
        "{\n",
        "    dp_map_ita_t it;\n",
        "    int i = 0;\n",
        "    struct dp_ct_key next_key;\n",
        "    struct dp_ct_tact *adat;\n",
        "    ct_arg_struct_t *as;\n",
        "    uint64_t ns = get_os_nsecs ();\n",
        "    adat = calloc (1, sizeof (* adat));\n",
        "    if (!adat)\n",
        "        return;\n",
        "    as = calloc (1, sizeof (* as));\n",
        "    if (!as) {\n",
        "        free (adat);\n",
        "        return;\n",
        "    }\n",
        "    as->curr_ns = ns;\n",
        "    memset (&it, 0, sizeof (it));\n",
        "    it.next_key = &next_key;\n",
        "    it.val = adat;\n",
        "    it.uarg = as;\n",
        "    as->rid = rid;\n",
        "    for (i = 0; i < naid; i++) {\n",
        "        as->aid[i] = aids[i];\n",
        "    }\n",
        "    as->n_aids = naid;\n",
        "    llb_map_loop_and_delete (LL_DP_CT_MAP, ll_ct_map_ent_rm_related, &it);\n",
        "    if (adat)\n",
        "        free (adat);\n",
        "    if (as)\n",
        "        free (as);\n",
        "}\n"
      ],
      "called_function_list": [
        "get_os_nsecs",
        "llb_map_loop_and_delete"
      ],
      "call_depth": 4,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "llb_set_rlims": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1799,
      "endLine": 1811,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "llb_set_rlims",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void"
      ],
      "output": "staticvoid",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static void llb_set_rlims (void)\n",
        "{\n",
        "    struct rlimit rlim_new = {\n",
        "        .rlim_cur = RLIM_INFINITY,\n",
        "        .rlim_max = RLIM_INFINITY,}\n",
        "    ;\n",
        "    if (setrlimit (RLIMIT_MEMLOCK, &rlim_new)) {\n",
        "        fprintf (stderr, \"Failed to increase RLIMIT_MEMLOCK limit!\\n\");\n",
        "        exit (1);\n",
        "    }\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "llb_link_prop_add": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1813,
      "endLine": 1877,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "llb_link_prop_add",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const char *ifname",
        " void *obj",
        " int mp_type"
      ],
      "output": "staticint",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int llb_link_prop_add (const char *ifname, void *obj, int mp_type)\n",
        "{\n",
        "    int n = 0;\n",
        "    int i = 0;\n",
        "    int free = 0;\n",
        "    int mfree = 0;\n",
        "    llb_dp_link_t *l;\n",
        "    llb_bpf_mnt_t *m;\n",
        "    XH_LOCK ();\n",
        "    for (; n < LLB_INTERFACES; n++) {\n",
        "        l = &xh->links[n];\n",
        "        if (l->valid && strncmp (l->ifname, ifname, IFNAMSIZ) == 0) {\n",
        "            if (l->nm > MAX_MPS) {\n",
        "                XH_UNLOCK ();\n",
        "                return -1;\n",
        "            }\n",
        "            for (i = 0; i < MAX_MPS; i++) {\n",
        "                m = &l->mp[i];\n",
        "                if (m->mp_type == mp_type) {\n",
        "                    XH_UNLOCK ();\n",
        "                    return -1;\n",
        "                }\n",
        "                if (m->mp_type == LL_BPF_MOUNT_NONE && !mfree)\n",
        "                    mfree = i + 1;\n",
        "            }\n",
        "            m = &l->mp[mfree - 1];\n",
        "            m->obj = obj;\n",
        "            m->mp_type = mp_type;\n",
        "            l->nm++;\n",
        "            XH_UNLOCK ();\n",
        "            printf (\"%s: IF-%s ref idx %d:%d type %d\\n\", __FUNCTION__, ifname, n, mfree - 1, mp_type);\n",
        "            return 0;\n",
        "        }\n",
        "        if (!l->valid && !free)\n",
        "            free = n + 1;\n",
        "    }\n",
        "    if (free <= 0 || free >= LLB_INTERFACES) {\n",
        "        XH_UNLOCK ();\n",
        "        return -1;\n",
        "    }\n",
        "    l = &xh->links[free - 1];\n",
        "    memset (l, 0, sizeof (*l));\n",
        "    l->valid = 1;\n",
        "    m = &l->mp[0];\n",
        "    m->obj = obj;\n",
        "    m->mp_type = mp_type;\n",
        "    strncpy (l->ifname, ifname, IFNAMSIZ);\n",
        "    l->ifname[IFNAMSIZ - 1] = '\\0';\n",
        "    l->nm++;\n",
        "    XH_UNLOCK ();\n",
        "    printf (\"%s: IF-%s added idx %d type %d\\n\", __FUNCTION__, ifname, free - 1, mp_type);\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "llb_link_prop_del": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1879,
      "endLine": 1910,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "llb_link_prop_del",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const char *ifname",
        " int mp_type"
      ],
      "output": "staticint",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int llb_link_prop_del (const char *ifname, int mp_type)\n",
        "{\n",
        "    int n = 0;\n",
        "    int i = 0;\n",
        "    llb_dp_link_t *l;\n",
        "    llb_bpf_mnt_t *m;\n",
        "    XH_LOCK ();\n",
        "    for (; n < LLB_INTERFACES; n++) {\n",
        "        l = &xh->links[n];\n",
        "        if (strncmp (l->ifname, ifname, IFNAMSIZ) == 0) {\n",
        "            for (i = 0; i < MAX_MPS; i++) {\n",
        "                m = &l->mp[i];\n",
        "                if (m->mp_type == mp_type) {\n",
        "                    m->obj = NULL;\n",
        "                    m->mp_type = LL_BPF_MOUNT_NONE;\n",
        "                    l->nm--;\n",
        "                    break;\n",
        "                }\n",
        "            }\n",
        "            if (l->nm == 0) {\n",
        "                memset (l, 0, sizeof (*l));\n",
        "            }\n",
        "            XH_UNLOCK ();\n",
        "            return 0;\n",
        "        }\n",
        "    }\n",
        "    XH_UNLOCK ();\n",
        "    return -1;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "llb_psec_add": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1912,
      "endLine": 1955,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "llb_psec_add",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const char *psec"
      ],
      "output": "staticint",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int llb_psec_add (const char *psec)\n",
        "{\n",
        "    int n = 0;\n",
        "    int free = 0;\n",
        "    int ret = -1;\n",
        "    llb_dp_sect_t *s;\n",
        "    XH_LOCK ();\n",
        "    for (; n < LLB_PSECS; n++) {\n",
        "        s = &xh->psecs[n];\n",
        "        if (strncmp (s->name, psec, SECNAMSIZ) == 0) {\n",
        "            if (s->valid) {\n",
        "                s->ref++;\n",
        "                ret = s->ref;\n",
        "                XH_UNLOCK ();\n",
        "                return ret;\n",
        "            }\n",
        "            else {\n",
        "                s->valid = 1;\n",
        "                s->ref = 0;\n",
        "                XH_UNLOCK ();\n",
        "                return 0;\n",
        "            }\n",
        "        }\n",
        "        if (!s->valid && !free)\n",
        "            free = n + 1;\n",
        "    }\n",
        "    if (free <= 0 || free >= LLB_PSECS) {\n",
        "        XH_UNLOCK ();\n",
        "        return -1;\n",
        "    }\n",
        "    s = &xh->psecs[free - 1];\n",
        "    s->valid = 1;\n",
        "    s->ref = 0;\n",
        "    strncpy (s->name, psec, SECNAMSIZ);\n",
        "    s->name[SECNAMSIZ - 1] = '\\0';\n",
        "    printf (\"%s: SEC-%s added idx %d\\n\", __FUNCTION__, psec, free - 1);\n",
        "    XH_UNLOCK ();\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "llb_psec_del": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1957,
      "endLine": 1982,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "llb_psec_del",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const char *psec"
      ],
      "output": "staticint",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int llb_psec_del (const char *psec)\n",
        "{\n",
        "    int n = 0;\n",
        "    llb_dp_sect_t *s;\n",
        "    XH_LOCK ();\n",
        "    for (; n < LLB_PSECS; n++) {\n",
        "        s = &xh->psecs[n];\n",
        "        if (strncmp (s->name, psec, SECNAMSIZ) == 0 && s->valid) {\n",
        "            if (s->ref == 0) {\n",
        "                s->valid = 0;\n",
        "                s->ref = 0;\n",
        "                XH_UNLOCK ();\n",
        "                return 0;\n",
        "            }\n",
        "            else {\n",
        "                s->ref--;\n",
        "                XH_UNLOCK ();\n",
        "                return 0;\n",
        "            }\n",
        "        }\n",
        "    }\n",
        "    XH_UNLOCK ();\n",
        "    return -1;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "llb_psec_setup": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1984,
      "endLine": 2002,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "llb_psec_setup",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const char *psec",
        " struct bpf_object *obj"
      ],
      "output": "staticint",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int llb_psec_setup (const char *psec, struct bpf_object *obj)\n",
        "{\n",
        "    int n = 0;\n",
        "    llb_dp_sect_t *s;\n",
        "    XH_LOCK ();\n",
        "    for (; n < LLB_PSECS; n++) {\n",
        "        s = &xh->psecs[n];\n",
        "        if (strncmp (s->name, psec, SECNAMSIZ) == 0 && s->valid) {\n",
        "            if (s->setup) {\n",
        "                s->setup (obj);\n",
        "                break;\n",
        "            }\n",
        "        }\n",
        "    }\n",
        "    XH_UNLOCK ();\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "llb_sys_exec": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 2004,
      "endLine": 2008,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "llb_sys_exec",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "char *str"
      ],
      "output": "staticvoid",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static void llb_sys_exec (char *str)\n",
        "{\n",
        "    (void) (system (str) + 1);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "llb_ebpf_link_attach": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 2010,
      "endLine": 2036,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "llb_ebpf_link_attach",
      "developer_inline_comments": [
        {
          "start_line": 2015,
          "end_line": 2015,
          "text": " ntc is netlox's modified tc tool "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct config *cfg"
      ],
      "output": "staticvoid",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static void *llb_ebpf_link_attach (struct config *cfg)\n",
        "{\n",
        "    char cmd [PATH_MAX];\n",
        "    if (cfg->tc_bpf) {\n",
        "        sprintf (cmd, \"ntc qdisc add dev %s clsact 2>&1 >/dev/null\", cfg->ifname);\n",
        "        llb_sys_exec (cmd);\n",
        "        printf (\"%s\\n\", cmd);\n",
        "        sprintf (cmd, \"ntc filter add dev %s ingress bpf da obj %s sec %s 2>&1\", cfg->ifname, cfg->filename, cfg->progsec);\n",
        "        llb_sys_exec (cmd);\n",
        "        printf (\"%s\\n\", cmd);\n",
        "\n",
        "#ifdef HAVE_DP_EGR_HOOK\n",
        "        sprintf (cmd, \"ntc filter add dev %s egress bpf da obj %s sec %s 2>&1\", cfg->ifname, cfg->filename, cfg->progsec);\n",
        "        llb_sys_exec (cmd);\n",
        "        printf (\"%s\\n\", cmd);\n",
        "\n",
        "#endif\n",
        "        return 0;\n",
        "    }\n",
        "    else {\n",
        "        return load_bpf_and_xdp_attach (cfg);\n",
        "    }\n",
        "}\n"
      ],
      "called_function_list": [
        "load_bpf_and_xdp_attach",
        "llb_sys_exec"
      ],
      "call_depth": 4,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "llb_ebpf_link_detach": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 2038,
      "endLine": 2058,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "llb_ebpf_link_detach",
      "developer_inline_comments": [
        {
          "start_line": 2044,
          "end_line": 2044,
          "text": " ntc is netlox's modified tc tool "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct config *cfg"
      ],
      "output": "staticint",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int llb_ebpf_link_detach (struct config *cfg)\n",
        "{\n",
        "    char cmd [PATH_MAX];\n",
        "    if (cfg->tc_bpf) {\n",
        "\n",
        "#ifdef HAVE_DP_EGR_HOOK\n",
        "        sprintf (cmd, \"ntc filter del dev %s egress 2>&1\", cfg->ifname);\n",
        "        printf (\"%s\\n\", cmd);\n",
        "        llb_sys_exec (cmd);\n",
        "\n",
        "#endif\n",
        "        sprintf (cmd, \"ntc filter del dev %s ingress 2>&1\", cfg->ifname);\n",
        "        printf (\"%s\\n\", cmd);\n",
        "        llb_sys_exec (cmd);\n",
        "        return 0;\n",
        "    }\n",
        "    else {\n",
        "        return xdp_link_detach (cfg->ifindex, cfg->xdp_flags, 0);\n",
        "    }\n",
        "}\n"
      ],
      "called_function_list": [
        "xdp_link_detach",
        "llb_sys_exec"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "llb_dp_link_attach": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 2060,
      "endLine": 2128,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "llb_dp_link_attach",
      "developer_inline_comments": [
        {
          "start_line": 2073,
          "end_line": 2073,
          "text": " Cmdline options can change progsec "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const char *ifname",
        " const char *psec",
        " int mp_type",
        " int unload"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "int llb_dp_link_attach (const char *ifname, const char *psec, int mp_type, int unload)\n",
        "{\n",
        "    struct bpf_object *bpf_obj;\n",
        "    struct config cfg;\n",
        "    int nr = 0;\n",
        "    assert (psec);\n",
        "    assert (ifname);\n",
        "    memset (&cfg, 0, sizeof (cfg));\n",
        "    strncpy (cfg.progsec, psec, sizeof (cfg.progsec));\n",
        "    if (mp_type == LL_BPF_MOUNT_TC) {\n",
        "        strncpy (cfg.filename, xh->ll_tc_fname, sizeof (cfg.filename));\n",
        "        cfg.tc_bpf = 1;\n",
        "    }\n",
        "    else {\n",
        "        strncpy (cfg.filename, xh->ll_dp_fname, sizeof (cfg.filename));\n",
        "    }\n",
        "    strncpy (cfg.pin_dir, xh->ll_dp_pdir, sizeof (cfg.pin_dir));\n",
        "    if (strcmp (ifname, LLB_MGMT_CHANNEL) == 0)\n",
        "        cfg.xdp_flags |= XDP_FLAGS_SKB_MODE;\n",
        "    cfg.xdp_flags &= ~XDP_FLAGS_UPDATE_IF_NOEXIST;\n",
        "    cfg.ifname = (char *) &cfg.ifname_buf;\n",
        "    strncpy (cfg.ifname, ifname, IF_NAMESIZE);\n",
        "    cfg.ifindex = if_nametoindex (cfg.ifname);\n",
        "    if (cfg.ifindex == 0 && cfg.tc_bpf == 0 && unload == 0) {\n",
        "        assert (0);\n",
        "    }\n",
        "    if (unload) {\n",
        "        llb_ebpf_link_detach (&cfg);\n",
        "        llb_psec_del (psec);\n",
        "        llb_link_prop_del (ifname, mp_type);\n",
        "        return 0;\n",
        "    }\n",
        "    nr = llb_psec_add (psec);\n",
        "    printf (\"NR %d PSEC %s %s\\n\", nr, psec, cfg.filename);\n",
        "    if (nr > 0) {\n",
        "        cfg.reuse_maps = 1;\n",
        "    }\n",
        "    bpf_obj = llb_ebpf_link_attach (& cfg);\n",
        "    if (!bpf_obj && mp_type == LL_BPF_MOUNT_XDP) {\n",
        "        llb_psec_del (psec);\n",
        "        return -1;\n",
        "    }\n",
        "    if (llb_link_prop_add (ifname, bpf_obj, mp_type) != 0) {\n",
        "        xdp_link_detach (cfg.ifindex, cfg.xdp_flags, 0);\n",
        "        llb_psec_del (psec);\n",
        "        llb_link_prop_del (ifname, mp_type);\n",
        "        return -1;\n",
        "    }\n",
        "    if (nr == 0 && mp_type == LL_BPF_MOUNT_XDP) {\n",
        "        printf (\"Setting up for %s|%s\\n\", ifname, psec);\n",
        "        llb_psec_setup (psec, bpf_obj);\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "llb_psec_del",
        "llb_ebpf_link_attach",
        "llb_link_prop_add",
        "llb_psec_add",
        "llb_link_prop_del",
        "llb_ebpf_link_detach",
        "xdp_link_detach",
        "llb_psec_setup"
      ],
      "call_depth": 5,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "loxilb_main": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 2130,
      "endLine": 2147,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/loxilb_libdp.c",
      "funcName": "loxilb_main",
      "developer_inline_comments": [
        {
          "start_line": 2139,
          "end_line": 2139,
          "text": " Save any special config parameters "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct ebpfcfg *cfg"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "int loxilb_main (struct ebpfcfg *cfg)\n",
        "{\n",
        "    libbpf_set_print (libbpf_print_fn);\n",
        "    llb_set_rlims ();\n",
        "    xh = calloc (1, sizeof (* xh));\n",
        "    assert (xh);\n",
        "    if (cfg) {\n",
        "        xh->have_mtrace = cfg->have_mtrace;\n",
        "        xh->nodenum = cfg->nodenum;\n",
        "    }\n",
        "    llb_xh_init (xh);\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "llb_xh_init",
        "llb_set_rlims"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "do_dp_policer": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        },
        {
          "capability": "read_sys_info",
          "read_sys_info": [
            {
              "Project": "bcc",
              "FunctionName": "bpf_ktime_get_ns",
              "Return Type": "u64",
              "Description": "u64 bpf_ktime_get_ns(void) Return: u64 number of nanoseconds. Starts at system boot time but stops during suspend. Examples in situ: \"https://github.com/iovisor/bcc/search?q=bpf_ktime_get_ns+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=bpf_ktime_get_ns+path%3Atools&type=Code search /tools ",
              "Return": "u64 number of nanoseconds",
              "Input Prameters": [],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 13,
      "endLine": 142,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_policer.c",
      "funcName": "do_dp_policer",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 6,
          "text": " *  llb_kern_policer.c: LoxiLB eBPF Policer Processing Implementation *  Copyright (C) 2022,  NetLOX <www.netlox.io> *  *  SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause) "
        },
        {
          "start_line": 10,
          "end_line": 12,
          "text": " The intent here is to make this function non-inline * to keep code size in check "
        },
        {
          "start_line": 35,
          "end_line": 35,
          "text": "|| pla->ca.act_type != DP_SET_DO_POLICER) { "
        },
        {
          "start_line": 43,
          "end_line": 43,
          "text": " Calculate and add tokens to CBS "
        },
        {
          "start_line": 61,
          "end_line": 63,
          "text": " No tokens were added so we revert to last timestamp when tokens     * were collected     "
        },
        {
          "start_line": 67,
          "end_line": 67,
          "text": " Calculate and add tokens to EBS "
        },
        {
          "start_line": 85,
          "end_line": 87,
          "text": " No tokens were added so we revert to last timestamp when tokens     * were collected     "
        },
        {
          "start_line": 92,
          "end_line": 92,
          "text": " Color-blind mode "
        },
        {
          "start_line": 104,
          "end_line": 104,
          "text": " Color-aware mode "
        }
      ],
      "updateMaps": [],
      "readMaps": [
        "  polx_map"
      ],
      "input": [
        "void *ctx",
        " struct xfi *xf",
        " int egr"
      ],
      "output": "staticint",
      "helper": [
        "bpf_spin_lock",
        "bpf_map_lookup_elem",
        "bpf_ktime_get_ns",
        "bpf_spin_unlock"
      ],
      "compatibleHookpoints": [
        "socket_filter",
        "xdp",
        "sock_ops",
        "sched_act",
        "sk_reuseport",
        "lwt_seg6local",
        "sk_msg",
        "lwt_in",
        "sk_skb",
        "lwt_xmit",
        "cgroup_sock",
        "lwt_out",
        "sched_cls",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int do_dp_policer (void *ctx, struct xfi *xf, int egr)\n",
        "{\n",
        "    struct dp_pol_tact *pla;\n",
        "    int ret = 0;\n",
        "    __u64 ts_now;\n",
        "    __u64 ts_last;\n",
        "    __u32 ntoks;\n",
        "    __u32 polid;\n",
        "    __u32 inbytes;\n",
        "    __u64 acc_toks;\n",
        "    __u64 usecs_elapsed;\n",
        "    ts_now = bpf_ktime_get_ns ();\n",
        "    if (egr) {\n",
        "        polid = xf->qm.opolid;\n",
        "    }\n",
        "    else {\n",
        "        polid = xf->qm.ipolid;\n",
        "    }\n",
        "    pla = bpf_map_lookup_elem (& polx_map, & polid);\n",
        "    if (!pla) {\n",
        "        return 0;\n",
        "    }\n",
        "    inbytes = xf->pm.l3_len;\n",
        "    bpf_spin_lock (&pla->lock);\n",
        "    ts_last = pla->pol.lastc_uts;\n",
        "    pla->pol.lastc_uts = ts_now;\n",
        "    usecs_elapsed = (ts_now - ts_last) / NSECS_IN_USEC;\n",
        "    acc_toks = pla->pol.toksc_pus * usecs_elapsed;\n",
        "    if (acc_toks > 0) {\n",
        "        if (pla->pol.cbs > pla->pol.tok_c) {\n",
        "            ntoks = pla->pol.cbs - pla->pol.tok_c;\n",
        "            if (acc_toks > ntoks) {\n",
        "                acc_toks -= ntoks;\n",
        "                pla->pol.tok_c += ntoks;\n",
        "            }\n",
        "            else {\n",
        "                pla->pol.tok_c += acc_toks;\n",
        "                acc_toks = 0;\n",
        "            }\n",
        "        }\n",
        "    }\n",
        "    else {\n",
        "        pla->pol.lastc_uts = ts_last;\n",
        "    }\n",
        "    ts_last = pla->pol.laste_uts;\n",
        "    pla->pol.laste_uts = ts_now;\n",
        "    usecs_elapsed = (ts_now - ts_last) / NSECS_IN_USEC;\n",
        "    acc_toks = pla->pol.tokse_pus * usecs_elapsed;\n",
        "    if (acc_toks) {\n",
        "        if (pla->pol.ebs > pla->pol.tok_e) {\n",
        "            ntoks = pla->pol.ebs - pla->pol.tok_e;\n",
        "            if (acc_toks > ntoks) {\n",
        "                acc_toks -= ntoks;\n",
        "                pla->pol.tok_e += ntoks;\n",
        "            }\n",
        "            else {\n",
        "                pla->pol.tok_e += acc_toks;\n",
        "                acc_toks = 0;\n",
        "            }\n",
        "        }\n",
        "    }\n",
        "    else {\n",
        "        pla->pol.laste_uts = ts_last;\n",
        "    }\n",
        "    if (pla->pol.color_aware == 0) {\n",
        "        if (pla->pol.tok_e < inbytes) {\n",
        "            xf->qm.ocol = LLB_PIPE_COL_RED;\n",
        "        }\n",
        "        else if (pla->pol.tok_c < inbytes) {\n",
        "            xf->qm.ocol = LLB_PIPE_COL_YELLOW;\n",
        "            pla->pol.tok_e -= inbytes;\n",
        "        }\n",
        "        else {\n",
        "            pla->pol.tok_c -= inbytes;\n",
        "            pla->pol.tok_e -= inbytes;\n",
        "            xf->qm.ocol = LLB_PIPE_COL_GREEN;\n",
        "        }\n",
        "    }\n",
        "    else {\n",
        "        if (xf->qm.icol == LLB_PIPE_COL_NONE) {\n",
        "            ret = -1;\n",
        "            goto out;\n",
        "        }\n",
        "        if (xf->qm.icol == LLB_PIPE_COL_RED) {\n",
        "            xf->qm.ocol = LLB_PIPE_COL_RED;\n",
        "            goto out;\n",
        "        }\n",
        "        if (pla->pol.tok_e < inbytes) {\n",
        "            xf->qm.ocol = LLB_PIPE_COL_RED;\n",
        "        }\n",
        "        else if (pla->pol.tok_c < inbytes) {\n",
        "            if (xf->qm.icol == LLB_PIPE_COL_GREEN) {\n",
        "                xf->qm.ocol = LLB_PIPE_COL_YELLOW;\n",
        "            }\n",
        "            else {\n",
        "                xf->qm.ocol = xf->qm.icol;\n",
        "            }\n",
        "            pla->pol.tok_e -= inbytes;\n",
        "        }\n",
        "        else {\n",
        "            pla->pol.tok_c -= inbytes;\n",
        "            pla->pol.tok_e -= inbytes;\n",
        "            xf->qm.ocol = xf->qm.icol;\n",
        "        }\n",
        "    }\n",
        "out :\n",
        "    if (pla->pol.drop_prio < xf->qm.ocol) {\n",
        "        ret = 1;\n",
        "        pla->pol.ps.drop_packets += 1;\n",
        "        LLBS_PPLN_DROP (xf);\n",
        "    }\n",
        "    else {\n",
        "        pla->pol.ps.pass_packets += 1;\n",
        "    }\n",
        "    bpf_spin_unlock (&pla->lock);\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "get_crc32c_map": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 10,
      "endLine": 22,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_sum.c",
      "funcName": "get_crc32c_map",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 6,
          "text": " *  llb_kern_sum.c: LoxiLB Kernel in-eBPF checksums  *  Copyright (C) 2022,  NetLOX <www.netlox.io> *  * SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause) "
        },
        {
          "start_line": 17,
          "end_line": 17,
          "text": " Not Reached "
        }
      ],
      "updateMaps": [],
      "readMaps": [
        "  crc32c_map"
      ],
      "input": [
        "__u32 off"
      ],
      "output": "static__u32__always_inline",
      "helper": [
        "bpf_map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static __u32 __always_inline get_crc32c_map (__u32 off)\n",
        "{\n",
        "    __u32 *val;\n",
        "    val = bpf_map_lookup_elem (& crc32c_map, & off);\n",
        "    if (!val) {\n",
        "        return 0;\n",
        "    }\n",
        "    return *val;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_sctp_csum": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 24,
      "endLine": 95,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_sum.c",
      "funcName": "dp_sctp_csum",
      "developer_inline_comments": [
        {
          "start_line": 36,
          "end_line": 36,
          "text": " Next tail-call"
        },
        {
          "start_line": 58,
          "end_line": 58,
          "text": " Update crc in sctp "
        },
        {
          "start_line": 59,
          "end_line": 59,
          "text": " Reset any flag which indicates further sctp processing "
        },
        {
          "start_line": 70,
          "end_line": 70,
          "text": "csum = bpf_htonl(crc ^ 0xffffffff);"
        },
        {
          "start_line": 79,
          "end_line": 79,
          "text": " Update state-variables "
        },
        {
          "start_line": 85,
          "end_line": 85,
          "text": " Jump to next helper section for checksum "
        },
        {
          "start_line": 93,
          "end_line": 93,
          "text": " Something went wrong here "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_sctp_csum (void *ctx, struct xfi *xf)\n",
        "{\n",
        "    int ret;\n",
        "    int off;\n",
        "    int rlen;\n",
        "    __u8 tcall;\n",
        "    __u32 tbval;\n",
        "    __u8 pb;\n",
        "    int loop = 0;\n",
        "    __u32 crc = 0xffffffff;\n",
        "    tcall = ~xf->km.skey[0];\n",
        "    off = *(__u16*) &xf->km.skey[2];\n",
        "    rlen = *(__u16*) &xf->km.skey[4];\n",
        "    if (off) {\n",
        "        crc = *(__u32*) &xf->km.skey[8];\n",
        "    }\n",
        "    for (loop = 0; loop < DP_MAX_LOOPS_PER_TCALL; loop++) {\n",
        "        __u8 idx;\n",
        "        if (rlen > 0) {\n",
        "            ret = dp_pktbuf_read (ctx, off, & pb, sizeof (pb));\n",
        "            if (ret < 0) {\n",
        "                goto drop;\n",
        "            }\n",
        "            idx = (crc ^ pb) & 0xff;\n",
        "            tbval = get_crc32c_map (idx);\n",
        "            crc = tbval ^ (crc >> 8);\n",
        "            off++;\n",
        "            rlen--;\n",
        "        }\n",
        "        else\n",
        "            break;\n",
        "    }\n",
        "    if (rlen <= 0) {\n",
        "        if (xf->l34m.nw_proto == IPPROTO_SCTP) {\n",
        "            void *dend = DP_TC_PTR (DP_PDATA_END (ctx));\n",
        "            struct sctphdr *sctp = DP_ADD_PTR (DP_PDATA (ctx), xf->pm.l4_off);\n",
        "            int sctp_csum_off = xf->pm.l4_off + offsetof (struct sctphdr, checksum);\n",
        "            __be32 csum;\n",
        "            if (sctp + 1 > dend) {\n",
        "                LLBS_PPLN_DROP (xf);\n",
        "                return DP_DROP;\n",
        "            }\n",
        "            csum = (crc ^ 0xffffffff);\n",
        "            dp_pktbuf_write (ctx, sctp_csum_off, &csum, sizeof (csum), 0);\n",
        "            xf->pm.nf = 0;\n",
        "        }\n",
        "        RETURN_TO_MP_OUT ();\n",
        "    }\n",
        "    xf->km.skey[0] = tcall;\n",
        "    *(__u16*) &xf->km.skey[2] = off;\n",
        "    *(__u16*) &xf->km.skey[4] = rlen;\n",
        "    *(__u32*) &xf->km.skey[8] = crc;\n",
        "    if (tcall) {\n",
        "        TCALL_CRC2 ();\n",
        "    }\n",
        "    else {\n",
        "        TCALL_CRC1 ();\n",
        "    }\n",
        "drop :\n",
        "    return DP_DROP;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_pktbuf_read",
        "dp_pktbuf_write",
        "get_crc32c_map"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "ERR_PTR": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 13,
      "endLine": 16,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/headers/linux/err.h",
      "funcName": "ERR_PTR",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": " SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause) "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "long error_"
      ],
      "output": "staticinlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static inline void *ERR_PTR (long error_)\n",
        "{\n",
        "    return (void *) error_;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ],
  "PTR_ERR": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 18,
      "endLine": 21,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/headers/linux/err.h",
      "funcName": "PTR_ERR",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const void *ptr"
      ],
      "output": "staticinlinelong",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static inline long PTR_ERR (const void *ptr)\n",
        "{\n",
        "    return (long) ptr;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "IS_ERR": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 23,
      "endLine": 26,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/headers/linux/err.h",
      "funcName": "IS_ERR",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const void *ptr"
      ],
      "output": "staticinlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static inline bool IS_ERR (const void *ptr)\n",
        "{\n",
        "    return IS_ERR_VALUE ((unsigned long) ptr);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ],
  "ip_is_fragment": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 143,
      "endLine": 146,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/common/parsing_helpers.h",
      "funcName": "ip_is_fragment",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": " SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-2-clause) "
        },
        {
          "start_line": 25,
          "end_line": 25,
          "text": " Parser to help ebpf packet parsing "
        },
        {
          "start_line": 36,
          "end_line": 36,
          "text": " Parser to help gtp ebpf packer parsing "
        },
        {
          "start_line": 52,
          "end_line": 52,
          "text": " Allow users of header file to redefine VLAN max depth "
        },
        {
          "start_line": 57,
          "end_line": 61,
          "text": " *\tstruct vlanhdr - vlan header *\t@h_vlan_TCI: priority and VLAN ID *\t@h_vlan_encapsulated_proto: packet type ID or len "
        },
        {
          "start_line": 69,
          "end_line": 79,
          "text": " *\tstruct arp_ethhdr - arp header *\t@ar_hrd: Hardware type *\t@ar_pro: Protocol type *\t@ar_hln: Protocol address len *\t@ar_op:  ARP opcode *\t@ar_sha: Sender hardware/mac address *\t@ar_spa: Sender protocol address *\t@ar_tha: Target hardware/mac address *\t@ar_tpa: Target protocol address "
        },
        {
          "start_line": 92,
          "end_line": 92,
          "text": " LLB L2 header type "
        },
        {
          "start_line": 95,
          "end_line": 102,
          "text": " *  struct llb_ethhdr - header for internal communication *  @iport: input port *  @oport: output port *  @mmap:  missed map *  @rcode: return code *  @ntype: next header type "
        },
        {
          "start_line": 115,
          "end_line": 119,
          "text": " *  struct vxlanhdr - vxlan header *  @vx_flags: flags *  @vx_vni:   vxlan vni info "
        },
        {
          "start_line": 125,
          "end_line": 130,
          "text": " * struct icmp_cmnhdr - represents the common part of the icmphdr and icmp6hdr * @type:  icmp packet type * @code:  icmp code * @cksum: icmp checksum "
        },
        {
          "start_line": 137,
          "end_line": 137,
          "text": " IP flags "
        },
        {
          "start_line": 138,
          "end_line": 138,
          "text": " Flag: \"Congestion\"\t\t"
        },
        {
          "start_line": 139,
          "end_line": 139,
          "text": " Flag: \"Don't Fragment\"\t"
        },
        {
          "start_line": 140,
          "end_line": 140,
          "text": " Flag: \"More Fragments\"\t"
        },
        {
          "start_line": 141,
          "end_line": 141,
          "text": " \"Fragment Offset\" part\t"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct iphdr *iph"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static __always_inline int ip_is_fragment (const struct iphdr *iph)\n",
        "{\n",
        "    return (iph->frag_off & bpf_htons (IP_MF | IP_OFFSET)) != 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "ip_is_first_fragment": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 148,
      "endLine": 151,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/common/parsing_helpers.h",
      "funcName": "ip_is_first_fragment",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct iphdr *iph"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static __always_inline int ip_is_first_fragment (const struct iphdr *iph)\n",
        "{\n",
        "    return (iph->frag_off & bpf_htons (IP_OFFSET)) == 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ],
  "proto_is_vlan": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 153,
      "endLine": 157,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/common/parsing_helpers.h",
      "funcName": "proto_is_vlan",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "__be16 h_proto"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static __always_inline int proto_is_vlan (__be16 h_proto)\n",
        "{\n",
        "    return !!(h_proto == bpf_htons (ETH_P_8021Q) || h_proto == bpf_htons (ETH_P_8021AD));\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "ip_decrease_ttl": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 160,
      "endLine": 166,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/common/parsing_helpers.h",
      "funcName": "ip_decrease_ttl",
      "developer_inline_comments": [
        {
          "start_line": 159,
          "end_line": 159,
          "text": " from include/net/ip.h "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct iphdr *iph"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static __always_inline int ip_decrease_ttl (struct iphdr *iph)\n",
        "{\n",
        "    __be32 check = iph->check;\n",
        "    check += bpf_htons (0x0100);\n",
        "    iph->check = (__be16) (check + (check >= 0xFFFF));\n",
        "    return --iph->ttl;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "ipv6_addr_is_multicast": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 168,
      "endLine": 171,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/common/parsing_helpers.h",
      "funcName": "ipv6_addr_is_multicast",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct in6_addr *addr"
      ],
      "output": "staticinlineint",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static inline int ipv6_addr_is_multicast (const struct in6_addr *addr)\n",
        "{\n",
        "    return (addr->s6_addr32[0] & bpf_htonl (0xFF000000)) == bpf_htonl (0xFF000000);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "csum_fold_helper": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 173,
      "endLine": 177,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/common/parsing_helpers.h",
      "funcName": "csum_fold_helper",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "__be32 csum"
      ],
      "output": "static__always_inline__be16",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static __always_inline __be16 csum_fold_helper (__be32 csum)\n",
        "{\n",
        "    return ~((csum & 0xffff) + (csum >> 16));\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "ipv4_csum": [
    {
      "capabilities": [
        {
          "capability": "read_skb",
          "read_skb": [
            {
              "Project": "libbpf",
              "Return Type": "s64",
              "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with bpf_l3_csum_replace() and bpf_l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with bpf_csum_diff(). ",
              "Return": " The checksum result, or a negative error code in case of failure.",
              "Function Name": "bpf_csum_diff",
              "Input Params": [
                "{Type: __be32 ,Var: *from}",
                "{Type:  u32 ,Var: from_size}",
                "{Type:  __be32 ,Var: *to}",
                "{Type:  u32 ,Var: to_size}",
                "{Type:  __wsum ,Var: seed}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "xdp",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "lwt_seg6local"
              ],
              "capabilities": [
                "read_skb"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 179,
      "endLine": 186,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/common/parsing_helpers.h",
      "funcName": "ipv4_csum",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *data_start",
        " int data_size",
        " __be32 *csum"
      ],
      "output": "static__always_inlinevoid",
      "helper": [
        "bpf_csum_diff"
      ],
      "compatibleHookpoints": [
        "xdp",
        "sched_act",
        "lwt_seg6local",
        "lwt_in",
        "lwt_xmit",
        "lwt_out",
        "sched_cls"
      ],
      "source": [
        "static __always_inline void ipv4_csum (void *data_start, int data_size, __be32 *csum)\n",
        "{\n",
        "    *csum = bpf_csum_diff (0, 0, data_start, data_size, *csum);\n",
        "    *csum = csum_fold_helper (*csum);\n",
        "}\n"
      ],
      "called_function_list": [
        "csum_fold_helper"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ],
  "ipv4_l4_csum": [
    {
      "capabilities": [
        {
          "capability": "read_skb",
          "read_skb": [
            {
              "Project": "libbpf",
              "Return Type": "s64",
              "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with bpf_l3_csum_replace() and bpf_l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with bpf_csum_diff(). ",
              "Return": " The checksum result, or a negative error code in case of failure.",
              "Function Name": "bpf_csum_diff",
              "Input Params": [
                "{Type: __be32 ,Var: *from}",
                "{Type:  u32 ,Var: from_size}",
                "{Type:  __be32 ,Var: *to}",
                "{Type:  u32 ,Var: to_size}",
                "{Type:  __wsum ,Var: seed}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "xdp",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "lwt_seg6local"
              ],
              "capabilities": [
                "read_skb"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 188,
      "endLine": 201,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/common/parsing_helpers.h",
      "funcName": "ipv4_l4_csum",
      "developer_inline_comments": [
        {
          "start_line": 194,
          "end_line": 194,
          "text": " __builtin_bswap32 equals to htonl()"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *data_start",
        " __be32 data_size",
        " __u64 *csum",
        " struct iphdr *iph"
      ],
      "output": "static__always_inlinevoid",
      "helper": [
        "bpf_csum_diff"
      ],
      "compatibleHookpoints": [
        "xdp",
        "sched_act",
        "lwt_seg6local",
        "lwt_in",
        "lwt_xmit",
        "lwt_out",
        "sched_cls"
      ],
      "source": [
        "static __always_inline void ipv4_l4_csum (void *data_start, __be32 data_size, __u64 *csum, struct iphdr *iph)\n",
        "{\n",
        "    __be32 tmp = 0;\n",
        "    *csum = bpf_csum_diff (0, 0, &iph->saddr, sizeof (__be32), *csum);\n",
        "    *csum = bpf_csum_diff (0, 0, &iph->daddr, sizeof (__be32), *csum);\n",
        "    tmp = __builtin_bswap32 ((__be32) (iph -> protocol));\n",
        "    *csum = bpf_csum_diff (0, 0, &tmp, sizeof (__be32), *csum);\n",
        "    tmp = __builtin_bswap32 ((__be32) (data_size));\n",
        "    *csum = bpf_csum_diff (0, 0, &tmp, sizeof (__be32), *csum);\n",
        "    *csum = bpf_csum_diff (0, 0, data_start, data_size, *csum);\n",
        "    *csum = csum_fold_helper (*csum);\n",
        "}\n"
      ],
      "called_function_list": [
        "csum_fold_helper"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 1
    }
  ],
  "dp_do_map_stats": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        },
        {
          "capability": "map_update",
          "map_update": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_map_update_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}",
                "{Type:  const void ,Var: *value}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_update"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 568,
      "endLine": 631,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_do_map_stats",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 6,
          "text": " *  llb_dp_cdefs.h: Loxilb eBPF/XDP utility functions  *  Copyright (C) 2022,  NetLOX <www.netlox.io> *  * SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause) "
        },
        {
          "start_line": 71,
          "end_line": 71,
          "text": " Index xdp_ifidx "
        },
        {
          "start_line": 78,
          "end_line": 78,
          "text": " Index bd_id "
        },
        {
          "start_line": 92,
          "end_line": 92,
          "text": " Index xdp_ifidx "
        },
        {
          "start_line": 106,
          "end_line": 106,
          "text": " Index CPU idx "
        },
        {
          "start_line": 120,
          "end_line": 120,
          "text": " Index xdp_ifidx "
        },
        {
          "start_line": 127,
          "end_line": 127,
          "text": " Index bd_id "
        },
        {
          "start_line": 155,
          "end_line": 155,
          "text": " tmac index "
        },
        {
          "start_line": 176,
          "end_line": 176,
          "text": " Counter Index "
        },
        {
          "start_line": 190,
          "end_line": 190,
          "text": " Counter Index "
        },
        {
          "start_line": 205,
          "end_line": 205,
          "text": " Counter Index "
        },
        {
          "start_line": 220,
          "end_line": 220,
          "text": " Counter Index "
        },
        {
          "start_line": 242,
          "end_line": 242,
          "text": " Counter Index "
        },
        {
          "start_line": 257,
          "end_line": 257,
          "text": " Counter Index "
        },
        {
          "start_line": 271,
          "end_line": 271,
          "text": " Counter Index "
        },
        {
          "start_line": 292,
          "end_line": 292,
          "text": " Index CPU idx "
        },
        {
          "start_line": 297,
          "end_line": 297,
          "text": " New BTF definitions "
        },
        {
          "start_line": 320,
          "end_line": 327,
          "text": "struct {        __uint(type,        BPF_MAP_TYPE_PERF_EVENT_ARRAY);        __type(key,         int);        __type(value,       __u32);        __uint(max_entries, MAX_CPUS);} pkt_ring SEC(\".maps\");"
        },
        {
          "start_line": 357,
          "end_line": 364,
          "text": "struct {        __uint(type,        BPF_MAP_TYPE_DEVMAP);        __type(key,         int);        __type(value,       int);        __uint(max_entries, LLB_INTERFACES);} tx_intf_map SEC(\".maps\");"
        },
        {
          "start_line": 450,
          "end_line": 457,
          "text": "struct {        __uint(type,        BPF_MAP_TYPE_LPM_TRIE);        __type(key,         struct dp_rtv4_key);        __type(value,       struct dp_rt_tact);        __uint(max_entries, LLB_RTV4_MAP_ENTRIES);} rt_v4_map SEC(\".maps\");"
        }
      ],
      "updateMaps": [
        " map"
      ],
      "readMaps": [
        " map"
      ],
      "input": [
        "struct xdp_md *ctx",
        " struct xfi *xf",
        " int xtbl",
        " int cidx"
      ],
      "output": "staticvoid__always_inline",
      "helper": [
        "bpf_map_lookup_elem",
        "bpf_map_update_elem"
      ],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "cgroup_device",
        "lwt_xmit",
        "cgroup_sock",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "cgroup_sysctl",
        "sk_msg",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "perf_event",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static void __always_inline dp_do_map_stats (struct xdp_md *ctx, struct xfi *xf, int xtbl, int cidx)\n",
        "{\n",
        "    struct dp_pb_stats *pb;\n",
        "    struct dp_pb_stats pb_new;\n",
        "    void *map = NULL;\n",
        "    int key = cidx;\n",
        "    switch (xtbl) {\n",
        "    case LL_DP_RTV4_STATS_MAP :\n",
        "        map = &rt_v4_stats_map;\n",
        "        break;\n",
        "    case LL_DP_RTV6_STATS_MAP :\n",
        "        map = &rt_v6_stats_map;\n",
        "        break;\n",
        "    case LL_DP_CT_STATS_MAP :\n",
        "        map = &ct_stats_map;\n",
        "        break;\n",
        "    case LL_DP_INTF_STATS_MAP :\n",
        "        map = &intf_stats_map;\n",
        "        break;\n",
        "    case LL_DP_TX_INTF_STATS_MAP :\n",
        "        map = &tx_intf_stats_map;\n",
        "        break;\n",
        "    case LL_DP_BD_STATS_MAP :\n",
        "        map = &bd_stats_map;\n",
        "        break;\n",
        "    case LL_DP_TX_BD_STATS_MAP :\n",
        "        map = &tx_bd_stats_map;\n",
        "        break;\n",
        "    case LL_DP_TMAC_STATS_MAP :\n",
        "        map = &tmac_stats_map;\n",
        "        break;\n",
        "    case LL_DP_SESS4_STATS_MAP :\n",
        "        map = &sess_v4_stats_map;\n",
        "        break;\n",
        "    case LL_DP_NAT_STATS_MAP :\n",
        "        map = &nat_stats_map;\n",
        "        break;\n",
        "    case LL_DP_FW4_STATS_MAP :\n",
        "        map = &fw_v4_stats_map;\n",
        "        break;\n",
        "    default :\n",
        "        return;\n",
        "    }\n",
        "    pb = bpf_map_lookup_elem (map, & key);\n",
        "    if (pb) {\n",
        "        pb->bytes += xf->pm.py_bytes;\n",
        "        pb->packets += 1;\n",
        "        LL_DBG_PRINTK (\"[STAT] %d %llu %llu\\n\", key, pb->bytes, pb->packets);\n",
        "        return;\n",
        "    }\n",
        "    pb_new.bytes = xf->pm.py_bytes;\n",
        "    ;\n",
        "    pb_new.packets = 1;\n",
        "    bpf_map_update_elem (map, &key, &pb_new, BPF_ANY);\n",
        "    return;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_ipv4_new_csum": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 633,
      "endLine": 647,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_ipv4_new_csum",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct iphdr *iph"
      ],
      "output": "staticvoid__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static void __always_inline dp_ipv4_new_csum (struct iphdr *iph)\n",
        "{\n",
        "    __u16 *iph16 = (__u16 *) iph;\n",
        "    __u32 csum;\n",
        "    int i;\n",
        "    iph->check = 0;\n",
        "\n",
        "#pragma clang loop unroll(full)\n",
        "    for (i = 0, csum = 0; i < sizeof (*iph) >> 1; i++)\n",
        "        csum += *iph16++;\n",
        "    iph->check = ~((csum & 0xffff) + (csum >> 16));\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_csum_tcall": [
    {
      "capabilities": [
        {
          "capability": "map_update",
          "map_update": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_map_update_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}",
                "{Type:  const void ,Var: *value}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_update"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 695,
      "endLine": 711,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_csum_tcall",
      "developer_inline_comments": [
        {
          "start_line": 701,
          "end_line": 701,
          "text": " Init state-variables "
        }
      ],
      "updateMaps": [
        " xfis"
      ],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_map_update_elem"
      ],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_csum_tcall (void *ctx, struct xfi *xf)\n",
        "{\n",
        "    int z = 0;\n",
        "    __u32 crc = 0xffffffff;\n",
        "    xf->km.skey[0] = 0;\n",
        "    *(__u16*) &xf->km.skey[2] = xf->pm.l4_off;\n",
        "    *(__u16*) &xf->km.skey[4] = xf->pm.l3_plen;\n",
        "    *(__u32*) &xf->km.skey[8] = crc;\n",
        "    bpf_map_update_elem (&xfis, &z, xf, BPF_ANY);\n",
        "    TCALL_CRC1 ();\n",
        "    return DP_PASS;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_sunp_tcall": [
    {
      "capabilities": [
        {
          "capability": "map_update",
          "map_update": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_map_update_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}",
                "{Type:  const void ,Var: *value}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_update"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 713,
      "endLine": 722,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_sunp_tcall",
      "developer_inline_comments": [],
      "updateMaps": [
        " xfis"
      ],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_map_update_elem",
        "bpf_tail_call"
      ],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "lwt_xmit",
        "cgroup_sock",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "perf_event",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_sunp_tcall (void *ctx, struct xfi *xf)\n",
        "{\n",
        "    int z = 0;\n",
        "    bpf_map_update_elem (&xfis, &z, xf, BPF_ANY);\n",
        "    bpf_tail_call (ctx, &pgm_tbl, LLB_DP_SUNP_PGM_ID2);\n",
        "    return DP_PASS;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_pkt_is_l2mcbc": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 724,
      "endLine": 734,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_pkt_is_l2mcbc",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct xfi *xf",
        " void *md"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_pkt_is_l2mcbc (struct xfi *xf, void *md)\n",
        "{\n",
        "    struct  __sk_buff *b = md;\n",
        "    if (b->pkt_type == PACKET_MULTICAST || b->pkt_type == PACKET_BROADCAST) {\n",
        "        return 1;\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1713,
      "endLine": 1730,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_pkt_is_l2mcbc",
      "developer_inline_comments": [
        {
          "start_line": 1698,
          "end_line": 1698,
          "text": " XDP utilities "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct xfi *xf",
        " void *md"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_pkt_is_l2mcbc (struct xfi *xf, void *md)\n",
        "{\n",
        "    if (xf->l2m.dl_dst[0] & 1) {\n",
        "        return 1;\n",
        "    }\n",
        "    if (xf->l2m.dl_dst[0] == 0xff && xf->l2m.dl_dst[1] == 0xff && xf->l2m.dl_dst[2] == 0xff && xf->l2m.dl_dst[3] == 0xff && xf->l2m.dl_dst[4] == 0xff && xf->l2m.dl_dst[5] == 0xff) {\n",
        "        return 1;\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_vlan_info": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 736,
      "endLine": 748,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_vlan_info",
      "developer_inline_comments": [
        {
          "start_line": 742,
          "end_line": 742,
          "text": "xf->l2m.dl_type = bpf_htons((__u16)(b->vlan_proto));"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct xfi *xf",
        " void *md"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_vlan_info (struct xfi *xf, void *md)\n",
        "{\n",
        "    struct  __sk_buff *b = md;\n",
        "    if (b->vlan_present) {\n",
        "        xf->l2m.vlan[0] = bpf_htons ((__u16) (b->vlan_tci));\n",
        "        return 1;\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_add_l2": [
    {
      "capabilities": [
        {
          "capability": "update_pkt",
          "update_pkt": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Grows headroom of packet associated to <[ skb ]>(IP: 0) and adjusts the offset of the MAC header accordingly , adding <[ len ]>(IP: 1) bytes of space. It automatically extends and reallocates memory as required. This helper can be used on a layer 3 <[ skb ]>(IP: 0) to push a MAC header for redirection into a layer 2 device. All values for <[ flags ]>(IP: 2) are reserved for future usage , and must be left at zero. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_skb_change_head",
              "Input Params": [
                "{Type: struct sk_buff ,Var: *skb}",
                "{Type:  u32 ,Var: len}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "lwt_xmit",
                "sk_skb"
              ],
              "capabilities": [
                "update_pkt"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 750,
      "endLine": 754,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_add_l2",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *md",
        " int delta"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_skb_change_head"
      ],
      "compatibleHookpoints": [
        "lwt_xmit",
        "sched_cls",
        "sk_skb",
        "sched_act"
      ],
      "source": [
        "static int __always_inline dp_add_l2 (void *md, int delta)\n",
        "{\n",
        "    return bpf_skb_change_head (md, delta, 0);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    },
    {
      "capabilities": [
        {
          "capability": "update_pkt",
          "update_pkt": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Adjust (move) xdp_md->data by <[ delta ]>(IP: 1) bytes. Note that it is possible to use a negative value for delta. This helper can be used to prepare the packet for pushing or popping headers. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_xdp_adjust_head",
              "Input Params": [
                "{Type: struct xdp_buff ,Var: *xdp_md}",
                "{Type:  int ,Var: delta}"
              ],
              "compatible_hookpoints": [
                "xdp"
              ],
              "capabilities": [
                "update_pkt"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1732,
      "endLine": 1736,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_add_l2",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *md",
        " int delta"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_xdp_adjust_head"
      ],
      "compatibleHookpoints": [
        "xdp"
      ],
      "source": [
        "static int __always_inline dp_add_l2 (void *md, int delta)\n",
        "{\n",
        "    return bpf_xdp_adjust_head (md, -delta);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_remove_l2": [
    {
      "capabilities": [
        {
          "capability": "update_pkt",
          "update_pkt": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Grow or shrink the room for data in the packet associated to <[ skb ]>(IP: 0) by <[ len_diff ]>(IP: 1) , and according to the selected mode. There are two supported modes at this time: \u00b7 BPF_ADJ_ROOM_MAC: Adjust room at the mac layer (room space is added or removed below the layer 2 header). \u00b7 BPF_ADJ_ROOM_NET: Adjust room at the network layer (room space is added or removed below the layer 3 header). The following <[ flags ]>(IP: 3) are supported at this time: \u00b7 BPF_F_ADJ_ROOM_FIXED_GSO: Do not adjust gso_size. Adjusting mss in this way is not allowed for datagrams. \u00b7 BPF_F_ADJ_ROOM_ENCAP_L3_IPV4 , BPF_F_ADJ_ROOM_ENCAP_L3_IPV6: Any new space is reserved to hold a tunnel header. Configure <[ skb ]>(IP: 0) offsets and other fields accordingly. \u00b7 BPF_F_ADJ_ROOM_ENCAP_L4_GRE , BPF_F_ADJ_ROOM_ENCAP_L4_UDP: Use with ENCAP_L3 <[ flags ]>(IP: 3) to further specify the tunnel type. \u00b7 BPF_F_ADJ_ROOM_ENCAP_L2(len): Use with ENCAP_L3/L4 <[ flags ]>(IP: 3) to further specify the tunnel type; len is the length of the inner MAC header. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_skb_adjust_room",
              "Input Params": [
                "{Type: struct sk_buff ,Var: *skb}",
                "{Type:  s32 ,Var: len_diff}",
                "{Type:  u32 ,Var: mode}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "update_pkt"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 756,
      "endLine": 761,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_remove_l2",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *md",
        " int delta"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_skb_adjust_room"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act"
      ],
      "source": [
        "static int __always_inline dp_remove_l2 (void *md, int delta)\n",
        "{\n",
        "    return bpf_skb_adjust_room (md, -delta, BPF_ADJ_ROOM_MAC, BPF_F_ADJ_ROOM_FIXED_GSO);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    },
    {
      "capabilities": [
        {
          "capability": "update_pkt",
          "update_pkt": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Adjust (move) xdp_md->data by <[ delta ]>(IP: 1) bytes. Note that it is possible to use a negative value for delta. This helper can be used to prepare the packet for pushing or popping headers. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_xdp_adjust_head",
              "Input Params": [
                "{Type: struct xdp_buff ,Var: *xdp_md}",
                "{Type:  int ,Var: delta}"
              ],
              "compatible_hookpoints": [
                "xdp"
              ],
              "capabilities": [
                "update_pkt"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1738,
      "endLine": 1742,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_remove_l2",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *md",
        " int delta"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_xdp_adjust_head"
      ],
      "compatibleHookpoints": [
        "xdp"
      ],
      "source": [
        "static int __always_inline dp_remove_l2 (void *md, int delta)\n",
        "{\n",
        "    return bpf_xdp_adjust_head (md, delta);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_buf_add_room": [
    {
      "capabilities": [
        {
          "capability": "update_pkt",
          "update_pkt": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Grow or shrink the room for data in the packet associated to <[ skb ]>(IP: 0) by <[ len_diff ]>(IP: 1) , and according to the selected mode. There are two supported modes at this time: \u00b7 BPF_ADJ_ROOM_MAC: Adjust room at the mac layer (room space is added or removed below the layer 2 header). \u00b7 BPF_ADJ_ROOM_NET: Adjust room at the network layer (room space is added or removed below the layer 3 header). The following <[ flags ]>(IP: 3) are supported at this time: \u00b7 BPF_F_ADJ_ROOM_FIXED_GSO: Do not adjust gso_size. Adjusting mss in this way is not allowed for datagrams. \u00b7 BPF_F_ADJ_ROOM_ENCAP_L3_IPV4 , BPF_F_ADJ_ROOM_ENCAP_L3_IPV6: Any new space is reserved to hold a tunnel header. Configure <[ skb ]>(IP: 0) offsets and other fields accordingly. \u00b7 BPF_F_ADJ_ROOM_ENCAP_L4_GRE , BPF_F_ADJ_ROOM_ENCAP_L4_UDP: Use with ENCAP_L3 <[ flags ]>(IP: 3) to further specify the tunnel type. \u00b7 BPF_F_ADJ_ROOM_ENCAP_L2(len): Use with ENCAP_L3/L4 <[ flags ]>(IP: 3) to further specify the tunnel type; len is the length of the inner MAC header. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_skb_adjust_room",
              "Input Params": [
                "{Type: struct sk_buff ,Var: *skb}",
                "{Type:  s32 ,Var: len_diff}",
                "{Type:  u32 ,Var: mode}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "update_pkt"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 763,
      "endLine": 768,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_buf_add_room",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *md",
        " int delta",
        " __u64 flags"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_skb_adjust_room"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act"
      ],
      "source": [
        "static int __always_inline dp_buf_add_room (void *md, int delta, __u64 flags)\n",
        "{\n",
        "    return bpf_skb_adjust_room (md, delta, BPF_ADJ_ROOM_MAC, flags);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    },
    {
      "capabilities": [
        {
          "capability": "update_pkt",
          "update_pkt": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Adjust (move) xdp_md->data by <[ delta ]>(IP: 1) bytes. Note that it is possible to use a negative value for delta. This helper can be used to prepare the packet for pushing or popping headers. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_xdp_adjust_head",
              "Input Params": [
                "{Type: struct xdp_buff ,Var: *xdp_md}",
                "{Type:  int ,Var: delta}"
              ],
              "compatible_hookpoints": [
                "xdp"
              ],
              "capabilities": [
                "update_pkt"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1744,
      "endLine": 1748,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_buf_add_room",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *md",
        " int delta",
        " __u64 flags"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_xdp_adjust_head"
      ],
      "compatibleHookpoints": [
        "xdp"
      ],
      "source": [
        "static int __always_inline dp_buf_add_room (void *md, int delta, __u64 flags)\n",
        "{\n",
        "    return bpf_xdp_adjust_head (md, -delta);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_buf_delete_room": [
    {
      "capabilities": [
        {
          "capability": "update_pkt",
          "update_pkt": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Grow or shrink the room for data in the packet associated to <[ skb ]>(IP: 0) by <[ len_diff ]>(IP: 1) , and according to the selected mode. There are two supported modes at this time: \u00b7 BPF_ADJ_ROOM_MAC: Adjust room at the mac layer (room space is added or removed below the layer 2 header). \u00b7 BPF_ADJ_ROOM_NET: Adjust room at the network layer (room space is added or removed below the layer 3 header). The following <[ flags ]>(IP: 3) are supported at this time: \u00b7 BPF_F_ADJ_ROOM_FIXED_GSO: Do not adjust gso_size. Adjusting mss in this way is not allowed for datagrams. \u00b7 BPF_F_ADJ_ROOM_ENCAP_L3_IPV4 , BPF_F_ADJ_ROOM_ENCAP_L3_IPV6: Any new space is reserved to hold a tunnel header. Configure <[ skb ]>(IP: 0) offsets and other fields accordingly. \u00b7 BPF_F_ADJ_ROOM_ENCAP_L4_GRE , BPF_F_ADJ_ROOM_ENCAP_L4_UDP: Use with ENCAP_L3 <[ flags ]>(IP: 3) to further specify the tunnel type. \u00b7 BPF_F_ADJ_ROOM_ENCAP_L2(len): Use with ENCAP_L3/L4 <[ flags ]>(IP: 3) to further specify the tunnel type; len is the length of the inner MAC header. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_skb_adjust_room",
              "Input Params": [
                "{Type: struct sk_buff ,Var: *skb}",
                "{Type:  s32 ,Var: len_diff}",
                "{Type:  u32 ,Var: mode}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "update_pkt"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 770,
      "endLine": 775,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_buf_delete_room",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *md",
        " int delta",
        " __u64 flags"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_skb_adjust_room"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act"
      ],
      "source": [
        "static int __always_inline dp_buf_delete_room (void *md, int delta, __u64 flags)\n",
        "{\n",
        "    return bpf_skb_adjust_room (md, -delta, BPF_ADJ_ROOM_MAC, flags);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    },
    {
      "capabilities": [
        {
          "capability": "update_pkt",
          "update_pkt": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Adjust (move) xdp_md->data by <[ delta ]>(IP: 1) bytes. Note that it is possible to use a negative value for delta. This helper can be used to prepare the packet for pushing or popping headers. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_xdp_adjust_head",
              "Input Params": [
                "{Type: struct xdp_buff ,Var: *xdp_md}",
                "{Type:  int ,Var: delta}"
              ],
              "compatible_hookpoints": [
                "xdp"
              ],
              "capabilities": [
                "update_pkt"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1750,
      "endLine": 1754,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_buf_delete_room",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *md",
        " int delta",
        " __u64 flags"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_xdp_adjust_head"
      ],
      "compatibleHookpoints": [
        "xdp"
      ],
      "source": [
        "static int __always_inline dp_buf_delete_room (void *md, int delta, __u64 flags)\n",
        "{\n",
        "    return bpf_xdp_adjust_head (md, delta);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_redirect_port": [
    {
      "capabilities": [
        {
          "capability": "pkt_stop_processing_drop_packet",
          "pkt_stop_processing_drop_packet": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_SHOT",
              "Return": 2,
              "Description": "instructs the kernel to drop the packet, meaning, upper layers of the networking stack will never see the skb on ingress and similarly the packet will never be submitted for transmission on egress. TC_ACT_SHOT and TC_ACT_STOLEN are both similar in nature with few differences: TC_ACT_SHOT will indicate to the kernel that the skb was released through kfree_skb() and return NET_XMIT_DROP to the callers for immediate feedback, whereas TC_ACT_STOLEN will release the skb through consume_skb() and pretend to upper layers that the transmission was successful through NET_XMIT_SUCCESS. The perf\u2019s drop monitor which records traces of kfree_skb() will therefore also not see any drop indications from TC_ACT_STOLEN since its semantics are such that the skb has been \u201cconsumed\u201d or queued but certainly not \"dropped\".",
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_stop_processing_drop_packet"
              ]
            }
          ]
        },
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 777,
      "endLine": 789,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_redirect_port",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [
        " tbl"
      ],
      "input": [
        "void *tbl",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "TC_ACT_SHOT",
        "redirect",
        "bpf_redirect",
        "bpf_map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act"
      ],
      "source": [
        "static int __always_inline dp_redirect_port (void *tbl, struct xfi *xf)\n",
        "{\n",
        "    int *oif;\n",
        "    int key = xf->pm.oport;\n",
        "    oif = bpf_map_lookup_elem (tbl, & key);\n",
        "    if (!oif) {\n",
        "        return TC_ACT_SHOT;\n",
        "    }\n",
        "    LL_DBG_PRINTK (\"[REDR] port %d OIF %d\\n\", key, *oif);\n",
        "    return bpf_redirect (*oif, 0);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1756,
      "endLine": 1760,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_redirect_port",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *tbl",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "redirect",
        "bpf_redirect_map",
        "bpf_redirect"
      ],
      "compatibleHookpoints": [
        "xdp"
      ],
      "source": [
        "static int __always_inline dp_redirect_port (void *tbl, struct xfi *xf)\n",
        "{\n",
        "    return bpf_redirect_map (tbl, xf->pm.oport, 0);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_rewire_port": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        },
        {
          "capability": "pkt_stop_processing_drop_packet",
          "pkt_stop_processing_drop_packet": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_SHOT",
              "Return": 2,
              "Description": "instructs the kernel to drop the packet, meaning, upper layers of the networking stack will never see the skb on ingress and similarly the packet will never be submitted for transmission on egress. TC_ACT_SHOT and TC_ACT_STOLEN are both similar in nature with few differences: TC_ACT_SHOT will indicate to the kernel that the skb was released through kfree_skb() and return NET_XMIT_DROP to the callers for immediate feedback, whereas TC_ACT_STOLEN will release the skb through consume_skb() and pretend to upper layers that the transmission was successful through NET_XMIT_SUCCESS. The perf\u2019s drop monitor which records traces of kfree_skb() will therefore also not see any drop indications from TC_ACT_STOLEN since its semantics are such that the skb has been \u201cconsumed\u201d or queued but certainly not \"dropped\".",
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_stop_processing_drop_packet"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 791,
      "endLine": 802,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_rewire_port",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [
        " tbl"
      ],
      "input": [
        "void *tbl",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_map_lookup_elem",
        "bpf_redirect",
        "TC_ACT_SHOT"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act"
      ],
      "source": [
        "static int __always_inline dp_rewire_port (void *tbl, struct xfi *xf)\n",
        "{\n",
        "    int *oif;\n",
        "    int key = xf->pm.oport;\n",
        "    oif = bpf_map_lookup_elem (tbl, & key);\n",
        "    if (!oif) {\n",
        "        return TC_ACT_SHOT;\n",
        "    }\n",
        "    return bpf_redirect (*oif, BPF_F_INGRESS);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1762,
      "endLine": 1767,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_rewire_port",
      "developer_inline_comments": [
        {
          "start_line": 1765,
          "end_line": 1765,
          "text": " Not supported "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *tbl",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_rewire_port (void *tbl, struct xfi *xf)\n",
        "{\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_record_it": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "libbpf",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "bpf_map_lookup_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        },
        {
          "capability": "pkt_stop_processing_drop_packet",
          "pkt_stop_processing_drop_packet": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_SHOT",
              "Return": 2,
              "Description": "instructs the kernel to drop the packet, meaning, upper layers of the networking stack will never see the skb on ingress and similarly the packet will never be submitted for transmission on egress. TC_ACT_SHOT and TC_ACT_STOLEN are both similar in nature with few differences: TC_ACT_SHOT will indicate to the kernel that the skb was released through kfree_skb() and return NET_XMIT_DROP to the callers for immediate feedback, whereas TC_ACT_STOLEN will release the skb through consume_skb() and pretend to upper layers that the transmission was successful through NET_XMIT_SUCCESS. The perf\u2019s drop monitor which records traces of kfree_skb() will therefore also not see any drop indications from TC_ACT_STOLEN since its semantics are such that the skb has been \u201cconsumed\u201d or queued but certainly not \"dropped\".",
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_stop_processing_drop_packet"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 804,
      "endLine": 815,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_record_it",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [
        "  tx_intf_map"
      ],
      "input": [
        "void *skb",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_map_lookup_elem",
        "redirect",
        "bpf_clone_redirect",
        "TC_ACT_SHOT"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act"
      ],
      "source": [
        "static int __always_inline dp_record_it (void *skb, struct xfi *xf)\n",
        "{\n",
        "    int *oif;\n",
        "    int key = LLB_PORT_NO;\n",
        "    oif = bpf_map_lookup_elem (& tx_intf_map, & key);\n",
        "    if (!oif) {\n",
        "        return TC_ACT_SHOT;\n",
        "    }\n",
        "    return bpf_clone_redirect (skb, *oif, 0);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1769,
      "endLine": 1774,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_record_it",
      "developer_inline_comments": [
        {
          "start_line": 1772,
          "end_line": 1772,
          "text": " Not supported "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_record_it (void *ctx, struct xfi *xf)\n",
        "{\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_remove_vlan_tag": [
    {
      "capabilities": [
        {
          "capability": "update_pkt",
          "update_pkt": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Pop a VLAN header from the packet associated to skb. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_skb_vlan_pop",
              "Input Params": [
                "{Type: struct sk_buff ,Var: *skb}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "update_pkt"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 817,
      "endLine": 833,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_remove_vlan_tag",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_skb_vlan_pop"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act"
      ],
      "source": [
        "static int __always_inline dp_remove_vlan_tag (void *ctx, struct xfi *xf)\n",
        "{\n",
        "    void *dend = DP_TC_PTR (DP_PDATA_END (ctx));\n",
        "    struct ethhdr *eth;\n",
        "    bpf_skb_vlan_pop (ctx);\n",
        "    eth = DP_TC_PTR (DP_PDATA (ctx));\n",
        "    dend = DP_TC_PTR (DP_PDATA_END (ctx));\n",
        "    if (eth + 1 > dend) {\n",
        "        return -1;\n",
        "    }\n",
        "    memcpy (eth->h_dest, xf->l2m.dl_dst, 6);\n",
        "    memcpy (eth->h_source, xf->l2m.dl_src, 6);\n",
        "    eth->h_proto = xf->l2m.dl_type;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_remove_l2"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1782,
      "endLine": 1801,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_remove_vlan_tag",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_remove_vlan_tag (void *ctx, struct xfi *xf)\n",
        "{\n",
        "    void *start = DP_TC_PTR (DP_PDATA (ctx));\n",
        "    void *dend = DP_TC_PTR (DP_PDATA_END (ctx));\n",
        "    struct ethhdr *eth;\n",
        "    struct vlanhdr *vlh;\n",
        "    if (start + (sizeof (*eth) + sizeof (*vlh)) > dend) {\n",
        "        return -1;\n",
        "    }\n",
        "    eth = DP_ADD_PTR (DP_PDATA (ctx), (int) sizeof (struct vlanhdr));\n",
        "    memcpy (eth->h_dest, xf->l2m.dl_dst, 6);\n",
        "    memcpy (eth->h_source, xf->l2m.dl_src, 6);\n",
        "    eth->h_proto = xf->l2m.dl_type;\n",
        "    if (dp_remove_l2 (ctx, (int) sizeof (struct vlanhdr))) {\n",
        "        return -1;\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_remove_l2"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_insert_vlan_tag": [
    {
      "capabilities": [
        {
          "capability": "update_pkt",
          "update_pkt": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Push a <[ vlan_tci ]>(IP: 2) (VLAN tag control information) of protocol <[ vlan_proto ]>(IP: 1) to the packet associated to <[ skb ]>(IP: 0) , then update the checksum. Note that if <[ vlan_proto ]>(IP: 1) is different from ETH_P_8021Q and ETH_P_8021AD , it is considered to be ETH_P_8021Q. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_skb_vlan_push",
              "Input Params": [
                "{Type: struct sk_buff ,Var: *skb}",
                "{Type:  __be16 ,Var: vlan_proto}",
                "{Type:  u16 ,Var: vlan_tci}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "update_pkt"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 835,
      "endLine": 850,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_insert_vlan_tag",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf",
        " __be16 vlan"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_skb_vlan_push"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act"
      ],
      "source": [
        "static int __always_inline dp_insert_vlan_tag (void *ctx, struct xfi *xf, __be16 vlan)\n",
        "{\n",
        "    void *dend = DP_TC_PTR (DP_PDATA_END (ctx));\n",
        "    struct ethhdr *eth;\n",
        "    bpf_skb_vlan_push (ctx, bpf_ntohs (xf->l2m.dl_type), bpf_ntohs (vlan));\n",
        "    eth = DP_TC_PTR (DP_PDATA (ctx));\n",
        "    dend = DP_TC_PTR (DP_PDATA_END (ctx));\n",
        "    if (eth + 1 > dend) {\n",
        "        return -1;\n",
        "    }\n",
        "    memcpy (eth->h_dest, xf->l2m.dl_dst, 6);\n",
        "    memcpy (eth->h_source, xf->l2m.dl_src, 6);\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_add_l2"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1803,
      "endLine": 1838,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_insert_vlan_tag",
      "developer_inline_comments": [
        {
          "start_line": 1817,
          "end_line": 1817,
          "text": " Revalidate for satisfy eBPF verifier "
        },
        {
          "start_line": 1825,
          "end_line": 1825,
          "text": " FIXME : "
        },
        {
          "start_line": 1835,
          "end_line": 1835,
          "text": " FIXME : "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf",
        " __be16 vlan"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_insert_vlan_tag (void *ctx, struct xfi *xf, __be16 vlan)\n",
        "{\n",
        "    struct ethhdr *neth;\n",
        "    struct vlanhdr *vlh;\n",
        "    void *dend = DP_TC_PTR (DP_PDATA_END (ctx));\n",
        "    if (dp_add_l2 (ctx, (int) sizeof (struct vlanhdr))) {\n",
        "        return -1;\n",
        "    }\n",
        "    neth = DP_TC_PTR (DP_PDATA (ctx));\n",
        "    dend = DP_TC_PTR (DP_PDATA_END (ctx));\n",
        "    if (DP_TC_PTR (neth) + sizeof (*neth) > dend) {\n",
        "        return -1;\n",
        "    }\n",
        "    memcpy (neth->h_dest, xf->l2m.dl_dst, 6);\n",
        "    memcpy (neth->h_source, xf->l2m.dl_src, 6);\n",
        "    neth->h_proto = bpf_htons (ETH_P_8021Q);\n",
        "    vlh = DP_ADD_PTR (DP_PDATA (ctx), sizeof (* neth));\n",
        "    if (DP_TC_PTR (vlh) + sizeof (*vlh) > dend) {\n",
        "        return -1;\n",
        "    }\n",
        "    vlh->h_vlan_TCI = vlan;\n",
        "    vlh->h_vlan_encapsulated_proto = xf->l2m.dl_type;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_add_l2"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_swap_vlan_tag": [
    {
      "capabilities": [
        {
          "capability": "update_pkt",
          "update_pkt": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Pop a VLAN header from the packet associated to skb. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_skb_vlan_pop",
              "Input Params": [
                "{Type: struct sk_buff ,Var: *skb}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "update_pkt"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 852,
      "endLine": 857,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_swap_vlan_tag",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf",
        " __be16 vlan"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_skb_vlan_pop"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act"
      ],
      "source": [
        "static int __always_inline dp_swap_vlan_tag (void *ctx, struct xfi *xf, __be16 vlan)\n",
        "{\n",
        "    bpf_skb_vlan_pop (ctx);\n",
        "    return dp_insert_vlan_tag (ctx, xf, vlan);\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_insert_vlan_tag"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1840,
      "endLine": 1861,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_swap_vlan_tag",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf",
        " __be16 vlan"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_swap_vlan_tag (void *ctx, struct xfi *xf, __be16 vlan)\n",
        "{\n",
        "    struct ethhdr *eth;\n",
        "    struct vlanhdr *vlh;\n",
        "    void *start = DP_TC_PTR (DP_PDATA (ctx));\n",
        "    void *dend = DP_TC_PTR (DP_PDATA_END (ctx));\n",
        "    if ((start + sizeof (*eth)) > dend) {\n",
        "        return -1;\n",
        "    }\n",
        "    eth = DP_TC_PTR (DP_PDATA (ctx));\n",
        "    memcpy (eth->h_dest, xf->l2m.dl_dst, 6);\n",
        "    memcpy (eth->h_source, xf->l2m.dl_src, 6);\n",
        "    vlh = DP_ADD_PTR (DP_PDATA (ctx), sizeof (* eth));\n",
        "    if (DP_TC_PTR (vlh) + sizeof (*vlh) > dend) {\n",
        "        return -1;\n",
        "    }\n",
        "    vlh->h_vlan_TCI = vlan;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_insert_vlan_tag"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_set_tcp_src_ip6": [
    {
      "capabilities": [
        {
          "capability": "update_pkt",
          "update_pkt": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Recompute the layer 4 (e. g. TCP , UDP or ICMP) checksum for the packet associated <[ to ]>(IP: 3) skb. Computation is incremental , so the helper must know the former value of the header field that was modified (from) , the new value of this field (to) , and the number of bytes (2 or 4) for this field , stored on the lowest four bits of flags. Alternatively , it is possible <[ to ]>(IP: 3) store the difference between the previous and the new values of the header field in <[ to ]>(IP: 3) , by setting <[ from ]>(IP: 2) and the four lowest bits of <[ flags ]>(IP: 4) <[ to ]>(IP: 3) 0. For both methods , <[ offset ]>(IP: 1) indicates the location of the IP checksum within the packet. In addition <[ to ]>(IP: 3) the size of the field , <[ flags ]>(IP: 4) can be added (bitwise OR) actual flags. With BPF_F_MARK_MANGLED_0 , a null checksum is left untouched (unless BPF_F_MARK_ENFORCE is added as well) , and for updates resulting in a null checksum the value is set <[ to ]>(IP: 3) CSUM_MANGLED_0 instead. Flag BPF_F_PSEUDO_HDR indicates the checksum is <[ to ]>(IP: 3) be computed against a pseudo-header. This helper works in combination with bpf_csum_diff() , which does not update the checksum in-place , but offers more flexibility and can handle sizes larger than 2 or 4 for the checksum <[ to ]>(IP: 3) update. A call <[ to ]>(IP: 3) this helper is susceptible <[ to ]>(IP: 3) change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_l4_csum_replace",
              "Input Params": [
                "{Type: struct sk_buff ,Var: *skb}",
                "{Type:  u32 ,Var: offset}",
                "{Type:  u64 ,Var: from}",
                "{Type:  u64 ,Var: to}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "lwt_xmit"
              ],
              "capabilities": [
                "update_pkt"
              ]
            },
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Store <[ len ]>(IP: 3) bytes <[ from ]>(IP: 2) address <[ from ]>(IP: 2) into the packet associated to <[ skb ]>(IP: 0) , at offset. <[ flags ]>(IP: 4) are a combination of BPF_F_RECOMPUTE_CSUM (automatically recompute the checksum for the packet after storing the bytes) and BPF_F_INVALIDATE_HASH (set skb->hash , skb->swhash and skb->l4hash to 0). A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_skb_store_bytes",
              "Input Params": [
                "{Type: struct sk_buff ,Var: *skb}",
                "{Type:  u32 ,Var: offset}",
                "{Type:  const void ,Var: *from}",
                "{Type:  u32 ,Var: len}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "lwt_xmit",
                "sk_skb"
              ],
              "capabilities": [
                "update_pkt"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 859,
      "endLine": 875,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_set_tcp_src_ip6",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *md",
        " struct xfi *xf",
        " __be32 *xip"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_l4_csum_replace",
        "bpf_skb_store_bytes"
      ],
      "compatibleHookpoints": [
        "lwt_xmit",
        "sched_cls",
        "sched_act"
      ],
      "source": [
        "static int __always_inline dp_set_tcp_src_ip6 (void *md, struct xfi *xf, __be32 *xip)\n",
        "{\n",
        "    int tcp_csum_off = xf->pm.l4_off + offsetof (struct tcphdr, check);\n",
        "    int ip_src_off = xf->pm.l3_off + offsetof (struct ipv6hdr, saddr);\n",
        "    __be32 *old_sip = xf->l34m.saddr;\n",
        "    bpf_l4_csum_replace (md, tcp_csum_off, old_sip[0], xip[0], BPF_F_PSEUDO_HDR | sizeof (*xip));\n",
        "    bpf_l4_csum_replace (md, tcp_csum_off, old_sip[1], xip[1], BPF_F_PSEUDO_HDR | sizeof (*xip));\n",
        "    bpf_l4_csum_replace (md, tcp_csum_off, old_sip[2], xip[2], BPF_F_PSEUDO_HDR | sizeof (*xip));\n",
        "    bpf_l4_csum_replace (md, tcp_csum_off, old_sip[3], xip[3], BPF_F_PSEUDO_HDR | sizeof (*xip));\n",
        "    bpf_skb_store_bytes (md, ip_src_off, xip, sizeof (xf->l34m.saddr), 0);\n",
        "    DP_XADDR_CP (xf->l34m.saddr, xip);\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_set_tcp_src_ip": [
    {
      "capabilities": [
        {
          "capability": "update_pkt",
          "update_pkt": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Recompute the layer 4 (e. g. TCP , UDP or ICMP) checksum for the packet associated <[ to ]>(IP: 3) skb. Computation is incremental , so the helper must know the former value of the header field that was modified (from) , the new value of this field (to) , and the number of bytes (2 or 4) for this field , stored on the lowest four bits of flags. Alternatively , it is possible <[ to ]>(IP: 3) store the difference between the previous and the new values of the header field in <[ to ]>(IP: 3) , by setting <[ from ]>(IP: 2) and the four lowest bits of <[ flags ]>(IP: 4) <[ to ]>(IP: 3) 0. For both methods , <[ offset ]>(IP: 1) indicates the location of the IP checksum within the packet. In addition <[ to ]>(IP: 3) the size of the field , <[ flags ]>(IP: 4) can be added (bitwise OR) actual flags. With BPF_F_MARK_MANGLED_0 , a null checksum is left untouched (unless BPF_F_MARK_ENFORCE is added as well) , and for updates resulting in a null checksum the value is set <[ to ]>(IP: 3) CSUM_MANGLED_0 instead. Flag BPF_F_PSEUDO_HDR indicates the checksum is <[ to ]>(IP: 3) be computed against a pseudo-header. This helper works in combination with bpf_csum_diff() , which does not update the checksum in-place , but offers more flexibility and can handle sizes larger than 2 or 4 for the checksum <[ to ]>(IP: 3) update. A call <[ to ]>(IP: 3) this helper is susceptible <[ to ]>(IP: 3) change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_l4_csum_replace",
              "Input Params": [
                "{Type: struct sk_buff ,Var: *skb}",
                "{Type:  u32 ,Var: offset}",
                "{Type:  u64 ,Var: from}",
                "{Type:  u64 ,Var: to}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "lwt_xmit"
              ],
              "capabilities": [
                "update_pkt"
              ]
            },
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Recompute the layer 3 (e. g. IP) checksum for the packet associated <[ to ]>(IP: 3) skb. Computation is incremental , so the helper must know the former value of the header field that was modified (from) , the new value of this field (to) , and the number of bytes (2 or 4) for this field , stored in size. Alternatively , it is possible <[ to ]>(IP: 3) store the difference between the previous and the new values of the header field in <[ to ]>(IP: 3) , by setting <[ from ]>(IP: 2) and <[ size ]>(IP: 4) <[ to ]>(IP: 3) 0. For both methods , <[ offset ]>(IP: 1) indicates the location of the IP checksum within the packet. This helper works in combination with bpf_csum_diff() , which does not update the checksum in-place , but offers more flexibility and can handle sizes larger than 2 or 4 for the checksum <[ to ]>(IP: 3) update. A call <[ to ]>(IP: 3) this helper is susceptible <[ to ]>(IP: 3) change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_l3_csum_replace",
              "Input Params": [
                "{Type: struct sk_buff ,Var: *skb}",
                "{Type:  u32 ,Var: offset}",
                "{Type:  u64 ,Var: from}",
                "{Type:  u64 ,Var: to}",
                "{Type:  u64 ,Var: size}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "lwt_xmit"
              ],
              "capabilities": [
                "update_pkt"
              ]
            },
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Store <[ len ]>(IP: 3) bytes <[ from ]>(IP: 2) address <[ from ]>(IP: 2) into the packet associated to <[ skb ]>(IP: 0) , at offset. <[ flags ]>(IP: 4) are a combination of BPF_F_RECOMPUTE_CSUM (automatically recompute the checksum for the packet after storing the bytes) and BPF_F_INVALIDATE_HASH (set skb->hash , skb->swhash and skb->l4hash to 0). A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_skb_store_bytes",
              "Input Params": [
                "{Type: struct sk_buff ,Var: *skb}",
                "{Type:  u32 ,Var: offset}",
                "{Type:  const void ,Var: *from}",
                "{Type:  u32 ,Var: len}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "lwt_xmit",
                "sk_skb"
              ],
              "capabilities": [
                "update_pkt"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 877,
      "endLine": 892,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_set_tcp_src_ip",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *md",
        " struct xfi *xf",
        " __be32 xip"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_l4_csum_replace",
        "bpf_l3_csum_replace",
        "bpf_skb_store_bytes"
      ],
      "compatibleHookpoints": [
        "lwt_xmit",
        "sched_cls",
        "sched_act"
      ],
      "source": [
        "static int __always_inline dp_set_tcp_src_ip (void *md, struct xfi *xf, __be32 xip)\n",
        "{\n",
        "    int ip_csum_off = xf->pm.l3_off + offsetof (struct iphdr, check);\n",
        "    int tcp_csum_off = xf->pm.l4_off + offsetof (struct tcphdr, check);\n",
        "    int ip_src_off = xf->pm.l3_off + offsetof (struct iphdr, saddr);\n",
        "    __be32 old_sip = xf->l34m.saddr4;\n",
        "    bpf_l4_csum_replace (md, tcp_csum_off, old_sip, xip, BPF_F_PSEUDO_HDR | sizeof (xip));\n",
        "    bpf_l3_csum_replace (md, ip_csum_off, old_sip, xip, sizeof (xip));\n",
        "    bpf_skb_store_bytes (md, ip_src_off, &xip, sizeof (xip), 0);\n",
        "    xf->l34m.saddr4 = xip;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_set_tcp_dst_ip6": [
    {
      "capabilities": [
        {
          "capability": "update_pkt",
          "update_pkt": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Recompute the layer 4 (e. g. TCP , UDP or ICMP) checksum for the packet associated <[ to ]>(IP: 3) skb. Computation is incremental , so the helper must know the former value of the header field that was modified (from) , the new value of this field (to) , and the number of bytes (2 or 4) for this field , stored on the lowest four bits of flags. Alternatively , it is possible <[ to ]>(IP: 3) store the difference between the previous and the new values of the header field in <[ to ]>(IP: 3) , by setting <[ from ]>(IP: 2) and the four lowest bits of <[ flags ]>(IP: 4) <[ to ]>(IP: 3) 0. For both methods , <[ offset ]>(IP: 1) indicates the location of the IP checksum within the packet. In addition <[ to ]>(IP: 3) the size of the field , <[ flags ]>(IP: 4) can be added (bitwise OR) actual flags. With BPF_F_MARK_MANGLED_0 , a null checksum is left untouched (unless BPF_F_MARK_ENFORCE is added as well) , and for updates resulting in a null checksum the value is set <[ to ]>(IP: 3) CSUM_MANGLED_0 instead. Flag BPF_F_PSEUDO_HDR indicates the checksum is <[ to ]>(IP: 3) be computed against a pseudo-header. This helper works in combination with bpf_csum_diff() , which does not update the checksum in-place , but offers more flexibility and can handle sizes larger than 2 or 4 for the checksum <[ to ]>(IP: 3) update. A call <[ to ]>(IP: 3) this helper is susceptible <[ to ]>(IP: 3) change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_l4_csum_replace",
              "Input Params": [
                "{Type: struct sk_buff ,Var: *skb}",
                "{Type:  u32 ,Var: offset}",
                "{Type:  u64 ,Var: from}",
                "{Type:  u64 ,Var: to}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "lwt_xmit"
              ],
              "capabilities": [
                "update_pkt"
              ]
            },
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Store <[ len ]>(IP: 3) bytes <[ from ]>(IP: 2) address <[ from ]>(IP: 2) into the packet associated to <[ skb ]>(IP: 0) , at offset. <[ flags ]>(IP: 4) are a combination of BPF_F_RECOMPUTE_CSUM (automatically recompute the checksum for the packet after storing the bytes) and BPF_F_INVALIDATE_HASH (set skb->hash , skb->swhash and skb->l4hash to 0). A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_skb_store_bytes",
              "Input Params": [
                "{Type: struct sk_buff ,Var: *skb}",
                "{Type:  u32 ,Var: offset}",
                "{Type:  const void ,Var: *from}",
                "{Type:  u32 ,Var: len}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "lwt_xmit",
                "sk_skb"
              ],
              "capabilities": [
                "update_pkt"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 894,
      "endLine": 910,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_set_tcp_dst_ip6",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *md",
        " struct xfi *xf",
        " __be32 *xip"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_l4_csum_replace",
        "bpf_skb_store_bytes"
      ],
      "compatibleHookpoints": [
        "lwt_xmit",
        "sched_cls",
        "sched_act"
      ],
      "source": [
        "static int __always_inline dp_set_tcp_dst_ip6 (void *md, struct xfi *xf, __be32 *xip)\n",
        "{\n",
        "    int tcp_csum_off = xf->pm.l4_off + offsetof (struct tcphdr, check);\n",
        "    int ip_dst_off = xf->pm.l3_off + offsetof (struct ipv6hdr, daddr);\n",
        "    __be32 *old_dip = xf->l34m.daddr;\n",
        "    bpf_l4_csum_replace (md, tcp_csum_off, old_dip[0], xip[0], BPF_F_PSEUDO_HDR | sizeof (*xip));\n",
        "    bpf_l4_csum_replace (md, tcp_csum_off, old_dip[1], xip[1], BPF_F_PSEUDO_HDR | sizeof (*xip));\n",
        "    bpf_l4_csum_replace (md, tcp_csum_off, old_dip[2], xip[2], BPF_F_PSEUDO_HDR | sizeof (*xip));\n",
        "    bpf_l4_csum_replace (md, tcp_csum_off, old_dip[3], xip[3], BPF_F_PSEUDO_HDR | sizeof (*xip));\n",
        "    bpf_skb_store_bytes (md, ip_dst_off, xip, sizeof (xf->l34m.saddr), 0);\n",
        "    DP_XADDR_CP (xf->l34m.daddr, xip);\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_set_tcp_dst_ip": [
    {
      "capabilities": [
        {
          "capability": "update_pkt",
          "update_pkt": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Recompute the layer 4 (e. g. TCP , UDP or ICMP) checksum for the packet associated <[ to ]>(IP: 3) skb. Computation is incremental , so the helper must know the former value of the header field that was modified (from) , the new value of this field (to) , and the number of bytes (2 or 4) for this field , stored on the lowest four bits of flags. Alternatively , it is possible <[ to ]>(IP: 3) store the difference between the previous and the new values of the header field in <[ to ]>(IP: 3) , by setting <[ from ]>(IP: 2) and the four lowest bits of <[ flags ]>(IP: 4) <[ to ]>(IP: 3) 0. For both methods , <[ offset ]>(IP: 1) indicates the location of the IP checksum within the packet. In addition <[ to ]>(IP: 3) the size of the field , <[ flags ]>(IP: 4) can be added (bitwise OR) actual flags. With BPF_F_MARK_MANGLED_0 , a null checksum is left untouched (unless BPF_F_MARK_ENFORCE is added as well) , and for updates resulting in a null checksum the value is set <[ to ]>(IP: 3) CSUM_MANGLED_0 instead. Flag BPF_F_PSEUDO_HDR indicates the checksum is <[ to ]>(IP: 3) be computed against a pseudo-header. This helper works in combination with bpf_csum_diff() , which does not update the checksum in-place , but offers more flexibility and can handle sizes larger than 2 or 4 for the checksum <[ to ]>(IP: 3) update. A call <[ to ]>(IP: 3) this helper is susceptible <[ to ]>(IP: 3) change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_l4_csum_replace",
              "Input Params": [
                "{Type: struct sk_buff ,Var: *skb}",
                "{Type:  u32 ,Var: offset}",
                "{Type:  u64 ,Var: from}",
                "{Type:  u64 ,Var: to}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "lwt_xmit"
              ],
              "capabilities": [
                "update_pkt"
              ]
            },
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Recompute the layer 3 (e. g. IP) checksum for the packet associated <[ to ]>(IP: 3) skb. Computation is incremental , so the helper must know the former value of the header field that was modified (from) , the new value of this field (to) , and the number of bytes (2 or 4) for this field , stored in size. Alternatively , it is possible <[ to ]>(IP: 3) store the difference between the previous and the new values of the header field in <[ to ]>(IP: 3) , by setting <[ from ]>(IP: 2) and <[ size ]>(IP: 4) <[ to ]>(IP: 3) 0. For both methods , <[ offset ]>(IP: 1) indicates the location of the IP checksum within the packet. This helper works in combination with bpf_csum_diff() , which does not update the checksum in-place , but offers more flexibility and can handle sizes larger than 2 or 4 for the checksum <[ to ]>(IP: 3) update. A call <[ to ]>(IP: 3) this helper is susceptible <[ to ]>(IP: 3) change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_l3_csum_replace",
              "Input Params": [
                "{Type: struct sk_buff ,Var: *skb}",
                "{Type:  u32 ,Var: offset}",
                "{Type:  u64 ,Var: from}",
                "{Type:  u64 ,Var: to}",
                "{Type:  u64 ,Var: size}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "lwt_xmit"
              ],
              "capabilities": [
                "update_pkt"
              ]
            },
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Store <[ len ]>(IP: 3) bytes <[ from ]>(IP: 2) address <[ from ]>(IP: 2) into the packet associated to <[ skb ]>(IP: 0) , at offset. <[ flags ]>(IP: 4) are a combination of BPF_F_RECOMPUTE_CSUM (automatically recompute the checksum for the packet after storing the bytes) and BPF_F_INVALIDATE_HASH (set skb->hash , skb->swhash and skb->l4hash to 0). A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_skb_store_bytes",
              "Input Params": [
                "{Type: struct sk_buff ,Var: *skb}",
                "{Type:  u32 ,Var: offset}",
                "{Type:  const void ,Var: *from}",
                "{Type:  u32 ,Var: len}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "lwt_xmit",
                "sk_skb"
              ],
              "capabilities": [
                "update_pkt"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 912,
      "endLine": 926,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_set_tcp_dst_ip",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *md",
        " struct xfi *xf",
        " __be32 xip"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_l4_csum_replace",
        "bpf_l3_csum_replace",
        "bpf_skb_store_bytes"
      ],
      "compatibleHookpoints": [
        "lwt_xmit",
        "sched_cls",
        "sched_act"
      ],
      "source": [
        "static int __always_inline dp_set_tcp_dst_ip (void *md, struct xfi *xf, __be32 xip)\n",
        "{\n",
        "    int ip_csum_off = xf->pm.l3_off + offsetof (struct iphdr, check);\n",
        "    int tcp_csum_off = xf->pm.l4_off + offsetof (struct tcphdr, check);\n",
        "    int ip_dst_off = xf->pm.l3_off + offsetof (struct iphdr, daddr);\n",
        "    __be32 old_dip = xf->l34m.daddr4;\n",
        "    bpf_l4_csum_replace (md, tcp_csum_off, old_dip, xip, BPF_F_PSEUDO_HDR | sizeof (xip));\n",
        "    bpf_l3_csum_replace (md, ip_csum_off, old_dip, xip, sizeof (xip));\n",
        "    bpf_skb_store_bytes (md, ip_dst_off, &xip, sizeof (xip), 0);\n",
        "    xf->l34m.daddr4 = xip;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_set_tcp_sport": [
    {
      "capabilities": [
        {
          "capability": "update_pkt",
          "update_pkt": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Recompute the layer 4 (e. g. TCP , UDP or ICMP) checksum for the packet associated <[ to ]>(IP: 3) skb. Computation is incremental , so the helper must know the former value of the header field that was modified (from) , the new value of this field (to) , and the number of bytes (2 or 4) for this field , stored on the lowest four bits of flags. Alternatively , it is possible <[ to ]>(IP: 3) store the difference between the previous and the new values of the header field in <[ to ]>(IP: 3) , by setting <[ from ]>(IP: 2) and the four lowest bits of <[ flags ]>(IP: 4) <[ to ]>(IP: 3) 0. For both methods , <[ offset ]>(IP: 1) indicates the location of the IP checksum within the packet. In addition <[ to ]>(IP: 3) the size of the field , <[ flags ]>(IP: 4) can be added (bitwise OR) actual flags. With BPF_F_MARK_MANGLED_0 , a null checksum is left untouched (unless BPF_F_MARK_ENFORCE is added as well) , and for updates resulting in a null checksum the value is set <[ to ]>(IP: 3) CSUM_MANGLED_0 instead. Flag BPF_F_PSEUDO_HDR indicates the checksum is <[ to ]>(IP: 3) be computed against a pseudo-header. This helper works in combination with bpf_csum_diff() , which does not update the checksum in-place , but offers more flexibility and can handle sizes larger than 2 or 4 for the checksum <[ to ]>(IP: 3) update. A call <[ to ]>(IP: 3) this helper is susceptible <[ to ]>(IP: 3) change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_l4_csum_replace",
              "Input Params": [
                "{Type: struct sk_buff ,Var: *skb}",
                "{Type:  u32 ,Var: offset}",
                "{Type:  u64 ,Var: from}",
                "{Type:  u64 ,Var: to}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "lwt_xmit"
              ],
              "capabilities": [
                "update_pkt"
              ]
            },
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Store <[ len ]>(IP: 3) bytes <[ from ]>(IP: 2) address <[ from ]>(IP: 2) into the packet associated to <[ skb ]>(IP: 0) , at offset. <[ flags ]>(IP: 4) are a combination of BPF_F_RECOMPUTE_CSUM (automatically recompute the checksum for the packet after storing the bytes) and BPF_F_INVALIDATE_HASH (set skb->hash , skb->swhash and skb->l4hash to 0). A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_skb_store_bytes",
              "Input Params": [
                "{Type: struct sk_buff ,Var: *skb}",
                "{Type:  u32 ,Var: offset}",
                "{Type:  const void ,Var: *from}",
                "{Type:  u32 ,Var: len}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "lwt_xmit",
                "sk_skb"
              ],
              "capabilities": [
                "update_pkt"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 928,
      "endLine": 940,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_set_tcp_sport",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *md",
        " struct xfi *xf",
        " __be16 xport"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_l4_csum_replace",
        "bpf_skb_store_bytes"
      ],
      "compatibleHookpoints": [
        "lwt_xmit",
        "sched_cls",
        "sched_act"
      ],
      "source": [
        "static int __always_inline dp_set_tcp_sport (void *md, struct xfi *xf, __be16 xport)\n",
        "{\n",
        "    int tcp_csum_off = xf->pm.l4_off + offsetof (struct tcphdr, check);\n",
        "    int tcp_sport_off = xf->pm.l4_off + offsetof (struct tcphdr, source);\n",
        "    __be32 old_sport = xf->l34m.source;\n",
        "    bpf_l4_csum_replace (md, tcp_csum_off, old_sport, xport, sizeof (xport));\n",
        "    bpf_skb_store_bytes (md, tcp_sport_off, &xport, sizeof (xport), 0);\n",
        "    xf->l34m.source = xport;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_set_tcp_dport": [
    {
      "capabilities": [
        {
          "capability": "update_pkt",
          "update_pkt": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Recompute the layer 4 (e. g. TCP , UDP or ICMP) checksum for the packet associated <[ to ]>(IP: 3) skb. Computation is incremental , so the helper must know the former value of the header field that was modified (from) , the new value of this field (to) , and the number of bytes (2 or 4) for this field , stored on the lowest four bits of flags. Alternatively , it is possible <[ to ]>(IP: 3) store the difference between the previous and the new values of the header field in <[ to ]>(IP: 3) , by setting <[ from ]>(IP: 2) and the four lowest bits of <[ flags ]>(IP: 4) <[ to ]>(IP: 3) 0. For both methods , <[ offset ]>(IP: 1) indicates the location of the IP checksum within the packet. In addition <[ to ]>(IP: 3) the size of the field , <[ flags ]>(IP: 4) can be added (bitwise OR) actual flags. With BPF_F_MARK_MANGLED_0 , a null checksum is left untouched (unless BPF_F_MARK_ENFORCE is added as well) , and for updates resulting in a null checksum the value is set <[ to ]>(IP: 3) CSUM_MANGLED_0 instead. Flag BPF_F_PSEUDO_HDR indicates the checksum is <[ to ]>(IP: 3) be computed against a pseudo-header. This helper works in combination with bpf_csum_diff() , which does not update the checksum in-place , but offers more flexibility and can handle sizes larger than 2 or 4 for the checksum <[ to ]>(IP: 3) update. A call <[ to ]>(IP: 3) this helper is susceptible <[ to ]>(IP: 3) change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_l4_csum_replace",
              "Input Params": [
                "{Type: struct sk_buff ,Var: *skb}",
                "{Type:  u32 ,Var: offset}",
                "{Type:  u64 ,Var: from}",
                "{Type:  u64 ,Var: to}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "lwt_xmit"
              ],
              "capabilities": [
                "update_pkt"
              ]
            },
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Store <[ len ]>(IP: 3) bytes <[ from ]>(IP: 2) address <[ from ]>(IP: 2) into the packet associated to <[ skb ]>(IP: 0) , at offset. <[ flags ]>(IP: 4) are a combination of BPF_F_RECOMPUTE_CSUM (automatically recompute the checksum for the packet after storing the bytes) and BPF_F_INVALIDATE_HASH (set skb->hash , skb->swhash and skb->l4hash to 0). A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_skb_store_bytes",
              "Input Params": [
                "{Type: struct sk_buff ,Var: *skb}",
                "{Type:  u32 ,Var: offset}",
                "{Type:  const void ,Var: *from}",
                "{Type:  u32 ,Var: len}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "lwt_xmit",
                "sk_skb"
              ],
              "capabilities": [
                "update_pkt"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 942,
      "endLine": 954,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_set_tcp_dport",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *md",
        " struct xfi *xf",
        " __be16 xport"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_l4_csum_replace",
        "bpf_skb_store_bytes"
      ],
      "compatibleHookpoints": [
        "lwt_xmit",
        "sched_cls",
        "sched_act"
      ],
      "source": [
        "static int __always_inline dp_set_tcp_dport (void *md, struct xfi *xf, __be16 xport)\n",
        "{\n",
        "    int tcp_csum_off = xf->pm.l4_off + offsetof (struct tcphdr, check);\n",
        "    int tcp_dport_off = xf->pm.l4_off + offsetof (struct tcphdr, dest);\n",
        "    __be32 old_dport = xf->l34m.dest;\n",
        "    bpf_l4_csum_replace (md, tcp_csum_off, old_dport, xport, sizeof (xport));\n",
        "    bpf_skb_store_bytes (md, tcp_dport_off, &xport, sizeof (xport), 0);\n",
        "    xf->l34m.dest = xport;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_set_udp_src_ip6": [
    {
      "capabilities": [
        {
          "capability": "update_pkt",
          "update_pkt": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Store <[ len ]>(IP: 3) bytes <[ from ]>(IP: 2) address <[ from ]>(IP: 2) into the packet associated to <[ skb ]>(IP: 0) , at offset. <[ flags ]>(IP: 4) are a combination of BPF_F_RECOMPUTE_CSUM (automatically recompute the checksum for the packet after storing the bytes) and BPF_F_INVALIDATE_HASH (set skb->hash , skb->swhash and skb->l4hash to 0). A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_skb_store_bytes",
              "Input Params": [
                "{Type: struct sk_buff ,Var: *skb}",
                "{Type:  u32 ,Var: offset}",
                "{Type:  const void ,Var: *from}",
                "{Type:  u32 ,Var: len}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "lwt_xmit",
                "sk_skb"
              ],
              "capabilities": [
                "update_pkt"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 956,
      "endLine": 969,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_set_udp_src_ip6",
      "developer_inline_comments": [
        {
          "start_line": 963,
          "end_line": 963,
          "text": " UDP checksum = 0 is valid "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *md",
        " struct xfi *xf",
        " __be32 *xip"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_skb_store_bytes"
      ],
      "compatibleHookpoints": [
        "lwt_xmit",
        "sched_cls",
        "sk_skb",
        "sched_act"
      ],
      "source": [
        "static int __always_inline dp_set_udp_src_ip6 (void *md, struct xfi *xf, __be32 *xip)\n",
        "{\n",
        "    int udp_csum_off = xf->pm.l4_off + offsetof (struct udphdr, check);\n",
        "    int ip_src_off = xf->pm.l3_off + offsetof (struct ipv6hdr, saddr);\n",
        "    __be16 csum = 0;\n",
        "    bpf_skb_store_bytes (md, udp_csum_off, &csum, sizeof (csum), 0);\n",
        "    bpf_skb_store_bytes (md, ip_src_off, xip, sizeof (xf->l34m.saddr), 0);\n",
        "    DP_XADDR_CP (xf->l34m.saddr, xip);\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_set_udp_src_ip": [
    {
      "capabilities": [
        {
          "capability": "update_pkt",
          "update_pkt": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Recompute the layer 3 (e. g. IP) checksum for the packet associated <[ to ]>(IP: 3) skb. Computation is incremental , so the helper must know the former value of the header field that was modified (from) , the new value of this field (to) , and the number of bytes (2 or 4) for this field , stored in size. Alternatively , it is possible <[ to ]>(IP: 3) store the difference between the previous and the new values of the header field in <[ to ]>(IP: 3) , by setting <[ from ]>(IP: 2) and <[ size ]>(IP: 4) <[ to ]>(IP: 3) 0. For both methods , <[ offset ]>(IP: 1) indicates the location of the IP checksum within the packet. This helper works in combination with bpf_csum_diff() , which does not update the checksum in-place , but offers more flexibility and can handle sizes larger than 2 or 4 for the checksum <[ to ]>(IP: 3) update. A call <[ to ]>(IP: 3) this helper is susceptible <[ to ]>(IP: 3) change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_l3_csum_replace",
              "Input Params": [
                "{Type: struct sk_buff ,Var: *skb}",
                "{Type:  u32 ,Var: offset}",
                "{Type:  u64 ,Var: from}",
                "{Type:  u64 ,Var: to}",
                "{Type:  u64 ,Var: size}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "lwt_xmit"
              ],
              "capabilities": [
                "update_pkt"
              ]
            },
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Store <[ len ]>(IP: 3) bytes <[ from ]>(IP: 2) address <[ from ]>(IP: 2) into the packet associated to <[ skb ]>(IP: 0) , at offset. <[ flags ]>(IP: 4) are a combination of BPF_F_RECOMPUTE_CSUM (automatically recompute the checksum for the packet after storing the bytes) and BPF_F_INVALIDATE_HASH (set skb->hash , skb->swhash and skb->l4hash to 0). A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_skb_store_bytes",
              "Input Params": [
                "{Type: struct sk_buff ,Var: *skb}",
                "{Type:  u32 ,Var: offset}",
                "{Type:  const void ,Var: *from}",
                "{Type:  u32 ,Var: len}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "lwt_xmit",
                "sk_skb"
              ],
              "capabilities": [
                "update_pkt"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 971,
      "endLine": 987,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_set_udp_src_ip",
      "developer_inline_comments": [
        {
          "start_line": 980,
          "end_line": 980,
          "text": " UDP checksum = 0 is valid "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *md",
        " struct xfi *xf",
        " __be32 xip"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_l3_csum_replace",
        "bpf_skb_store_bytes"
      ],
      "compatibleHookpoints": [
        "lwt_xmit",
        "sched_cls",
        "sched_act"
      ],
      "source": [
        "static int __always_inline dp_set_udp_src_ip (void *md, struct xfi *xf, __be32 xip)\n",
        "{\n",
        "    int ip_csum_off = xf->pm.l3_off + offsetof (struct iphdr, check);\n",
        "    int udp_csum_off = xf->pm.l4_off + offsetof (struct udphdr, check);\n",
        "    int ip_src_off = xf->pm.l3_off + offsetof (struct iphdr, saddr);\n",
        "    __be16 csum = 0;\n",
        "    __be32 old_sip = xf->l34m.saddr4;\n",
        "    bpf_skb_store_bytes (md, udp_csum_off, &csum, sizeof (csum), 0);\n",
        "    bpf_l3_csum_replace (md, ip_csum_off, old_sip, xip, sizeof (xip));\n",
        "    bpf_skb_store_bytes (md, ip_src_off, &xip, sizeof (xip), 0);\n",
        "    xf->l34m.saddr4 = xip;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_set_udp_dst_ip6": [
    {
      "capabilities": [
        {
          "capability": "update_pkt",
          "update_pkt": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Store <[ len ]>(IP: 3) bytes <[ from ]>(IP: 2) address <[ from ]>(IP: 2) into the packet associated to <[ skb ]>(IP: 0) , at offset. <[ flags ]>(IP: 4) are a combination of BPF_F_RECOMPUTE_CSUM (automatically recompute the checksum for the packet after storing the bytes) and BPF_F_INVALIDATE_HASH (set skb->hash , skb->swhash and skb->l4hash to 0). A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_skb_store_bytes",
              "Input Params": [
                "{Type: struct sk_buff ,Var: *skb}",
                "{Type:  u32 ,Var: offset}",
                "{Type:  const void ,Var: *from}",
                "{Type:  u32 ,Var: len}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "lwt_xmit",
                "sk_skb"
              ],
              "capabilities": [
                "update_pkt"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 989,
      "endLine": 1002,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_set_udp_dst_ip6",
      "developer_inline_comments": [
        {
          "start_line": 996,
          "end_line": 996,
          "text": " UDP checksum = 0 is valid "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *md",
        " struct xfi *xf",
        " __be32 *xip"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_skb_store_bytes"
      ],
      "compatibleHookpoints": [
        "lwt_xmit",
        "sched_cls",
        "sk_skb",
        "sched_act"
      ],
      "source": [
        "static int __always_inline dp_set_udp_dst_ip6 (void *md, struct xfi *xf, __be32 *xip)\n",
        "{\n",
        "    int udp_csum_off = xf->pm.l4_off + offsetof (struct udphdr, check);\n",
        "    int ip_dst_off = xf->pm.l3_off + offsetof (struct ipv6hdr, daddr);\n",
        "    __be16 csum = 0;\n",
        "    bpf_skb_store_bytes (md, udp_csum_off, &csum, sizeof (csum), 0);\n",
        "    bpf_skb_store_bytes (md, ip_dst_off, xip, sizeof (xf->l34m.daddr), 0);\n",
        "    DP_XADDR_CP (xf->l34m.daddr, xip);\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_set_udp_dst_ip": [
    {
      "capabilities": [
        {
          "capability": "update_pkt",
          "update_pkt": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Recompute the layer 3 (e. g. IP) checksum for the packet associated <[ to ]>(IP: 3) skb. Computation is incremental , so the helper must know the former value of the header field that was modified (from) , the new value of this field (to) , and the number of bytes (2 or 4) for this field , stored in size. Alternatively , it is possible <[ to ]>(IP: 3) store the difference between the previous and the new values of the header field in <[ to ]>(IP: 3) , by setting <[ from ]>(IP: 2) and <[ size ]>(IP: 4) <[ to ]>(IP: 3) 0. For both methods , <[ offset ]>(IP: 1) indicates the location of the IP checksum within the packet. This helper works in combination with bpf_csum_diff() , which does not update the checksum in-place , but offers more flexibility and can handle sizes larger than 2 or 4 for the checksum <[ to ]>(IP: 3) update. A call <[ to ]>(IP: 3) this helper is susceptible <[ to ]>(IP: 3) change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_l3_csum_replace",
              "Input Params": [
                "{Type: struct sk_buff ,Var: *skb}",
                "{Type:  u32 ,Var: offset}",
                "{Type:  u64 ,Var: from}",
                "{Type:  u64 ,Var: to}",
                "{Type:  u64 ,Var: size}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "lwt_xmit"
              ],
              "capabilities": [
                "update_pkt"
              ]
            },
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Store <[ len ]>(IP: 3) bytes <[ from ]>(IP: 2) address <[ from ]>(IP: 2) into the packet associated to <[ skb ]>(IP: 0) , at offset. <[ flags ]>(IP: 4) are a combination of BPF_F_RECOMPUTE_CSUM (automatically recompute the checksum for the packet after storing the bytes) and BPF_F_INVALIDATE_HASH (set skb->hash , skb->swhash and skb->l4hash to 0). A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_skb_store_bytes",
              "Input Params": [
                "{Type: struct sk_buff ,Var: *skb}",
                "{Type:  u32 ,Var: offset}",
                "{Type:  const void ,Var: *from}",
                "{Type:  u32 ,Var: len}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "lwt_xmit",
                "sk_skb"
              ],
              "capabilities": [
                "update_pkt"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1004,
      "endLine": 1020,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_set_udp_dst_ip",
      "developer_inline_comments": [
        {
          "start_line": 1013,
          "end_line": 1013,
          "text": " UDP checksum = 0 is valid "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *md",
        " struct xfi *xf",
        " __be32 xip"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_l3_csum_replace",
        "bpf_skb_store_bytes"
      ],
      "compatibleHookpoints": [
        "lwt_xmit",
        "sched_cls",
        "sched_act"
      ],
      "source": [
        "static int __always_inline dp_set_udp_dst_ip (void *md, struct xfi *xf, __be32 xip)\n",
        "{\n",
        "    int ip_csum_off = xf->pm.l3_off + offsetof (struct iphdr, check);\n",
        "    int udp_csum_off = xf->pm.l4_off + offsetof (struct udphdr, check);\n",
        "    int ip_dst_off = xf->pm.l3_off + offsetof (struct iphdr, daddr);\n",
        "    __be16 csum = 0;\n",
        "    __be32 old_dip = xf->l34m.daddr4;\n",
        "    bpf_skb_store_bytes (md, udp_csum_off, &csum, sizeof (csum), 0);\n",
        "    bpf_l3_csum_replace (md, ip_csum_off, old_dip, xip, sizeof (xip));\n",
        "    bpf_skb_store_bytes (md, ip_dst_off, &xip, sizeof (xip), 0);\n",
        "    xf->l34m.daddr4 = xip;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_set_udp_sport": [
    {
      "capabilities": [
        {
          "capability": "update_pkt",
          "update_pkt": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Store <[ len ]>(IP: 3) bytes <[ from ]>(IP: 2) address <[ from ]>(IP: 2) into the packet associated to <[ skb ]>(IP: 0) , at offset. <[ flags ]>(IP: 4) are a combination of BPF_F_RECOMPUTE_CSUM (automatically recompute the checksum for the packet after storing the bytes) and BPF_F_INVALIDATE_HASH (set skb->hash , skb->swhash and skb->l4hash to 0). A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_skb_store_bytes",
              "Input Params": [
                "{Type: struct sk_buff ,Var: *skb}",
                "{Type:  u32 ,Var: offset}",
                "{Type:  const void ,Var: *from}",
                "{Type:  u32 ,Var: len}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "lwt_xmit",
                "sk_skb"
              ],
              "capabilities": [
                "update_pkt"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1022,
      "endLine": 1035,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_set_udp_sport",
      "developer_inline_comments": [
        {
          "start_line": 1029,
          "end_line": 1029,
          "text": " UDP checksum = 0 is valid "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *md",
        " struct xfi *xf",
        " __be16 xport"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_skb_store_bytes"
      ],
      "compatibleHookpoints": [
        "lwt_xmit",
        "sched_cls",
        "sk_skb",
        "sched_act"
      ],
      "source": [
        "static int __always_inline dp_set_udp_sport (void *md, struct xfi *xf, __be16 xport)\n",
        "{\n",
        "    int udp_csum_off = xf->pm.l4_off + offsetof (struct udphdr, check);\n",
        "    int udp_sport_off = xf->pm.l4_off + offsetof (struct udphdr, source);\n",
        "    __be16 csum = 0;\n",
        "    bpf_skb_store_bytes (md, udp_csum_off, &csum, sizeof (csum), 0);\n",
        "    bpf_skb_store_bytes (md, udp_sport_off, &xport, sizeof (xport), 0);\n",
        "    xf->l34m.source = xport;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_set_udp_dport": [
    {
      "capabilities": [
        {
          "capability": "update_pkt",
          "update_pkt": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Store <[ len ]>(IP: 3) bytes <[ from ]>(IP: 2) address <[ from ]>(IP: 2) into the packet associated to <[ skb ]>(IP: 0) , at offset. <[ flags ]>(IP: 4) are a combination of BPF_F_RECOMPUTE_CSUM (automatically recompute the checksum for the packet after storing the bytes) and BPF_F_INVALIDATE_HASH (set skb->hash , skb->swhash and skb->l4hash to 0). A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_skb_store_bytes",
              "Input Params": [
                "{Type: struct sk_buff ,Var: *skb}",
                "{Type:  u32 ,Var: offset}",
                "{Type:  const void ,Var: *from}",
                "{Type:  u32 ,Var: len}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "lwt_xmit",
                "sk_skb"
              ],
              "capabilities": [
                "update_pkt"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1037,
      "endLine": 1050,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_set_udp_dport",
      "developer_inline_comments": [
        {
          "start_line": 1044,
          "end_line": 1044,
          "text": " UDP checksum = 0 is valid "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *md",
        " struct xfi *xf",
        " __be16 xport"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_skb_store_bytes"
      ],
      "compatibleHookpoints": [
        "lwt_xmit",
        "sched_cls",
        "sk_skb",
        "sched_act"
      ],
      "source": [
        "static int __always_inline dp_set_udp_dport (void *md, struct xfi *xf, __be16 xport)\n",
        "{\n",
        "    int udp_csum_off = xf->pm.l4_off + offsetof (struct udphdr, check);\n",
        "    int udp_dport_off = xf->pm.l4_off + offsetof (struct udphdr, dest);\n",
        "    __be16 csum = 0;\n",
        "    bpf_skb_store_bytes (md, udp_csum_off, &csum, sizeof (csum), 0);\n",
        "    bpf_skb_store_bytes (md, udp_dport_off, &xport, sizeof (xport), 0);\n",
        "    xf->l34m.dest = xport;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_set_icmp_src_ip6": [
    {
      "capabilities": [
        {
          "capability": "update_pkt",
          "update_pkt": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Store <[ len ]>(IP: 3) bytes <[ from ]>(IP: 2) address <[ from ]>(IP: 2) into the packet associated to <[ skb ]>(IP: 0) , at offset. <[ flags ]>(IP: 4) are a combination of BPF_F_RECOMPUTE_CSUM (automatically recompute the checksum for the packet after storing the bytes) and BPF_F_INVALIDATE_HASH (set skb->hash , skb->swhash and skb->l4hash to 0). A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_skb_store_bytes",
              "Input Params": [
                "{Type: struct sk_buff ,Var: *skb}",
                "{Type:  u32 ,Var: offset}",
                "{Type:  const void ,Var: *from}",
                "{Type:  u32 ,Var: len}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "lwt_xmit",
                "sk_skb"
              ],
              "capabilities": [
                "update_pkt"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1052,
      "endLine": 1061,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_set_icmp_src_ip6",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *md",
        " struct xfi *xf",
        " __be32 *xip"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_skb_store_bytes"
      ],
      "compatibleHookpoints": [
        "lwt_xmit",
        "sched_cls",
        "sk_skb",
        "sched_act"
      ],
      "source": [
        "static int __always_inline dp_set_icmp_src_ip6 (void *md, struct xfi *xf, __be32 *xip)\n",
        "{\n",
        "    int ip_src_off = xf->pm.l3_off + offsetof (struct ipv6hdr, saddr);\n",
        "    bpf_skb_store_bytes (md, ip_src_off, xip, sizeof (struct in6_addr), 0);\n",
        "    DP_XADDR_CP (xf->l34m.saddr, xip);\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_set_icmp_src_ip": [
    {
      "capabilities": [
        {
          "capability": "update_pkt",
          "update_pkt": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Recompute the layer 3 (e. g. IP) checksum for the packet associated <[ to ]>(IP: 3) skb. Computation is incremental , so the helper must know the former value of the header field that was modified (from) , the new value of this field (to) , and the number of bytes (2 or 4) for this field , stored in size. Alternatively , it is possible <[ to ]>(IP: 3) store the difference between the previous and the new values of the header field in <[ to ]>(IP: 3) , by setting <[ from ]>(IP: 2) and <[ size ]>(IP: 4) <[ to ]>(IP: 3) 0. For both methods , <[ offset ]>(IP: 1) indicates the location of the IP checksum within the packet. This helper works in combination with bpf_csum_diff() , which does not update the checksum in-place , but offers more flexibility and can handle sizes larger than 2 or 4 for the checksum <[ to ]>(IP: 3) update. A call <[ to ]>(IP: 3) this helper is susceptible <[ to ]>(IP: 3) change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_l3_csum_replace",
              "Input Params": [
                "{Type: struct sk_buff ,Var: *skb}",
                "{Type:  u32 ,Var: offset}",
                "{Type:  u64 ,Var: from}",
                "{Type:  u64 ,Var: to}",
                "{Type:  u64 ,Var: size}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "lwt_xmit"
              ],
              "capabilities": [
                "update_pkt"
              ]
            },
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Store <[ len ]>(IP: 3) bytes <[ from ]>(IP: 2) address <[ from ]>(IP: 2) into the packet associated to <[ skb ]>(IP: 0) , at offset. <[ flags ]>(IP: 4) are a combination of BPF_F_RECOMPUTE_CSUM (automatically recompute the checksum for the packet after storing the bytes) and BPF_F_INVALIDATE_HASH (set skb->hash , skb->swhash and skb->l4hash to 0). A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_skb_store_bytes",
              "Input Params": [
                "{Type: struct sk_buff ,Var: *skb}",
                "{Type:  u32 ,Var: offset}",
                "{Type:  const void ,Var: *from}",
                "{Type:  u32 ,Var: len}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "lwt_xmit",
                "sk_skb"
              ],
              "capabilities": [
                "update_pkt"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1063,
      "endLine": 1075,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_set_icmp_src_ip",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *md",
        " struct xfi *xf",
        " __be32 xip"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_l3_csum_replace",
        "bpf_skb_store_bytes"
      ],
      "compatibleHookpoints": [
        "lwt_xmit",
        "sched_cls",
        "sched_act"
      ],
      "source": [
        "static int __always_inline dp_set_icmp_src_ip (void *md, struct xfi *xf, __be32 xip)\n",
        "{\n",
        "    int ip_csum_off = xf->pm.l3_off + offsetof (struct iphdr, check);\n",
        "    int ip_src_off = xf->pm.l3_off + offsetof (struct iphdr, saddr);\n",
        "    __be32 old_sip = xf->l34m.saddr4;\n",
        "    bpf_l3_csum_replace (md, ip_csum_off, old_sip, xip, sizeof (xip));\n",
        "    bpf_skb_store_bytes (md, ip_src_off, &xip, sizeof (xip), 0);\n",
        "    xf->l34m.saddr4 = xip;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_set_icmp_dst_ip6": [
    {
      "capabilities": [
        {
          "capability": "update_pkt",
          "update_pkt": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Store <[ len ]>(IP: 3) bytes <[ from ]>(IP: 2) address <[ from ]>(IP: 2) into the packet associated to <[ skb ]>(IP: 0) , at offset. <[ flags ]>(IP: 4) are a combination of BPF_F_RECOMPUTE_CSUM (automatically recompute the checksum for the packet after storing the bytes) and BPF_F_INVALIDATE_HASH (set skb->hash , skb->swhash and skb->l4hash to 0). A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_skb_store_bytes",
              "Input Params": [
                "{Type: struct sk_buff ,Var: *skb}",
                "{Type:  u32 ,Var: offset}",
                "{Type:  const void ,Var: *from}",
                "{Type:  u32 ,Var: len}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "lwt_xmit",
                "sk_skb"
              ],
              "capabilities": [
                "update_pkt"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1077,
      "endLine": 1086,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_set_icmp_dst_ip6",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *md",
        " struct xfi *xf",
        " __be32 *xip"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_skb_store_bytes"
      ],
      "compatibleHookpoints": [
        "lwt_xmit",
        "sched_cls",
        "sk_skb",
        "sched_act"
      ],
      "source": [
        "static int __always_inline dp_set_icmp_dst_ip6 (void *md, struct xfi *xf, __be32 *xip)\n",
        "{\n",
        "    int ip_dst_off = xf->pm.l3_off + offsetof (struct ipv6hdr, daddr);\n",
        "    bpf_skb_store_bytes (md, ip_dst_off, xip, sizeof (struct in6_addr), 0);\n",
        "    DP_XADDR_CP (xf->l34m.daddr, xip);\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_set_icmp_dst_ip": [
    {
      "capabilities": [
        {
          "capability": "update_pkt",
          "update_pkt": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Recompute the layer 3 (e. g. IP) checksum for the packet associated <[ to ]>(IP: 3) skb. Computation is incremental , so the helper must know the former value of the header field that was modified (from) , the new value of this field (to) , and the number of bytes (2 or 4) for this field , stored in size. Alternatively , it is possible <[ to ]>(IP: 3) store the difference between the previous and the new values of the header field in <[ to ]>(IP: 3) , by setting <[ from ]>(IP: 2) and <[ size ]>(IP: 4) <[ to ]>(IP: 3) 0. For both methods , <[ offset ]>(IP: 1) indicates the location of the IP checksum within the packet. This helper works in combination with bpf_csum_diff() , which does not update the checksum in-place , but offers more flexibility and can handle sizes larger than 2 or 4 for the checksum <[ to ]>(IP: 3) update. A call <[ to ]>(IP: 3) this helper is susceptible <[ to ]>(IP: 3) change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_l3_csum_replace",
              "Input Params": [
                "{Type: struct sk_buff ,Var: *skb}",
                "{Type:  u32 ,Var: offset}",
                "{Type:  u64 ,Var: from}",
                "{Type:  u64 ,Var: to}",
                "{Type:  u64 ,Var: size}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "lwt_xmit"
              ],
              "capabilities": [
                "update_pkt"
              ]
            },
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Store <[ len ]>(IP: 3) bytes <[ from ]>(IP: 2) address <[ from ]>(IP: 2) into the packet associated to <[ skb ]>(IP: 0) , at offset. <[ flags ]>(IP: 4) are a combination of BPF_F_RECOMPUTE_CSUM (automatically recompute the checksum for the packet after storing the bytes) and BPF_F_INVALIDATE_HASH (set skb->hash , skb->swhash and skb->l4hash to 0). A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_skb_store_bytes",
              "Input Params": [
                "{Type: struct sk_buff ,Var: *skb}",
                "{Type:  u32 ,Var: offset}",
                "{Type:  const void ,Var: *from}",
                "{Type:  u32 ,Var: len}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "lwt_xmit",
                "sk_skb"
              ],
              "capabilities": [
                "update_pkt"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1088,
      "endLine": 1100,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_set_icmp_dst_ip",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *md",
        " struct xfi *xf",
        " __be32 xip"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_l3_csum_replace",
        "bpf_skb_store_bytes"
      ],
      "compatibleHookpoints": [
        "lwt_xmit",
        "sched_cls",
        "sched_act"
      ],
      "source": [
        "static int __always_inline dp_set_icmp_dst_ip (void *md, struct xfi *xf, __be32 xip)\n",
        "{\n",
        "    int ip_csum_off = xf->pm.l3_off + offsetof (struct iphdr, check);\n",
        "    int ip_dst_off = xf->pm.l3_off + offsetof (struct iphdr, daddr);\n",
        "    __be32 old_dip = xf->l34m.daddr4;\n",
        "    bpf_l3_csum_replace (md, ip_csum_off, old_dip, xip, sizeof (xip));\n",
        "    bpf_skb_store_bytes (md, ip_dst_off, &xip, sizeof (xip), 0);\n",
        "    xf->l34m.daddr4 = xip;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_set_sctp_src_ip6": [
    {
      "capabilities": [
        {
          "capability": "update_pkt",
          "update_pkt": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Store <[ len ]>(IP: 3) bytes <[ from ]>(IP: 2) address <[ from ]>(IP: 2) into the packet associated to <[ skb ]>(IP: 0) , at offset. <[ flags ]>(IP: 4) are a combination of BPF_F_RECOMPUTE_CSUM (automatically recompute the checksum for the packet after storing the bytes) and BPF_F_INVALIDATE_HASH (set skb->hash , skb->swhash and skb->l4hash to 0). A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_skb_store_bytes",
              "Input Params": [
                "{Type: struct sk_buff ,Var: *skb}",
                "{Type:  u32 ,Var: offset}",
                "{Type:  const void ,Var: *from}",
                "{Type:  u32 ,Var: len}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "lwt_xmit",
                "sk_skb"
              ],
              "capabilities": [
                "update_pkt"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1102,
      "endLine": 1111,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_set_sctp_src_ip6",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *md",
        " struct xfi *xf",
        " __be32 *xip"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_skb_store_bytes"
      ],
      "compatibleHookpoints": [
        "lwt_xmit",
        "sched_cls",
        "sk_skb",
        "sched_act"
      ],
      "source": [
        "static int __always_inline dp_set_sctp_src_ip6 (void *md, struct xfi *xf, __be32 *xip)\n",
        "{\n",
        "    int ip_src_off = xf->pm.l3_off + offsetof (struct ipv6hdr, saddr);\n",
        "    bpf_skb_store_bytes (md, ip_src_off, xip, sizeof (struct in6_addr), 0);\n",
        "    DP_XADDR_CP (xf->l34m.saddr, xip);\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_set_sctp_src_ip": [
    {
      "capabilities": [
        {
          "capability": "update_pkt",
          "update_pkt": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Recompute the layer 3 (e. g. IP) checksum for the packet associated <[ to ]>(IP: 3) skb. Computation is incremental , so the helper must know the former value of the header field that was modified (from) , the new value of this field (to) , and the number of bytes (2 or 4) for this field , stored in size. Alternatively , it is possible <[ to ]>(IP: 3) store the difference between the previous and the new values of the header field in <[ to ]>(IP: 3) , by setting <[ from ]>(IP: 2) and <[ size ]>(IP: 4) <[ to ]>(IP: 3) 0. For both methods , <[ offset ]>(IP: 1) indicates the location of the IP checksum within the packet. This helper works in combination with bpf_csum_diff() , which does not update the checksum in-place , but offers more flexibility and can handle sizes larger than 2 or 4 for the checksum <[ to ]>(IP: 3) update. A call <[ to ]>(IP: 3) this helper is susceptible <[ to ]>(IP: 3) change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_l3_csum_replace",
              "Input Params": [
                "{Type: struct sk_buff ,Var: *skb}",
                "{Type:  u32 ,Var: offset}",
                "{Type:  u64 ,Var: from}",
                "{Type:  u64 ,Var: to}",
                "{Type:  u64 ,Var: size}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "lwt_xmit"
              ],
              "capabilities": [
                "update_pkt"
              ]
            },
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Store <[ len ]>(IP: 3) bytes <[ from ]>(IP: 2) address <[ from ]>(IP: 2) into the packet associated to <[ skb ]>(IP: 0) , at offset. <[ flags ]>(IP: 4) are a combination of BPF_F_RECOMPUTE_CSUM (automatically recompute the checksum for the packet after storing the bytes) and BPF_F_INVALIDATE_HASH (set skb->hash , skb->swhash and skb->l4hash to 0). A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_skb_store_bytes",
              "Input Params": [
                "{Type: struct sk_buff ,Var: *skb}",
                "{Type:  u32 ,Var: offset}",
                "{Type:  const void ,Var: *from}",
                "{Type:  u32 ,Var: len}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "lwt_xmit",
                "sk_skb"
              ],
              "capabilities": [
                "update_pkt"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1113,
      "endLine": 1125,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_set_sctp_src_ip",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *md",
        " struct xfi *xf",
        " __be32 xip"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_l3_csum_replace",
        "bpf_skb_store_bytes"
      ],
      "compatibleHookpoints": [
        "lwt_xmit",
        "sched_cls",
        "sched_act"
      ],
      "source": [
        "static int __always_inline dp_set_sctp_src_ip (void *md, struct xfi *xf, __be32 xip)\n",
        "{\n",
        "    int ip_csum_off = xf->pm.l3_off + offsetof (struct iphdr, check);\n",
        "    int ip_src_off = xf->pm.l3_off + offsetof (struct iphdr, saddr);\n",
        "    __be32 old_sip = xf->l34m.saddr4;\n",
        "    bpf_l3_csum_replace (md, ip_csum_off, old_sip, xip, sizeof (xip));\n",
        "    bpf_skb_store_bytes (md, ip_src_off, &xip, sizeof (xip), 0);\n",
        "    xf->l34m.saddr4 = xip;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_set_sctp_dst_ip6": [
    {
      "capabilities": [
        {
          "capability": "update_pkt",
          "update_pkt": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Store <[ len ]>(IP: 3) bytes <[ from ]>(IP: 2) address <[ from ]>(IP: 2) into the packet associated to <[ skb ]>(IP: 0) , at offset. <[ flags ]>(IP: 4) are a combination of BPF_F_RECOMPUTE_CSUM (automatically recompute the checksum for the packet after storing the bytes) and BPF_F_INVALIDATE_HASH (set skb->hash , skb->swhash and skb->l4hash to 0). A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_skb_store_bytes",
              "Input Params": [
                "{Type: struct sk_buff ,Var: *skb}",
                "{Type:  u32 ,Var: offset}",
                "{Type:  const void ,Var: *from}",
                "{Type:  u32 ,Var: len}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "lwt_xmit",
                "sk_skb"
              ],
              "capabilities": [
                "update_pkt"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1127,
      "endLine": 1136,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_set_sctp_dst_ip6",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *md",
        " struct xfi *xf",
        " __be32 *xip"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_skb_store_bytes"
      ],
      "compatibleHookpoints": [
        "lwt_xmit",
        "sched_cls",
        "sk_skb",
        "sched_act"
      ],
      "source": [
        "static int __always_inline dp_set_sctp_dst_ip6 (void *md, struct xfi *xf, __be32 *xip)\n",
        "{\n",
        "    int ip_dst_off = xf->pm.l3_off + offsetof (struct ipv6hdr, daddr);\n",
        "    bpf_skb_store_bytes (md, ip_dst_off, xip, sizeof (struct in6_addr), 0);\n",
        "    DP_XADDR_CP (xf->l34m.daddr, xip);\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_set_sctp_dst_ip": [
    {
      "capabilities": [
        {
          "capability": "update_pkt",
          "update_pkt": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Recompute the layer 3 (e. g. IP) checksum for the packet associated <[ to ]>(IP: 3) skb. Computation is incremental , so the helper must know the former value of the header field that was modified (from) , the new value of this field (to) , and the number of bytes (2 or 4) for this field , stored in size. Alternatively , it is possible <[ to ]>(IP: 3) store the difference between the previous and the new values of the header field in <[ to ]>(IP: 3) , by setting <[ from ]>(IP: 2) and <[ size ]>(IP: 4) <[ to ]>(IP: 3) 0. For both methods , <[ offset ]>(IP: 1) indicates the location of the IP checksum within the packet. This helper works in combination with bpf_csum_diff() , which does not update the checksum in-place , but offers more flexibility and can handle sizes larger than 2 or 4 for the checksum <[ to ]>(IP: 3) update. A call <[ to ]>(IP: 3) this helper is susceptible <[ to ]>(IP: 3) change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_l3_csum_replace",
              "Input Params": [
                "{Type: struct sk_buff ,Var: *skb}",
                "{Type:  u32 ,Var: offset}",
                "{Type:  u64 ,Var: from}",
                "{Type:  u64 ,Var: to}",
                "{Type:  u64 ,Var: size}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "lwt_xmit"
              ],
              "capabilities": [
                "update_pkt"
              ]
            },
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Store <[ len ]>(IP: 3) bytes <[ from ]>(IP: 2) address <[ from ]>(IP: 2) into the packet associated to <[ skb ]>(IP: 0) , at offset. <[ flags ]>(IP: 4) are a combination of BPF_F_RECOMPUTE_CSUM (automatically recompute the checksum for the packet after storing the bytes) and BPF_F_INVALIDATE_HASH (set skb->hash , skb->swhash and skb->l4hash to 0). A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_skb_store_bytes",
              "Input Params": [
                "{Type: struct sk_buff ,Var: *skb}",
                "{Type:  u32 ,Var: offset}",
                "{Type:  const void ,Var: *from}",
                "{Type:  u32 ,Var: len}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "lwt_xmit",
                "sk_skb"
              ],
              "capabilities": [
                "update_pkt"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1138,
      "endLine": 1150,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_set_sctp_dst_ip",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *md",
        " struct xfi *xf",
        " __be32 xip"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_l3_csum_replace",
        "bpf_skb_store_bytes"
      ],
      "compatibleHookpoints": [
        "lwt_xmit",
        "sched_cls",
        "sched_act"
      ],
      "source": [
        "static int __always_inline dp_set_sctp_dst_ip (void *md, struct xfi *xf, __be32 xip)\n",
        "{\n",
        "    int ip_csum_off = xf->pm.l3_off + offsetof (struct iphdr, check);\n",
        "    int ip_dst_off = xf->pm.l3_off + offsetof (struct iphdr, daddr);\n",
        "    __be32 old_dip = xf->l34m.daddr4;\n",
        "    bpf_l3_csum_replace (md, ip_csum_off, old_dip, xip, sizeof (xip));\n",
        "    bpf_skb_store_bytes (md, ip_dst_off, &xip, sizeof (xip), 0);\n",
        "    xf->l34m.daddr4 = xip;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_set_sctp_sport": [
    {
      "capabilities": [
        {
          "capability": "update_pkt",
          "update_pkt": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Store <[ len ]>(IP: 3) bytes <[ from ]>(IP: 2) address <[ from ]>(IP: 2) into the packet associated to <[ skb ]>(IP: 0) , at offset. <[ flags ]>(IP: 4) are a combination of BPF_F_RECOMPUTE_CSUM (automatically recompute the checksum for the packet after storing the bytes) and BPF_F_INVALIDATE_HASH (set skb->hash , skb->swhash and skb->l4hash to 0). A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_skb_store_bytes",
              "Input Params": [
                "{Type: struct sk_buff ,Var: *skb}",
                "{Type:  u32 ,Var: offset}",
                "{Type:  const void ,Var: *from}",
                "{Type:  u32 ,Var: len}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "lwt_xmit",
                "sk_skb"
              ],
              "capabilities": [
                "update_pkt"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1152,
      "endLine": 1164,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_set_sctp_sport",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *md",
        " struct xfi *xf",
        " __be16 xport"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_skb_store_bytes"
      ],
      "compatibleHookpoints": [
        "lwt_xmit",
        "sched_cls",
        "sk_skb",
        "sched_act"
      ],
      "source": [
        "static int __always_inline dp_set_sctp_sport (void *md, struct xfi *xf, __be16 xport)\n",
        "{\n",
        "    uint32_t csum = 0;\n",
        "    int sctp_csum_off = xf->pm.l4_off + offsetof (struct sctphdr, checksum);\n",
        "    int sctp_sport_off = xf->pm.l4_off + offsetof (struct sctphdr, source);\n",
        "    bpf_skb_store_bytes (md, sctp_csum_off, &csum, sizeof (csum), 0);\n",
        "    bpf_skb_store_bytes (md, sctp_sport_off, &xport, sizeof (xport), 0);\n",
        "    xf->l34m.source = xport;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_set_sctp_dport": [
    {
      "capabilities": [
        {
          "capability": "update_pkt",
          "update_pkt": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Store <[ len ]>(IP: 3) bytes <[ from ]>(IP: 2) address <[ from ]>(IP: 2) into the packet associated to <[ skb ]>(IP: 0) , at offset. <[ flags ]>(IP: 4) are a combination of BPF_F_RECOMPUTE_CSUM (automatically recompute the checksum for the packet after storing the bytes) and BPF_F_INVALIDATE_HASH (set skb->hash , skb->swhash and skb->l4hash to 0). A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_skb_store_bytes",
              "Input Params": [
                "{Type: struct sk_buff ,Var: *skb}",
                "{Type:  u32 ,Var: offset}",
                "{Type:  const void ,Var: *from}",
                "{Type:  u32 ,Var: len}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "lwt_xmit",
                "sk_skb"
              ],
              "capabilities": [
                "update_pkt"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1166,
      "endLine": 1178,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_set_sctp_dport",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *md",
        " struct xfi *xf",
        " __be16 xport"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_skb_store_bytes"
      ],
      "compatibleHookpoints": [
        "lwt_xmit",
        "sched_cls",
        "sk_skb",
        "sched_act"
      ],
      "source": [
        "static int __always_inline dp_set_sctp_dport (void *md, struct xfi *xf, __be16 xport)\n",
        "{\n",
        "    uint32_t csum = 0;\n",
        "    int sctp_csum_off = xf->pm.l4_off + offsetof (struct sctphdr, checksum);\n",
        "    int sctp_dport_off = xf->pm.l4_off + offsetof (struct sctphdr, dest);\n",
        "    bpf_skb_store_bytes (md, sctp_csum_off, &csum, sizeof (csum), 0);\n",
        "    bpf_skb_store_bytes (md, sctp_dport_off, &xport, sizeof (xport), 0);\n",
        "    xf->l34m.dest = xport;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_do_dnat": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1180,
      "endLine": 1255,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_do_dnat",
      "developer_inline_comments": [
        {
          "start_line": 1193,
          "end_line": 1193,
          "text": " Hairpin nat to host "
        },
        {
          "start_line": 1213,
          "end_line": 1213,
          "text": " Hairpin nat to host "
        },
        {
          "start_line": 1233,
          "end_line": 1233,
          "text": " Hairpin nat to host "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf",
        " __be32 xip",
        " __be16 xport"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_do_dnat (void *ctx, struct xfi *xf, __be32 xip, __be16 xport)\n",
        "{\n",
        "    void *dend = DP_TC_PTR (DP_PDATA_END (ctx));\n",
        "    if (xf->l34m.nw_proto == IPPROTO_TCP) {\n",
        "        struct tcphdr *tcp = DP_ADD_PTR (DP_PDATA (ctx), xf->pm.l4_off);\n",
        "        if (tcp + 1 > dend) {\n",
        "            LLBS_PPLN_DROP (xf);\n",
        "            return -1;\n",
        "        }\n",
        "        if (xip == 0) {\n",
        "            xip = xf->l34m.saddr4;\n",
        "            dp_set_tcp_src_ip (ctx, xf, xf->l34m.daddr4);\n",
        "            dp_set_tcp_dst_ip (ctx, xf, xip);\n",
        "        }\n",
        "        else {\n",
        "            if (xf->nm.nrip4) {\n",
        "                dp_set_tcp_src_ip (ctx, xf, xf->nm.nrip4);\n",
        "            }\n",
        "            dp_set_tcp_dst_ip (ctx, xf, xip);\n",
        "        }\n",
        "        dp_set_tcp_dport (ctx, xf, xport);\n",
        "    }\n",
        "    else if (xf->l34m.nw_proto == IPPROTO_UDP) {\n",
        "        struct udphdr *udp = DP_ADD_PTR (DP_PDATA (ctx), xf->pm.l4_off);\n",
        "        if (udp + 1 > dend) {\n",
        "            LLBS_PPLN_DROP (xf);\n",
        "            return -1;\n",
        "        }\n",
        "        if (xip == 0) {\n",
        "            xip = xf->l34m.saddr4;\n",
        "            dp_set_udp_src_ip (ctx, xf, xf->l34m.daddr4);\n",
        "            dp_set_udp_dst_ip (ctx, xf, xip);\n",
        "        }\n",
        "        else {\n",
        "            if (xf->nm.nrip4) {\n",
        "                dp_set_udp_src_ip (ctx, xf, xf->nm.nrip4);\n",
        "            }\n",
        "            dp_set_udp_dst_ip (ctx, xf, xip);\n",
        "        }\n",
        "        dp_set_udp_dport (ctx, xf, xport);\n",
        "    }\n",
        "    else if (xf->l34m.nw_proto == IPPROTO_SCTP) {\n",
        "        struct sctphdr *sctp = DP_ADD_PTR (DP_PDATA (ctx), xf->pm.l4_off);\n",
        "        if (sctp + 1 > dend) {\n",
        "            LLBS_PPLN_DROP (xf);\n",
        "            return -1;\n",
        "        }\n",
        "        if (xip == 0) {\n",
        "            xip = xf->l34m.saddr4;\n",
        "            dp_set_sctp_src_ip (ctx, xf, xf->l34m.daddr4);\n",
        "            dp_set_sctp_dst_ip (ctx, xf, xip);\n",
        "        }\n",
        "        else {\n",
        "            if (xf->nm.nrip4) {\n",
        "                dp_set_sctp_src_ip (ctx, xf, xf->nm.nrip4);\n",
        "            }\n",
        "            dp_set_sctp_dst_ip (ctx, xf, xip);\n",
        "        }\n",
        "        dp_set_sctp_dport (ctx, xf, xport);\n",
        "\n",
        "#ifdef HAVE_DP_SCTP_SUM\n",
        "        dp_csum_tcall (ctx, xf);\n",
        "\n",
        "#endif\n",
        "    }\n",
        "    else if (xf->l34m.nw_proto == IPPROTO_ICMP) {\n",
        "        if (xf->nm.nrip4) {\n",
        "            dp_set_icmp_src_ip (ctx, xf, xf->nm.nrip4);\n",
        "        }\n",
        "        dp_set_icmp_dst_ip (ctx, xf, xip);\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_set_sctp_dst_ip",
        "dp_set_udp_src_ip",
        "dp_set_icmp_dst_ip",
        "dp_set_tcp_dport",
        "dp_set_sctp_src_ip",
        "dp_set_icmp_src_ip",
        "dp_set_tcp_src_ip",
        "dp_csum_tcall",
        "dp_set_udp_dst_ip",
        "dp_set_sctp_dport",
        "dp_set_tcp_dst_ip",
        "dp_set_udp_dport"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1877,
      "endLine": 1882,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_do_dnat",
      "developer_inline_comments": [
        {
          "start_line": 1880,
          "end_line": 1880,
          "text": " FIXME - TBD "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf",
        " __be32 xip",
        " __be16 xport"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_do_dnat (void *ctx, struct xfi *xf, __be32 xip, __be16 xport)\n",
        "{\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_set_sctp_dst_ip",
        "dp_set_udp_src_ip",
        "dp_set_icmp_dst_ip",
        "dp_set_tcp_dport",
        "dp_set_sctp_src_ip",
        "dp_set_icmp_src_ip",
        "dp_set_tcp_src_ip",
        "dp_csum_tcall",
        "dp_set_udp_dst_ip",
        "dp_set_sctp_dport",
        "dp_set_tcp_dst_ip",
        "dp_set_udp_dport"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_do_dnat6": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1257,
      "endLine": 1332,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_do_dnat6",
      "developer_inline_comments": [
        {
          "start_line": 1270,
          "end_line": 1270,
          "text": " Hairpin nat to host "
        },
        {
          "start_line": 1290,
          "end_line": 1290,
          "text": " Hairpin nat to host "
        },
        {
          "start_line": 1310,
          "end_line": 1310,
          "text": " Hairpin nat to host "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf",
        " __be32 *xip",
        " __be16 xport"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_do_dnat6 (void *ctx, struct xfi *xf, __be32 *xip, __be16 xport)\n",
        "{\n",
        "    void *dend = DP_TC_PTR (DP_PDATA_END (ctx));\n",
        "    if (xf->l34m.nw_proto == IPPROTO_TCP) {\n",
        "        struct tcphdr *tcp = DP_ADD_PTR (DP_PDATA (ctx), xf->pm.l4_off);\n",
        "        if (tcp + 1 > dend) {\n",
        "            LLBS_PPLN_DROP (xf);\n",
        "            return -1;\n",
        "        }\n",
        "        if (DP_XADDR_ISZR (xip)) {\n",
        "            DP_XADDR_CP (xip, xf->l34m.saddr);\n",
        "            dp_set_tcp_src_ip6 (ctx, xf, xf->l34m.daddr);\n",
        "            dp_set_tcp_dst_ip6 (ctx, xf, xip);\n",
        "        }\n",
        "        else {\n",
        "            if (!DP_XADDR_ISZR(xf->nm.nrip)) {\n",
        "                dp_set_tcp_src_ip6 (ctx, xf, xf->nm.nrip);\n",
        "            }\n",
        "            dp_set_tcp_dst_ip6 (ctx, xf, xip);\n",
        "        }\n",
        "        dp_set_tcp_dport (ctx, xf, xport);\n",
        "    }\n",
        "    else if (xf->l34m.nw_proto == IPPROTO_UDP) {\n",
        "        struct udphdr *udp = DP_ADD_PTR (DP_PDATA (ctx), xf->pm.l4_off);\n",
        "        if (udp + 1 > dend) {\n",
        "            LLBS_PPLN_DROP (xf);\n",
        "            return -1;\n",
        "        }\n",
        "        if (DP_XADDR_ISZR (xip)) {\n",
        "            DP_XADDR_CP (xip, xf->l34m.saddr);\n",
        "            dp_set_udp_src_ip6 (ctx, xf, xf->l34m.daddr);\n",
        "            dp_set_udp_dst_ip6 (ctx, xf, xip);\n",
        "        }\n",
        "        else {\n",
        "            if (!DP_XADDR_ISZR(xf->nm.nrip)) {\n",
        "                dp_set_udp_src_ip6 (ctx, xf, xf->nm.nrip);\n",
        "            }\n",
        "            dp_set_udp_dst_ip6 (ctx, xf, xip);\n",
        "        }\n",
        "        dp_set_udp_dport (ctx, xf, xport);\n",
        "    }\n",
        "    else if (xf->l34m.nw_proto == IPPROTO_SCTP) {\n",
        "        struct sctphdr *sctp = DP_ADD_PTR (DP_PDATA (ctx), xf->pm.l4_off);\n",
        "        if (sctp + 1 > dend) {\n",
        "            LLBS_PPLN_DROP (xf);\n",
        "            return -1;\n",
        "        }\n",
        "        if (DP_XADDR_ISZR (xip)) {\n",
        "            DP_XADDR_CP (xip, xf->l34m.saddr);\n",
        "            dp_set_sctp_src_ip6 (ctx, xf, xf->l34m.daddr);\n",
        "            dp_set_sctp_dst_ip6 (ctx, xf, xip);\n",
        "        }\n",
        "        else {\n",
        "            if (!DP_XADDR_ISZR(xf->nm.nrip)) {\n",
        "                dp_set_sctp_src_ip6 (ctx, xf, xf->nm.nrip);\n",
        "            }\n",
        "            dp_set_sctp_dst_ip6 (ctx, xf, xip);\n",
        "        }\n",
        "        dp_set_sctp_dport (ctx, xf, xport);\n",
        "\n",
        "#ifdef HAVE_DP_SCTP_SUM\n",
        "        dp_csum_tcall (ctx, xf);\n",
        "\n",
        "#endif\n",
        "    }\n",
        "    else if (xf->l34m.nw_proto == IPPROTO_ICMP) {\n",
        "        if (!DP_XADDR_ISZR(xf->nm.nrip)) {\n",
        "            dp_set_icmp_src_ip6 (ctx, xf, xf->nm.nrip);\n",
        "        }\n",
        "        dp_set_icmp_dst_ip6 (ctx, xf, xip);\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_set_icmp_src_ip6",
        "dp_csum_tcall",
        "dp_set_udp_src_ip6",
        "dp_set_tcp_dport",
        "dp_set_udp_dport",
        "dp_set_sctp_dst_ip6",
        "dp_set_sctp_src_ip6",
        "dp_set_icmp_dst_ip6",
        "dp_set_sctp_dport",
        "dp_set_tcp_src_ip6",
        "dp_set_udp_dst_ip6",
        "dp_set_tcp_dst_ip6"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1884,
      "endLine": 1889,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_do_dnat6",
      "developer_inline_comments": [
        {
          "start_line": 1887,
          "end_line": 1887,
          "text": " FIXME - TBD "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf",
        " __be32 *xip",
        " __be16 xport"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_do_dnat6 (void *ctx, struct xfi *xf, __be32 *xip, __be16 xport)\n",
        "{\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_set_icmp_src_ip6",
        "dp_csum_tcall",
        "dp_set_udp_src_ip6",
        "dp_set_tcp_dport",
        "dp_set_udp_dport",
        "dp_set_sctp_dst_ip6",
        "dp_set_sctp_src_ip6",
        "dp_set_icmp_dst_ip6",
        "dp_set_sctp_dport",
        "dp_set_tcp_src_ip6",
        "dp_set_udp_dst_ip6",
        "dp_set_tcp_dst_ip6"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_do_snat": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1334,
      "endLine": 1409,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_do_snat",
      "developer_inline_comments": [
        {
          "start_line": 1347,
          "end_line": 1347,
          "text": " Hairpin nat to host "
        },
        {
          "start_line": 1367,
          "end_line": 1367,
          "text": " Hairpin nat to host "
        },
        {
          "start_line": 1387,
          "end_line": 1387,
          "text": " Hairpin nat to host "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf",
        " __be32 xip",
        " __be16 xport"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_do_snat (void *ctx, struct xfi *xf, __be32 xip, __be16 xport)\n",
        "{\n",
        "    void *dend = DP_TC_PTR (DP_PDATA_END (ctx));\n",
        "    if (xf->l34m.nw_proto == IPPROTO_TCP) {\n",
        "        struct tcphdr *tcp = DP_ADD_PTR (DP_PDATA (ctx), xf->pm.l4_off);\n",
        "        if (tcp + 1 > dend) {\n",
        "            LLBS_PPLN_DROP (xf);\n",
        "            return -1;\n",
        "        }\n",
        "        if (xip == 0) {\n",
        "            xip = xf->l34m.saddr4;\n",
        "            dp_set_tcp_src_ip (ctx, xf, xf->l34m.daddr4);\n",
        "            dp_set_tcp_dst_ip (ctx, xf, xip);\n",
        "        }\n",
        "        else {\n",
        "            dp_set_tcp_src_ip (ctx, xf, xip);\n",
        "            if (xf->nm.nrip4) {\n",
        "                dp_set_tcp_dst_ip (ctx, xf, xf->nm.nrip4);\n",
        "            }\n",
        "        }\n",
        "        dp_set_tcp_sport (ctx, xf, xport);\n",
        "    }\n",
        "    else if (xf->l34m.nw_proto == IPPROTO_UDP) {\n",
        "        struct udphdr *udp = DP_ADD_PTR (DP_PDATA (ctx), xf->pm.l4_off);\n",
        "        if (udp + 1 > dend) {\n",
        "            LLBS_PPLN_DROP (xf);\n",
        "            return -1;\n",
        "        }\n",
        "        if (xip == 0) {\n",
        "            xip = xf->l34m.saddr4;\n",
        "            dp_set_udp_src_ip (ctx, xf, xf->l34m.daddr4);\n",
        "            dp_set_udp_dst_ip (ctx, xf, xip);\n",
        "        }\n",
        "        else {\n",
        "            dp_set_udp_src_ip (ctx, xf, xip);\n",
        "            if (xf->nm.nrip4) {\n",
        "                dp_set_udp_dst_ip (ctx, xf, xf->nm.nrip4);\n",
        "            }\n",
        "        }\n",
        "        dp_set_udp_sport (ctx, xf, xport);\n",
        "    }\n",
        "    else if (xf->l34m.nw_proto == IPPROTO_SCTP) {\n",
        "        struct sctphdr *sctp = DP_ADD_PTR (DP_PDATA (ctx), xf->pm.l4_off);\n",
        "        if (sctp + 1 > dend) {\n",
        "            LLBS_PPLN_DROP (xf);\n",
        "            return -1;\n",
        "        }\n",
        "        if (xip == 0) {\n",
        "            xip = xf->l34m.saddr4;\n",
        "            dp_set_sctp_src_ip (ctx, xf, xf->l34m.daddr4);\n",
        "            dp_set_sctp_dst_ip (ctx, xf, xip);\n",
        "        }\n",
        "        else {\n",
        "            dp_set_sctp_src_ip (ctx, xf, xip);\n",
        "            if (xf->nm.nrip4) {\n",
        "                dp_set_sctp_dst_ip (ctx, xf, xf->nm.nrip4);\n",
        "            }\n",
        "        }\n",
        "        dp_set_sctp_sport (ctx, xf, xport);\n",
        "\n",
        "#ifdef HAVE_DP_SCTP_SUM\n",
        "        dp_csum_tcall (ctx, xf);\n",
        "\n",
        "#endif\n",
        "    }\n",
        "    else if (xf->l34m.nw_proto == IPPROTO_ICMP) {\n",
        "        dp_set_icmp_src_ip (ctx, xf, xip);\n",
        "        if (xf->nm.nrip4) {\n",
        "            dp_set_icmp_dst_ip (ctx, xf, xf->nm.nrip4);\n",
        "        }\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_set_sctp_dst_ip",
        "dp_set_udp_sport",
        "dp_set_udp_src_ip",
        "dp_set_icmp_dst_ip",
        "dp_set_sctp_src_ip",
        "dp_set_sctp_sport",
        "dp_set_icmp_src_ip",
        "dp_set_tcp_src_ip",
        "dp_csum_tcall",
        "dp_set_tcp_sport",
        "dp_set_tcp_dst_ip",
        "dp_set_udp_dst_ip"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1863,
      "endLine": 1868,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_do_snat",
      "developer_inline_comments": [
        {
          "start_line": 1866,
          "end_line": 1866,
          "text": " FIXME - TBD "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf",
        " __be32 xip",
        " __be16 xport"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_do_snat (void *ctx, struct xfi *xf, __be32 xip, __be16 xport)\n",
        "{\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_set_sctp_dst_ip",
        "dp_set_udp_sport",
        "dp_set_udp_src_ip",
        "dp_set_icmp_dst_ip",
        "dp_set_sctp_src_ip",
        "dp_set_sctp_sport",
        "dp_set_icmp_src_ip",
        "dp_set_tcp_src_ip",
        "dp_csum_tcall",
        "dp_set_tcp_sport",
        "dp_set_tcp_dst_ip",
        "dp_set_udp_dst_ip"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_do_snat6": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1411,
      "endLine": 1486,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_do_snat6",
      "developer_inline_comments": [
        {
          "start_line": 1424,
          "end_line": 1424,
          "text": " Hairpin nat to host "
        },
        {
          "start_line": 1444,
          "end_line": 1444,
          "text": " Hairpin nat to host "
        },
        {
          "start_line": 1464,
          "end_line": 1464,
          "text": " Hairpin nat to host "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf",
        " __be32 *xip",
        " __be16 xport"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_do_snat6 (void *ctx, struct xfi *xf, __be32 *xip, __be16 xport)\n",
        "{\n",
        "    void *dend = DP_TC_PTR (DP_PDATA_END (ctx));\n",
        "    if (xf->l34m.nw_proto == IPPROTO_TCP) {\n",
        "        struct tcphdr *tcp = DP_ADD_PTR (DP_PDATA (ctx), xf->pm.l4_off);\n",
        "        if (tcp + 1 > dend) {\n",
        "            LLBS_PPLN_DROP (xf);\n",
        "            return -1;\n",
        "        }\n",
        "        if (DP_XADDR_ISZR (xip)) {\n",
        "            DP_XADDR_CP (xip, xf->l34m.saddr);\n",
        "            dp_set_tcp_src_ip6 (ctx, xf, xf->l34m.daddr);\n",
        "            dp_set_tcp_dst_ip6 (ctx, xf, xip);\n",
        "        }\n",
        "        else {\n",
        "            dp_set_tcp_src_ip6 (ctx, xf, xip);\n",
        "            if (!DP_XADDR_ISZR(xf->nm.nrip)) {\n",
        "                dp_set_tcp_dst_ip6 (ctx, xf, xf->nm.nrip);\n",
        "            }\n",
        "        }\n",
        "        dp_set_tcp_sport (ctx, xf, xport);\n",
        "    }\n",
        "    else if (xf->l34m.nw_proto == IPPROTO_UDP) {\n",
        "        struct udphdr *udp = DP_ADD_PTR (DP_PDATA (ctx), xf->pm.l4_off);\n",
        "        if (udp + 1 > dend) {\n",
        "            LLBS_PPLN_DROP (xf);\n",
        "            return -1;\n",
        "        }\n",
        "        if (DP_XADDR_ISZR (xip)) {\n",
        "            DP_XADDR_CP (xip, xf->l34m.saddr);\n",
        "            dp_set_udp_src_ip6 (ctx, xf, xf->l34m.daddr);\n",
        "            dp_set_udp_dst_ip6 (ctx, xf, xip);\n",
        "        }\n",
        "        else {\n",
        "            dp_set_udp_src_ip6 (ctx, xf, xip);\n",
        "            if (!DP_XADDR_ISZR(xf->nm.nrip)) {\n",
        "                dp_set_udp_dst_ip6 (ctx, xf, xf->nm.nrip);\n",
        "            }\n",
        "        }\n",
        "        dp_set_udp_sport (ctx, xf, xport);\n",
        "    }\n",
        "    else if (xf->l34m.nw_proto == IPPROTO_SCTP) {\n",
        "        struct sctphdr *sctp = DP_ADD_PTR (DP_PDATA (ctx), xf->pm.l4_off);\n",
        "        if (sctp + 1 > dend) {\n",
        "            LLBS_PPLN_DROP (xf);\n",
        "            return -1;\n",
        "        }\n",
        "        if (DP_XADDR_ISZR (xip)) {\n",
        "            DP_XADDR_CP (xip, xf->l34m.saddr);\n",
        "            dp_set_sctp_src_ip6 (ctx, xf, xf->l34m.daddr);\n",
        "            dp_set_sctp_dst_ip6 (ctx, xf, xip);\n",
        "        }\n",
        "        else {\n",
        "            dp_set_sctp_src_ip6 (ctx, xf, xip);\n",
        "            if (!DP_XADDR_ISZR(xf->nm.nrip)) {\n",
        "                dp_set_sctp_dst_ip6 (ctx, xf, xf->nm.nrip);\n",
        "            }\n",
        "        }\n",
        "        dp_set_sctp_sport (ctx, xf, xport);\n",
        "\n",
        "#ifdef HAVE_DP_SCTP_SUM\n",
        "        dp_csum_tcall (ctx, xf);\n",
        "\n",
        "#endif\n",
        "    }\n",
        "    else if (xf->l34m.nw_proto == IPPROTO_ICMP) {\n",
        "        dp_set_icmp_src_ip6 (ctx, xf, xip);\n",
        "        if (!DP_XADDR_ISZR(xf->nm.nrip)) {\n",
        "            dp_set_icmp_dst_ip6 (ctx, xf, xf->nm.nrip);\n",
        "        }\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_set_icmp_src_ip6",
        "dp_set_sctp_sport",
        "dp_csum_tcall",
        "dp_set_tcp_sport",
        "dp_set_udp_src_ip6",
        "dp_set_udp_sport",
        "dp_set_sctp_dst_ip6",
        "dp_set_sctp_src_ip6",
        "dp_set_icmp_dst_ip6",
        "dp_set_tcp_src_ip6",
        "dp_set_udp_dst_ip6",
        "dp_set_tcp_dst_ip6"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1870,
      "endLine": 1875,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_do_snat6",
      "developer_inline_comments": [
        {
          "start_line": 1873,
          "end_line": 1873,
          "text": " FIXME - TBD "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf",
        " __be32 *xip",
        " __be16 xport"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_do_snat6 (void *ctx, struct xfi *xf, __be32 *xip, __be16 xport)\n",
        "{\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_set_icmp_src_ip6",
        "dp_set_sctp_sport",
        "dp_csum_tcall",
        "dp_set_tcp_sport",
        "dp_set_udp_src_ip6",
        "dp_set_udp_sport",
        "dp_set_sctp_dst_ip6",
        "dp_set_sctp_src_ip6",
        "dp_set_icmp_dst_ip6",
        "dp_set_tcp_src_ip6",
        "dp_set_udp_dst_ip6",
        "dp_set_tcp_dst_ip6"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_do_dnat64": [
    {
      "capabilities": [
        {
          "capability": "update_pkt",
          "update_pkt": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Change the protocol of the <[ skb ]>(IP: 0) to proto. Currently supported are transition from IPv4 to IPv6 , and from IPv6 to IPv4. The helper takes care of the groundwork for the transition , including resizing the socket buffer. The eBPF program is expected to fill the new headers , if any , via skb_store_bytes() and to recompute the checksums with bpf_l3_csum_replace() and bpf_l4_csum_replace(). The main case for this helper is to perform NAT64 operations out of an eBPF program. Internally , the GSO type is marked as dodgy so that headers are checked and segments are recalculated by the GSO/GRO engine. The size for GSO target is adapted as well. All values for <[ flags ]>(IP: 2) are reserved for future usage , and must be left at zero. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_skb_change_proto",
              "Input Params": [
                "{Type: struct sk_buff ,Var: *skb}",
                "{Type:  __be16 ,Var: proto}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "update_pkt"
              ]
            },
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Recompute the layer 4 (e. g. TCP , UDP or ICMP) checksum for the packet associated <[ to ]>(IP: 3) skb. Computation is incremental , so the helper must know the former value of the header field that was modified (from) , the new value of this field (to) , and the number of bytes (2 or 4) for this field , stored on the lowest four bits of flags. Alternatively , it is possible <[ to ]>(IP: 3) store the difference between the previous and the new values of the header field in <[ to ]>(IP: 3) , by setting <[ from ]>(IP: 2) and the four lowest bits of <[ flags ]>(IP: 4) <[ to ]>(IP: 3) 0. For both methods , <[ offset ]>(IP: 1) indicates the location of the IP checksum within the packet. In addition <[ to ]>(IP: 3) the size of the field , <[ flags ]>(IP: 4) can be added (bitwise OR) actual flags. With BPF_F_MARK_MANGLED_0 , a null checksum is left untouched (unless BPF_F_MARK_ENFORCE is added as well) , and for updates resulting in a null checksum the value is set <[ to ]>(IP: 3) CSUM_MANGLED_0 instead. Flag BPF_F_PSEUDO_HDR indicates the checksum is <[ to ]>(IP: 3) be computed against a pseudo-header. This helper works in combination with bpf_csum_diff() , which does not update the checksum in-place , but offers more flexibility and can handle sizes larger than 2 or 4 for the checksum <[ to ]>(IP: 3) update. A call <[ to ]>(IP: 3) this helper is susceptible <[ to ]>(IP: 3) change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_l4_csum_replace",
              "Input Params": [
                "{Type: struct sk_buff ,Var: *skb}",
                "{Type:  u32 ,Var: offset}",
                "{Type:  u64 ,Var: from}",
                "{Type:  u64 ,Var: to}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "lwt_xmit"
              ],
              "capabilities": [
                "update_pkt"
              ]
            }
          ]
        },
        {
          "capability": "read_skb",
          "read_skb": [
            {
              "Project": "libbpf",
              "Return Type": "s64",
              "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with bpf_l3_csum_replace() and bpf_l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with bpf_csum_diff(). ",
              "Return": " The checksum result, or a negative error code in case of failure.",
              "Function Name": "bpf_csum_diff",
              "Input Params": [
                "{Type: __be32 ,Var: *from}",
                "{Type:  u32 ,Var: from_size}",
                "{Type:  __be32 ,Var: *to}",
                "{Type:  u32 ,Var: to_size}",
                "{Type:  __wsum ,Var: seed}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "xdp",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "lwt_seg6local"
              ],
              "capabilities": [
                "read_skb"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1488,
      "endLine": 1582,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_do_dnat64",
      "developer_inline_comments": [
        {
          "start_line": 1542,
          "end_line": 1542,
          "text": " Outer IP header "
        },
        {
          "start_line": 1546,
          "end_line": 1546,
          "text": " FIXME - Copy inner"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *md",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_skb_change_proto",
        "bpf_l4_csum_replace",
        "bpf_csum_diff"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act"
      ],
      "source": [
        "static int __always_inline dp_do_dnat64 (void *md, struct xfi *xf)\n",
        "{\n",
        "    struct iphdr *iph;\n",
        "    struct ethhdr *eth;\n",
        "    struct tcphdr *tcp;\n",
        "    struct udphdr *udp;\n",
        "    struct vlanhdr *vlh;\n",
        "    __be32 sum;\n",
        "    void *dend;\n",
        "    if (xf->l34m.nw_proto != IPPROTO_TCP && xf->l34m.nw_proto != IPPROTO_UDP) {\n",
        "        LLBS_PPLN_DROP (xf);\n",
        "        return -1;\n",
        "    }\n",
        "    if (bpf_skb_change_proto (md, bpf_htons (ETH_P_IP), 0) < 0) {\n",
        "        LLBS_PPLN_DROP (xf);\n",
        "        return -1;\n",
        "    }\n",
        "    eth = DP_TC_PTR (DP_PDATA (md));\n",
        "    dend = DP_TC_PTR (DP_PDATA_END (md));\n",
        "    if (eth + 1 > dend) {\n",
        "        LLBS_PPLN_DROP (xf);\n",
        "        return -1;\n",
        "    }\n",
        "    xf->l2m.dl_type = bpf_htons (ETH_P_IP);\n",
        "    memcpy (eth->h_dest, xf->l2m.dl_dst, 2 * 6);\n",
        "    if (xf->l2m.vlan[0] != 0) {\n",
        "        vlh = DP_ADD_PTR (eth, sizeof (* eth));\n",
        "        if (vlh + 1 > dend) {\n",
        "            LLBS_PPLN_DROP (xf);\n",
        "            return -1;\n",
        "        }\n",
        "        eth->h_proto = bpf_htons (0x8100);\n",
        "        vlh->h_vlan_encapsulated_proto = xf->l2m.dl_type;\n",
        "    }\n",
        "    else {\n",
        "        eth->h_proto = xf->l2m.dl_type;\n",
        "    }\n",
        "    iph = (void *) (eth + 1);\n",
        "    if (iph + 1 > dend) {\n",
        "        LLBS_PPLN_DROP (xf);\n",
        "        return -1;\n",
        "    }\n",
        "    xf->pm.l3_len = xf->pm.l3_plen + sizeof (*iph);\n",
        "    xf->pm.l3_off = DP_DIFF_PTR (iph, eth);\n",
        "    xf->pm.l4_off = DP_DIFF_PTR ((iph + 1), eth);\n",
        "    iph->version = 4;\n",
        "    iph->ihl = 5;\n",
        "    iph->tot_len = bpf_htons (xf->pm.l3_len);\n",
        "    iph->ttl = 64;\n",
        "    iph->protocol = xf->l34m.nw_proto;\n",
        "    iph->saddr = xf->nm.nrip4;\n",
        "    iph->daddr = xf->nm.nxip4;\n",
        "    dp_ipv4_new_csum ((void *) iph);\n",
        "    if (xf->l34m.nw_proto == IPPROTO_TCP) {\n",
        "        tcp = (void *) (iph + 1);\n",
        "        if (tcp + 1 > dend) {\n",
        "            LLBS_PPLN_DROP (xf);\n",
        "            return -1;\n",
        "        }\n",
        "        sum = bpf_csum_diff (xf -> l34m.saddr, sizeof (xf -> l34m.saddr), & iph -> saddr, sizeof (iph -> saddr), 0);\n",
        "        sum = bpf_csum_diff (xf -> l34m.daddr, sizeof (xf -> l34m.daddr), & iph -> daddr, sizeof (iph -> daddr), sum);\n",
        "        bpf_l4_csum_replace (md, xf->pm.l4_off + offsetof (struct tcphdr, check), 0, sum, BPF_F_PSEUDO_HDR);\n",
        "        dp_set_tcp_dport (md, xf, xf->nm.nxport);\n",
        "    }\n",
        "    else {\n",
        "        udp = (void *) (iph + 1);\n",
        "        if (udp + 1 > dend) {\n",
        "            LLBS_PPLN_DROP (xf);\n",
        "            return -1;\n",
        "        }\n",
        "        dp_set_udp_dport (md, xf, xf->nm.nxport);\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_ipv4_new_csum",
        "dp_set_tcp_dport",
        "dp_set_udp_dport"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1891,
      "endLine": 1896,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_do_dnat64",
      "developer_inline_comments": [
        {
          "start_line": 1894,
          "end_line": 1894,
          "text": " FIXME - TBD "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_do_dnat64 (void *ctx, struct xfi *xf)\n",
        "{\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_ipv4_new_csum",
        "dp_set_tcp_dport",
        "dp_set_udp_dport"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_do_snat46": [
    {
      "capabilities": [
        {
          "capability": "update_pkt",
          "update_pkt": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Change the protocol of the <[ skb ]>(IP: 0) to proto. Currently supported are transition from IPv4 to IPv6 , and from IPv6 to IPv4. The helper takes care of the groundwork for the transition , including resizing the socket buffer. The eBPF program is expected to fill the new headers , if any , via skb_store_bytes() and to recompute the checksums with bpf_l3_csum_replace() and bpf_l4_csum_replace(). The main case for this helper is to perform NAT64 operations out of an eBPF program. Internally , the GSO type is marked as dodgy so that headers are checked and segments are recalculated by the GSO/GRO engine. The size for GSO target is adapted as well. All values for <[ flags ]>(IP: 2) are reserved for future usage , and must be left at zero. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_skb_change_proto",
              "Input Params": [
                "{Type: struct sk_buff ,Var: *skb}",
                "{Type:  __be16 ,Var: proto}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "update_pkt"
              ]
            },
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Recompute the layer 4 (e. g. TCP , UDP or ICMP) checksum for the packet associated <[ to ]>(IP: 3) skb. Computation is incremental , so the helper must know the former value of the header field that was modified (from) , the new value of this field (to) , and the number of bytes (2 or 4) for this field , stored on the lowest four bits of flags. Alternatively , it is possible <[ to ]>(IP: 3) store the difference between the previous and the new values of the header field in <[ to ]>(IP: 3) , by setting <[ from ]>(IP: 2) and the four lowest bits of <[ flags ]>(IP: 4) <[ to ]>(IP: 3) 0. For both methods , <[ offset ]>(IP: 1) indicates the location of the IP checksum within the packet. In addition <[ to ]>(IP: 3) the size of the field , <[ flags ]>(IP: 4) can be added (bitwise OR) actual flags. With BPF_F_MARK_MANGLED_0 , a null checksum is left untouched (unless BPF_F_MARK_ENFORCE is added as well) , and for updates resulting in a null checksum the value is set <[ to ]>(IP: 3) CSUM_MANGLED_0 instead. Flag BPF_F_PSEUDO_HDR indicates the checksum is <[ to ]>(IP: 3) be computed against a pseudo-header. This helper works in combination with bpf_csum_diff() , which does not update the checksum in-place , but offers more flexibility and can handle sizes larger than 2 or 4 for the checksum <[ to ]>(IP: 3) update. A call <[ to ]>(IP: 3) this helper is susceptible <[ to ]>(IP: 3) change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_l4_csum_replace",
              "Input Params": [
                "{Type: struct sk_buff ,Var: *skb}",
                "{Type:  u32 ,Var: offset}",
                "{Type:  u64 ,Var: from}",
                "{Type:  u64 ,Var: to}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "lwt_xmit"
              ],
              "capabilities": [
                "update_pkt"
              ]
            }
          ]
        },
        {
          "capability": "read_skb",
          "read_skb": [
            {
              "Project": "libbpf",
              "Return Type": "s64",
              "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with bpf_l3_csum_replace() and bpf_l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with bpf_csum_diff(). ",
              "Return": " The checksum result, or a negative error code in case of failure.",
              "Function Name": "bpf_csum_diff",
              "Input Params": [
                "{Type: __be32 ,Var: *from}",
                "{Type:  u32 ,Var: from_size}",
                "{Type:  __be32 ,Var: *to}",
                "{Type:  u32 ,Var: to_size}",
                "{Type:  __wsum ,Var: seed}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "xdp",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "lwt_seg6local"
              ],
              "capabilities": [
                "read_skb"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1584,
      "endLine": 1677,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_do_snat46",
      "developer_inline_comments": [
        {
          "start_line": 1638,
          "end_line": 1638,
          "text": " Outer IP header "
        },
        {
          "start_line": 1641,
          "end_line": 1641,
          "text": " FIXME - Copy inner ??"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *md",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_skb_change_proto",
        "bpf_l4_csum_replace",
        "bpf_csum_diff"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act"
      ],
      "source": [
        "static int __always_inline dp_do_snat46 (void *md, struct xfi *xf)\n",
        "{\n",
        "    struct ipv6hdr *ip6h;\n",
        "    struct ethhdr *eth;\n",
        "    struct tcphdr *tcp;\n",
        "    struct udphdr *udp;\n",
        "    struct vlanhdr *vlh;\n",
        "    __be32 sum;\n",
        "    void *dend;\n",
        "    if (xf->l34m.nw_proto != IPPROTO_TCP && xf->l34m.nw_proto != IPPROTO_UDP) {\n",
        "        LLBS_PPLN_DROP (xf);\n",
        "        return -1;\n",
        "    }\n",
        "    if (bpf_skb_change_proto (md, bpf_htons (ETH_P_IPV6), 0) < 0) {\n",
        "        LLBS_PPLN_DROP (xf);\n",
        "        return -1;\n",
        "    }\n",
        "    eth = DP_TC_PTR (DP_PDATA (md));\n",
        "    dend = DP_TC_PTR (DP_PDATA_END (md));\n",
        "    if (eth + 1 > dend) {\n",
        "        LLBS_PPLN_DROP (xf);\n",
        "        return -1;\n",
        "    }\n",
        "    xf->l2m.dl_type = bpf_htons (ETH_P_IPV6);\n",
        "    memcpy (eth->h_dest, xf->l2m.dl_dst, 2 * 6);\n",
        "    if (xf->l2m.vlan[0] != 0) {\n",
        "        vlh = DP_ADD_PTR (eth, sizeof (* eth));\n",
        "        if (vlh + 1 > dend) {\n",
        "            LLBS_PPLN_DROP (xf);\n",
        "            return -1;\n",
        "        }\n",
        "        eth->h_proto = bpf_htons (0x8100);\n",
        "        vlh->h_vlan_encapsulated_proto = xf->l2m.dl_type;\n",
        "    }\n",
        "    else {\n",
        "        eth->h_proto = xf->l2m.dl_type;\n",
        "    }\n",
        "    ip6h = (void *) (eth + 1);\n",
        "    if (ip6h + 1 > dend) {\n",
        "        LLBS_PPLN_DROP (xf);\n",
        "        return -1;\n",
        "    }\n",
        "    xf->pm.l3_len = xf->pm.l3_plen + sizeof (*ip6h);\n",
        "    xf->pm.l3_off = DP_DIFF_PTR (ip6h, eth);\n",
        "    xf->pm.l4_off = DP_DIFF_PTR ((ip6h + 1), eth);\n",
        "    ip6h->version = 6;\n",
        "    ip6h->payload_len = bpf_htons (xf->pm.l3_plen);\n",
        "    ip6h->hop_limit = 64;\n",
        "    ip6h->flow_lbl[0] = 0;\n",
        "    ip6h->flow_lbl[1] = 0;\n",
        "    ip6h->flow_lbl[2] = 0;\n",
        "    ip6h->nexthdr = xf->l34m.nw_proto;\n",
        "    memcpy (&ip6h->saddr, xf->nm.nxip, 16);\n",
        "    memcpy (&ip6h->daddr, xf->nm.nrip, 16);\n",
        "    if (xf->l34m.nw_proto == IPPROTO_TCP) {\n",
        "        tcp = (void *) (ip6h + 1);\n",
        "        if (tcp + 1 > dend) {\n",
        "            LLBS_PPLN_DROP (xf);\n",
        "            return -1;\n",
        "        }\n",
        "        sum = bpf_csum_diff (& xf -> l34m.saddr [0], 4, (void *) & ip6h -> saddr, sizeof (ip6h -> saddr), 0);\n",
        "        sum = bpf_csum_diff (& xf -> l34m.daddr [0], 4, (void *) & ip6h -> daddr, sizeof (ip6h -> daddr), sum);\n",
        "        bpf_l4_csum_replace (md, xf->pm.l4_off + offsetof (struct tcphdr, check), 0, sum, BPF_F_PSEUDO_HDR);\n",
        "        dp_set_tcp_sport (md, xf, xf->nm.nxport);\n",
        "    }\n",
        "    else {\n",
        "        udp = (void *) (ip6h + 1);\n",
        "        if (udp + 1 > dend) {\n",
        "            LLBS_PPLN_DROP (xf);\n",
        "            return -1;\n",
        "        }\n",
        "        dp_set_udp_sport (md, xf, xf->nm.nxport);\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_set_udp_sport",
        "dp_set_tcp_sport"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1898,
      "endLine": 1903,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_do_snat46",
      "developer_inline_comments": [
        {
          "start_line": 1901,
          "end_line": 1901,
          "text": " FIXME - TBD "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_do_snat46 (void *ctx, struct xfi *xf)\n",
        "{\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_set_udp_sport",
        "dp_set_tcp_sport"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_get_pkt_hash": [
    {
      "capabilities": [
        {
          "capability": "update_pkt",
          "update_pkt": [
            {
              "Project": "libbpf",
              "Return Type": "u32",
              "Description": "Set the full <[ hash ]>(IP: 1) for <[ skb ]>(IP: 0) (set the field skb->hash) to value hash. ",
              "Return": " 0",
              "Function Name": "bpf_set_hash",
              "Input Params": [
                "{Type: struct sk_buff ,Var: *skb}",
                "{Type:  u32 ,Var: hash}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "update_pkt"
              ]
            },
            {
              "Project": "libbpf",
              "Return Type": "void",
              "Description": "Invalidate the current skb->hash. It can be used after mangling on headers through direct packet access , in order to indicate that the hash is outdated and to trigger a recalculation the next time the kernel tries to access this hash or when the bpf_get_hash_recalc() helper is called. ",
              "Function Name": "bpf_set_hash_invalid",
              "Input Params": [
                "{Type: struct sk_buff ,Var: *skb}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "lwt_xmit"
              ],
              "capabilities": [
                "update_pkt"
              ]
            }
          ]
        },
        {
          "capability": "read_sys_info",
          "read_sys_info": [
            {
              "Project": "libbpf",
              "Return Type": "u32",
              "Description": "Retrieve the hash of the packet , skb->hash. If it is not set , in particular if the hash was cleared due to mangling , recompute this hash. Later accesses to the hash can be done directly with skb->hash. Calling bpf_set_hash_invalid() , changing a packet prototype with bpf_skb_change_proto() , or calling bpf_skb_store_bytes() with the BPF_F_INVALIDATE_HASH are actions susceptible to clear the hash and to trigger a new computation for the next call to bpf_get_hash_recalc(). ",
              "Return": " The 32-bit hash.",
              "Function Name": "bpf_get_hash_recalc",
              "Input Params": [
                "{Type: struct sk_buff ,Var: *skb}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "lwt_seg6local"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1679,
      "endLine": 1684,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_get_pkt_hash",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *md"
      ],
      "output": "static__u32__always_inline",
      "helper": [
        "bpf_set_hash",
        "bpf_set_hash_invalid",
        "bpf_get_hash_recalc"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act"
      ],
      "source": [
        "static __u32 __always_inline dp_get_pkt_hash (void *md)\n",
        "{\n",
        "    bpf_set_hash_invalid (md);\n",
        "    return bpf_get_hash_recalc (md);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1905,
      "endLine": 1910,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_get_pkt_hash",
      "developer_inline_comments": [
        {
          "start_line": 1908,
          "end_line": 1908,
          "text": " FIXME - TODO "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *md"
      ],
      "output": "static__u32__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static __u32 __always_inline dp_get_pkt_hash (void *md)\n",
        "{\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_pktbuf_read": [
    {
      "capabilities": [
        {
          "capability": "read_skb",
          "read_skb": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "This helper was provided as an easy way <[ to ]>(IP: 2) load data from a packet. It can be used <[ to ]>(IP: 2) load <[ len ]>(IP: 3) bytes from <[ offset ]>(IP: 1) from the packet associated <[ to ]>(IP: 2) <[ skb ]>(IP: 0) , into the buffer pointed by to. Since Linux 4. 7 , usage of this helper has mostly been replaced by \"direct packet access\" , enabling packet data <[ to ]>(IP: 2) be manipulated with skb->data and skb->data_end pointing respectively <[ to ]>(IP: 2) the first byte of packet data and <[ to ]>(IP: 2) the byte after the last byte of packet data. However , it remains useful if one wishes <[ to ]>(IP: 2) read large quantities of data at once from a packet into the eBPF stack. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_skb_load_bytes",
              "Input Params": [
                "{Type: const struct sk_buff ,Var: *skb}",
                "{Type:  u32 ,Var: offset}",
                "{Type:  void ,Var: *to}",
                "{Type:  u32 ,Var: len}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "sched_cls",
                "sched_act",
                "cgroup_skb",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sk_skb",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector"
              ],
              "capabilities": [
                "read_skb"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1686,
      "endLine": 1690,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_pktbuf_read",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *md",
        " __u32 off",
        " void *tobuf",
        " __u32 tolen"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_skb_load_bytes"
      ],
      "compatibleHookpoints": [
        "socket_filter",
        "sched_act",
        "sk_reuseport",
        "lwt_seg6local",
        "lwt_in",
        "sk_skb",
        "lwt_xmit",
        "lwt_out",
        "sched_cls",
        "flow_dissector",
        "cgroup_skb"
      ],
      "source": [
        "static int __always_inline dp_pktbuf_read (void *md, __u32 off, void *tobuf, __u32 tolen)\n",
        "{\n",
        "    return bpf_skb_load_bytes (md, off, tobuf, tolen);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1912,
      "endLine": 1917,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_pktbuf_read",
      "developer_inline_comments": [
        {
          "start_line": 1915,
          "end_line": 1915,
          "text": " FIXME - TODO "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *md",
        " __u32 off",
        " void *buf",
        " __u32 tolen"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_pktbuf_read (void *md, __u32 off, void *buf, __u32 tolen)\n",
        "{\n",
        "    return -1;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_pktbuf_write": [
    {
      "capabilities": [
        {
          "capability": "update_pkt",
          "update_pkt": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Store <[ len ]>(IP: 3) bytes <[ from ]>(IP: 2) address <[ from ]>(IP: 2) into the packet associated to <[ skb ]>(IP: 0) , at offset. <[ flags ]>(IP: 4) are a combination of BPF_F_RECOMPUTE_CSUM (automatically recompute the checksum for the packet after storing the bytes) and BPF_F_INVALIDATE_HASH (set skb->hash , skb->swhash and skb->l4hash to 0). A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_skb_store_bytes",
              "Input Params": [
                "{Type: struct sk_buff ,Var: *skb}",
                "{Type:  u32 ,Var: offset}",
                "{Type:  const void ,Var: *from}",
                "{Type:  u32 ,Var: len}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "lwt_xmit",
                "sk_skb"
              ],
              "capabilities": [
                "update_pkt"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1692,
      "endLine": 1696,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_pktbuf_write",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *md",
        " __u32 off",
        " void *frmbuf",
        " __u32 frmlen",
        " __u64 flags"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_skb_store_bytes"
      ],
      "compatibleHookpoints": [
        "lwt_xmit",
        "sched_cls",
        "sk_skb",
        "sched_act"
      ],
      "source": [
        "static int __always_inline dp_pktbuf_write (void *md, __u32 off, void *frmbuf, __u32 frmlen, __u64 flags)\n",
        "{\n",
        "    return bpf_skb_store_bytes (md, off, frmbuf, frmlen, flags);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1919,
      "endLine": 1924,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_pktbuf_write",
      "developer_inline_comments": [
        {
          "start_line": 1922,
          "end_line": 1922,
          "text": " FIXME - TODO "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *md",
        " __u32 off",
        " void *frmbuf",
        " __u32 frmlen",
        " __u64 flags"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_pktbuf_write (void *md, __u32 off, void *frmbuf, __u32 frmlen, __u64 flags)\n",
        "{\n",
        "    return -1;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_do_out_vlan": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1928,
      "endLine": 1974,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_do_out_vlan",
      "developer_inline_comments": [
        {
          "start_line": 1926,
          "end_line": 1926,
          "text": " End of XDP utilities "
        },
        {
          "start_line": 1939,
          "end_line": 1939,
          "text": " Strip existing vlan. Nothing to do if there was no vlan tag "
        },
        {
          "start_line": 1956,
          "end_line": 1958,
          "text": " If existing vlan tag was present just replace vlan-id, else      * push a new vlan tag and set the vlan-id     "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_do_out_vlan (void *ctx, struct xfi *xf)\n",
        "{\n",
        "    void *start = DP_TC_PTR (DP_PDATA (ctx));\n",
        "    void *dend = DP_TC_PTR (DP_PDATA_END (ctx));\n",
        "    struct ethhdr *eth;\n",
        "    int vlan;\n",
        "    vlan = xf->pm.bd;\n",
        "    if (vlan == 0) {\n",
        "        if (xf->l2m.vlan[0] != 0) {\n",
        "            if (dp_remove_vlan_tag (ctx, xf) != 0) {\n",
        "                LLBS_PPLN_DROP (xf);\n",
        "                return -1;\n",
        "            }\n",
        "        }\n",
        "        else {\n",
        "            if (start + sizeof (*eth) > dend) {\n",
        "                LLBS_PPLN_DROP (xf);\n",
        "                return -1;\n",
        "            }\n",
        "            eth = DP_TC_PTR (DP_PDATA (ctx));\n",
        "            memcpy (eth->h_dest, xf->l2m.dl_dst, 6);\n",
        "            memcpy (eth->h_source, xf->l2m.dl_src, 6);\n",
        "        }\n",
        "        return 0;\n",
        "    }\n",
        "    else {\n",
        "        eth = DP_TC_PTR (DP_PDATA (ctx));\n",
        "        if (xf->l2m.vlan[0] != 0) {\n",
        "            if (dp_swap_vlan_tag (ctx, xf, vlan) != 0) {\n",
        "                LLBS_PPLN_DROP (xf);\n",
        "                return -1;\n",
        "            }\n",
        "        }\n",
        "        else {\n",
        "            if (dp_insert_vlan_tag (ctx, xf, vlan) != 0) {\n",
        "                LLBS_PPLN_DROP (xf);\n",
        "                return -1;\n",
        "            }\n",
        "        }\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_remove_vlan_tag",
        "dp_swap_vlan_tag",
        "dp_insert_vlan_tag"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_pop_outer_l2_metadata": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1976,
      "endLine": 1986,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_pop_outer_l2_metadata",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *md",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_pop_outer_l2_metadata (void *md, struct xfi *xf)\n",
        "{\n",
        "    memcpy (&xf->l2m.dl_type, &xf->il2m.dl_type, sizeof (xf->l2m) - sizeof (xf->l2m.vlan));\n",
        "    memcpy (xf->pm.lkup_dmac, xf->il2m.dl_dst, 6);\n",
        "    xf->il2m.valid = 0;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_pop_outer_metadata": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1988,
      "endLine": 2008,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_pop_outer_metadata",
      "developer_inline_comments": [
        {
          "start_line": 1991,
          "end_line": 1991,
          "text": " Reset pipeline metadata "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *md",
        " struct xfi *xf",
        " int l2tun"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_pop_outer_metadata (void *md, struct xfi *xf, int l2tun)\n",
        "{\n",
        "    memcpy (&xf->l34m, &xf->il34m, sizeof (xf->l34m));\n",
        "    xf->pm.tcp_flags = xf->pm.itcp_flags;\n",
        "    xf->pm.l4fin = xf->pm.il4fin;\n",
        "    xf->pm.l3_off = xf->pm.il3_off;\n",
        "    xf->pm.l3_len = xf->pm.il3_len;\n",
        "    xf->pm.l3_plen = xf->pm.il3_plen;\n",
        "    xf->pm.l4_off = xf->pm.il4_off;\n",
        "    xf->il34m.valid = 0;\n",
        "    xf->tm.tun_decap = 1;\n",
        "    if (l2tun) {\n",
        "        return dp_pop_outer_l2_metadata (md, xf);\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_pop_outer_l2_metadata"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_do_strip_ipip": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 2010,
      "endLine": 2052,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_do_strip_ipip",
      "developer_inline_comments": [
        {
          "start_line": 2031,
          "end_line": 2031,
          "text": " Recreate eth header "
        },
        {
          "start_line": 2035,
          "end_line": 2037,
          "text": " We do not care about vlan's now   * After routing it will be set as per outgoing BD   "
        },
        {
          "start_line": 2042,
          "end_line": 2042,
          "text": " Reset pipeline metadata "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *md",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_do_strip_ipip (void *md, struct xfi *xf)\n",
        "{\n",
        "    struct ethhdr *eth;\n",
        "    void *dend;\n",
        "    int olen = sizeof (struct iphdr);\n",
        "    if (dp_buf_delete_room (md, olen, BPF_F_ADJ_ROOM_FIXED_GSO) < 0) {\n",
        "        LL_DBG_PRINTK (\"Failed gtph remove\\n\");\n",
        "        LLBS_PPLN_DROP (xf);\n",
        "        return -1;\n",
        "    }\n",
        "    eth = DP_TC_PTR (DP_PDATA (md));\n",
        "    dend = DP_TC_PTR (DP_PDATA_END (md));\n",
        "    if (eth + 1 > dend) {\n",
        "        LLBS_PPLN_DROP (xf);\n",
        "        return -1;\n",
        "    }\n",
        "    memcpy (eth->h_dest, xf->l2m.dl_dst, 2 * 6);\n",
        "    eth->h_proto = xf->l2m.dl_type;\n",
        "    xf->l2m.vlan[0] = 0;\n",
        "    xf->l2m.vlan[1] = 0;\n",
        "\n",
        "#if 0\n",
        "    memcpy (&xf->l34m, &xf->il34m, sizeof (xf->l34m));\n",
        "    memcpy (xf->pm.lkup_dmac, eth->h_dest, 6);\n",
        "    xf->il34m.valid = 0;\n",
        "    xf->il2m.valid = 0;\n",
        "    xf->tm.tun_decap = 1;\n",
        "\n",
        "#endif\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_buf_delete_room"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_do_ins_ipip": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 2054,
      "endLine": 2128,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_do_ins_ipip",
      "developer_inline_comments": [
        {
          "start_line": 2073,
          "end_line": 2073,
          "text": " add room between mac and network header "
        },
        {
          "start_line": 2093,
          "end_line": 2093,
          "text": " Outer IP header "
        },
        {
          "start_line": 2097,
          "end_line": 2097,
          "text": " FIXME - Copy inner"
        },
        {
          "start_line": 2110,
          "end_line": 2114,
          "text": "    * Reset pipeline metadata    * If it is called from deparser, there is no need   * to do the following (set skip_md = 1)   "
        },
        {
          "start_line": 2117,
          "end_line": 2117,
          "text": " Outer L2 - MAC addr are invalid as of now "
        },
        {
          "start_line": 2120,
          "end_line": 2120,
          "text": " Outer L3 "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *md",
        " struct xfi *xf",
        " __be32 rip",
        " __be32 sip",
        " __be32 tid",
        " int skip_md"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_do_ins_ipip (void *md, struct xfi *xf, __be32 rip, __be32 sip, __be32 tid, int skip_md)\n",
        "{\n",
        "    void *dend;\n",
        "    struct ethhdr *eth;\n",
        "    struct iphdr *iph;\n",
        "    int olen;\n",
        "    __u64 flags;\n",
        "    olen = sizeof (*iph);\n",
        "    flags = BPF_F_ADJ_ROOM_FIXED_GSO | BPF_F_ADJ_ROOM_ENCAP_L3_IPV4;\n",
        "    if (dp_buf_add_room (md, olen, flags)) {\n",
        "        LLBS_PPLN_DROP (xf);\n",
        "        return -1;\n",
        "    }\n",
        "    eth = DP_TC_PTR (DP_PDATA (md));\n",
        "    dend = DP_TC_PTR (DP_PDATA_END (md));\n",
        "    if (eth + 1 > dend) {\n",
        "        LLBS_PPLN_DROP (xf);\n",
        "        return -1;\n",
        "    }\n",
        "    iph = (void *) (eth + 1);\n",
        "    if (iph + 1 > dend) {\n",
        "        LLBS_PPLN_DROP (xf);\n",
        "        return -1;\n",
        "    }\n",
        "    iph->version = 4;\n",
        "    iph->ihl = 5;\n",
        "    iph->tot_len = bpf_htons (xf->pm.l3_len + olen);\n",
        "    iph->ttl = 64;\n",
        "    iph->protocol = IPPROTO_IPIP;\n",
        "    iph->saddr = sip;\n",
        "    iph->daddr = rip;\n",
        "    dp_ipv4_new_csum ((void *) iph);\n",
        "    xf->tm.tun_encap = 1;\n",
        "    if (skip_md) {\n",
        "        return 0;\n",
        "    }\n",
        "    memcpy (&xf->il34m, &xf->l34m, sizeof (xf->l34m));\n",
        "    xf->pm.lkup_dmac[0] = 0xff;\n",
        "    xf->l34m.saddr4 = sip;\n",
        "    xf->l34m.daddr4 = rip;\n",
        "    xf->l34m.source = 0;\n",
        "    xf->l34m.dest = 0;\n",
        "    xf->pm.l4_off = xf->pm.l3_off + sizeof (*iph);\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_ipv4_new_csum",
        "dp_buf_add_room"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_do_strip_vxlan": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 2130,
      "endLine": 2175,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_do_strip_vxlan",
      "developer_inline_comments": [
        {
          "start_line": 2163,
          "end_line": 2163,
          "text": " Reset pipeline metadata "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *md",
        " struct xfi *xf",
        " int olen"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_do_strip_vxlan (void *md, struct xfi *xf, int olen)\n",
        "{\n",
        "    struct ethhdr *eth;\n",
        "    struct vlanhdr *vlh;\n",
        "    void *dend;\n",
        "    if (dp_buf_delete_room (md, olen, BPF_F_ADJ_ROOM_FIXED_GSO) < 0) {\n",
        "        LL_DBG_PRINTK (\"Failed MAC remove\\n\");\n",
        "        LLBS_PPLN_DROP (xf);\n",
        "        return -1;\n",
        "    }\n",
        "    eth = DP_TC_PTR (DP_PDATA (md));\n",
        "    dend = DP_TC_PTR (DP_PDATA_END (md));\n",
        "    if (eth + 1 > dend) {\n",
        "        LLBS_PPLN_DROP (xf);\n",
        "        return -1;\n",
        "    }\n",
        "    memcpy (eth->h_dest, xf->il2m.dl_dst, 2 * 6);\n",
        "    if (xf->il2m.vlan[0] != 0) {\n",
        "        vlh = DP_ADD_PTR (eth, sizeof (* eth));\n",
        "        if (vlh + 1 > dend) {\n",
        "            LLBS_PPLN_DROP (xf);\n",
        "            return -1;\n",
        "        }\n",
        "        vlh->h_vlan_encapsulated_proto = xf->il2m.dl_type;\n",
        "    }\n",
        "    else {\n",
        "        eth->h_proto = xf->il2m.dl_type;\n",
        "    }\n",
        "\n",
        "#if 0\n",
        "    memcpy (&xf->l34m, &xf->il34m, sizeof (xf->l34m));\n",
        "    memcpy (&xf->l2m, &xf->il2m, sizeof (xf->l2m));\n",
        "    memcpy (xf->pm.lkup_dmac, eth->h_dest, 6);\n",
        "    xf->il34m.valid = 0;\n",
        "    xf->il2m.valid = 0;\n",
        "    xf->tm.tun_decap = 1;\n",
        "\n",
        "#endif\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_buf_delete_room"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_do_ins_vxlan": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 2177,
      "endLine": 2330,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_do_ins_vxlan",
      "developer_inline_comments": [
        {
          "start_line": 2194,
          "end_line": 2194,
          "text": " We do not pass vlan header inside vxlan "
        },
        {
          "start_line": 2211,
          "end_line": 2211,
          "text": " add room between mac and network header "
        },
        {
          "start_line": 2226,
          "end_line": 2232,
          "text": "    * FIXME - Inner ethernet    * No need to copy but if we dont    * inner eth header is sometimes not set   * properly especially when incoming packet   * was vlan tagged   "
        },
        {
          "start_line": 2245,
          "end_line": 2245,
          "text": " Outer IP header "
        },
        {
          "start_line": 2249,
          "end_line": 2249,
          "text": " FIXME - Copy inner"
        },
        {
          "start_line": 2262,
          "end_line": 2262,
          "text": " Outer UDP header "
        },
        {
          "start_line": 2268,
          "end_line": 2268,
          "text": " VxLAN header "
        },
        {
          "start_line": 2275,
          "end_line": 2277,
          "text": " Control agent should pass tunnel-id something like this -   * bpf_htonl(((__le32)(tid) << 8) & 0xffffff00);   "
        },
        {
          "start_line": 2281,
          "end_line": 2283,
          "text": " Inner eth header -   * XXX If we do not copy, inner eth is zero'd out   "
        },
        {
          "start_line": 2293,
          "end_line": 2293,
          "text": " Tunnel metadata "
        },
        {
          "start_line": 2301,
          "end_line": 2301,
          "text": " Reset flags essential for L2 header rewrite "
        },
        {
          "start_line": 2309,
          "end_line": 2313,
          "text": "    * Reset pipeline metadata    * If it is called from deparser, there is no need   * to do the following (set skip_md = 1)   "
        },
        {
          "start_line": 2318,
          "end_line": 2318,
          "text": " Outer L2 - MAC addr are invalid as of now "
        },
        {
          "start_line": 2321,
          "end_line": 2321,
          "text": " Outer L3 "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *md",
        " struct xfi *xf",
        " __be32 rip",
        " __be32 sip",
        " __be32 tid",
        " int skip_md"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_do_ins_vxlan (void *md, struct xfi *xf, __be32 rip, __be32 sip, __be32 tid, int skip_md)\n",
        "{\n",
        "    void *dend;\n",
        "    struct ethhdr *eth;\n",
        "    struct ethhdr *ieth;\n",
        "    struct iphdr *iph;\n",
        "    struct udphdr *udp;\n",
        "    struct vxlanhdr *vx;\n",
        "    int olen, l2_len;\n",
        "    __u64 flags;\n",
        "    if (xf->l2m.vlan[0] != 0) {\n",
        "        if (dp_remove_vlan_tag (md, xf) < 0) {\n",
        "            LLBS_PPLN_DROP (xf);\n",
        "            return -1;\n",
        "        }\n",
        "    }\n",
        "    olen = sizeof (*iph) + sizeof (*udp) + sizeof (*vx);\n",
        "    l2_len = sizeof (*eth);\n",
        "    flags = BPF_F_ADJ_ROOM_FIXED_GSO | BPF_F_ADJ_ROOM_ENCAP_L3_IPV4 | BPF_F_ADJ_ROOM_ENCAP_L4_UDP | BPF_F_ADJ_ROOM_ENCAP_L2 (l2_len);\n",
        "    olen += l2_len;\n",
        "    if (dp_buf_add_room (md, olen, flags)) {\n",
        "        LLBS_PPLN_DROP (xf);\n",
        "        return -1;\n",
        "    }\n",
        "    eth = DP_TC_PTR (DP_PDATA (md));\n",
        "    dend = DP_TC_PTR (DP_PDATA_END (md));\n",
        "    if (eth + 1 > dend) {\n",
        "        LLBS_PPLN_DROP (xf);\n",
        "        return -1;\n",
        "    }\n",
        "\n",
        "#if 0\n",
        "    if (xf->l2m.vlan[0]) {\n",
        "        memcpy (eth->h_dest, xf->il2m.dl_dst, 2 * 6);\n",
        "        eth->h_proto = xf->il2m.dl_type;\n",
        "    }\n",
        "\n",
        "#endif\n",
        "    iph = (void *) (eth + 1);\n",
        "    if (iph + 1 > dend) {\n",
        "        LLBS_PPLN_DROP (xf);\n",
        "        return -1;\n",
        "    }\n",
        "    iph->version = 4;\n",
        "    iph->ihl = 5;\n",
        "    iph->tot_len = bpf_htons (xf->pm.l3_len + olen);\n",
        "    iph->ttl = 64;\n",
        "    iph->protocol = IPPROTO_UDP;\n",
        "    iph->saddr = sip;\n",
        "    iph->daddr = rip;\n",
        "    dp_ipv4_new_csum ((void *) iph);\n",
        "    udp = (void *) (iph + 1);\n",
        "    if (udp + 1 > dend) {\n",
        "        LLBS_PPLN_DROP (xf);\n",
        "        return -1;\n",
        "    }\n",
        "    udp->source = xf->l34m.source + VXLAN_OUDP_SPORT;\n",
        "    udp->dest = bpf_htons (VXLAN_OUDP_DPORT);\n",
        "    udp->check = 0;\n",
        "    udp->len = bpf_htons (xf->pm.l3_len + olen - sizeof (*iph));\n",
        "    vx = (void *) (udp + 1);\n",
        "    if (vx + 1 > dend) {\n",
        "        LLBS_PPLN_DROP (xf);\n",
        "        return -1;\n",
        "    }\n",
        "    vx->vx_vni = tid;\n",
        "    vx->vx_flags = VXLAN_VI_FLAG_ON;\n",
        "    ieth = (void *) (vx + 1);\n",
        "    if (ieth + 1 > dend) {\n",
        "        LLBS_PPLN_DROP (xf);\n",
        "        return -1;\n",
        "    }\n",
        "    memcpy (ieth->h_dest, xf->il2m.dl_dst, 2 * 6);\n",
        "    ieth->h_proto = xf->il2m.dl_type;\n",
        "    xf->tm.tun_type = LLB_TUN_VXLAN;\n",
        "    xf->tm.tunnel_id = bpf_ntohl (tid);\n",
        "    xf->pm.tun_off = sizeof (*eth) + sizeof (*iph) + sizeof (*udp);\n",
        "    xf->tm.tun_encap = 1;\n",
        "    xf->l2m.vlan[0] = 0;\n",
        "    xf->l2m.dl_type = bpf_htons (ETH_P_IP);\n",
        "    if (skip_md) {\n",
        "        return 0;\n",
        "    }\n",
        "    memcpy (&xf->il34m, &xf->l34m, sizeof (xf->l34m));\n",
        "    memcpy (&xf->il2m, &xf->l2m, sizeof (xf->l2m));\n",
        "    xf->il2m.vlan[0] = 0;\n",
        "    xf->pm.lkup_dmac[0] = 0xff;\n",
        "    xf->l34m.saddr4 = sip;\n",
        "    xf->l34m.daddr4 = rip;\n",
        "    xf->l34m.source = udp->source;\n",
        "    xf->l34m.dest = udp->dest;\n",
        "    xf->pm.l3_off = sizeof (*eth);\n",
        "    xf->pm.l4_off = sizeof (*eth) + sizeof (*iph);\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_ipv4_new_csum",
        "dp_remove_vlan_tag",
        "dp_buf_add_room"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_do_strip_gtp": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 2332,
      "endLine": 2378,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_do_strip_gtp",
      "developer_inline_comments": [
        {
          "start_line": 2357,
          "end_line": 2357,
          "text": " Recreate eth header "
        },
        {
          "start_line": 2361,
          "end_line": 2363,
          "text": " We do not care about vlan's now   * After routing it will be set as per outgoing BD   "
        },
        {
          "start_line": 2368,
          "end_line": 2368,
          "text": " Reset pipeline metadata "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *md",
        " struct xfi *xf",
        " int olen"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_do_strip_gtp (void *md, struct xfi *xf, int olen)\n",
        "{\n",
        "    struct ethhdr *eth;\n",
        "    void *dend;\n",
        "    if (olen < sizeof (*eth)) {\n",
        "        LLBS_PPLN_DROP (xf);\n",
        "        return -1;\n",
        "    }\n",
        "    if (dp_buf_delete_room (md, olen - sizeof (*eth), BPF_F_ADJ_ROOM_FIXED_GSO) < 0) {\n",
        "        LL_DBG_PRINTK (\"Failed gtph remove\\n\");\n",
        "        LLBS_PPLN_DROP (xf);\n",
        "        return -1;\n",
        "    }\n",
        "    eth = DP_TC_PTR (DP_PDATA (md));\n",
        "    dend = DP_TC_PTR (DP_PDATA_END (md));\n",
        "    if (eth + 1 > dend) {\n",
        "        LLBS_PPLN_DROP (xf);\n",
        "        return -1;\n",
        "    }\n",
        "    memcpy (eth->h_dest, xf->l2m.dl_dst, 2 * 6);\n",
        "    eth->h_proto = xf->l2m.dl_type;\n",
        "    xf->l2m.vlan[0] = 0;\n",
        "    xf->l2m.vlan[1] = 0;\n",
        "\n",
        "#if 0\n",
        "    memcpy (&xf->l34m, &xf->il34m, sizeof (xf->l34m));\n",
        "    memcpy (xf->pm.lkup_dmac, eth->h_dest, 6);\n",
        "    xf->il34m.valid = 0;\n",
        "    xf->il2m.valid = 0;\n",
        "    xf->tm.tun_decap = 1;\n",
        "\n",
        "#endif\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_buf_delete_room"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_do_ins_gtp": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 2380,
      "endLine": 2528,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_do_ins_gtp",
      "developer_inline_comments": [
        {
          "start_line": 2415,
          "end_line": 2415,
          "text": " add room between mac and network header "
        },
        {
          "start_line": 2435,
          "end_line": 2435,
          "text": " Outer IP header "
        },
        {
          "start_line": 2439,
          "end_line": 2439,
          "text": " FIXME - Copy inner"
        },
        {
          "start_line": 2452,
          "end_line": 2452,
          "text": " Outer UDP header "
        },
        {
          "start_line": 2458,
          "end_line": 2458,
          "text": " GTP header "
        },
        {
          "start_line": 2473,
          "end_line": 2473,
          "text": " GTP extension header "
        },
        {
          "start_line": 2497,
          "end_line": 2497,
          "text": " Tunnel metadata "
        },
        {
          "start_line": 2509,
          "end_line": 2513,
          "text": "    * Reset pipeline metadata    * If it is called from deparser, there is no need   * to do the following (set skip_md = 1)   "
        },
        {
          "start_line": 2517,
          "end_line": 2517,
          "text": " Outer L2 - MAC addr are invalid as of now "
        },
        {
          "start_line": 2520,
          "end_line": 2520,
          "text": " Outer L3 "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *md",
        " struct xfi *xf",
        " __be32 rip",
        " __be32 sip",
        " __be32 tid",
        " __u8 qfi",
        " int skip_md"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_do_ins_gtp (void *md, struct xfi *xf, __be32 rip, __be32 sip, __be32 tid, __u8 qfi, int skip_md)\n",
        "{\n",
        "    void *dend;\n",
        "    struct gtp_v1_hdr *gh;\n",
        "    struct gtp_v1_ehdr *geh;\n",
        "    struct gtp_dl_pdu_sess_hdr *gedh;\n",
        "    struct ethhdr *eth;\n",
        "    struct iphdr *iph;\n",
        "    struct udphdr *udp;\n",
        "    int olen;\n",
        "    __u64 flags;\n",
        "    int ghlen;\n",
        "    __u8 espn;\n",
        "    if (qfi) {\n",
        "        ghlen = sizeof (*gh) + sizeof (*geh) + sizeof (*gedh);\n",
        "        espn = GTP_EXT_FM;\n",
        "    }\n",
        "    else {\n",
        "        ghlen = sizeof (*gh);\n",
        "        espn = 0;\n",
        "    }\n",
        "    olen = sizeof (*iph) + sizeof (*udp) + ghlen;\n",
        "    flags = BPF_F_ADJ_ROOM_FIXED_GSO | BPF_F_ADJ_ROOM_ENCAP_L3_IPV4 | BPF_F_ADJ_ROOM_ENCAP_L4_UDP;\n",
        "    if (dp_buf_add_room (md, olen, flags)) {\n",
        "        LLBS_PPLN_DROP (xf);\n",
        "        return -1;\n",
        "    }\n",
        "    eth = DP_TC_PTR (DP_PDATA (md));\n",
        "    dend = DP_TC_PTR (DP_PDATA_END (md));\n",
        "    if (eth + 1 > dend) {\n",
        "        LLBS_PPLN_DROP (xf);\n",
        "        return -1;\n",
        "    }\n",
        "    iph = (void *) (eth + 1);\n",
        "    if (iph + 1 > dend) {\n",
        "        LLBS_PPLN_DROP (xf);\n",
        "        return -1;\n",
        "    }\n",
        "    iph->version = 4;\n",
        "    iph->ihl = 5;\n",
        "    iph->tot_len = bpf_htons (xf->pm.l3_len + olen);\n",
        "    iph->ttl = 64;\n",
        "    iph->protocol = IPPROTO_UDP;\n",
        "    iph->saddr = sip;\n",
        "    iph->daddr = rip;\n",
        "    dp_ipv4_new_csum ((void *) iph);\n",
        "    udp = (void *) (iph + 1);\n",
        "    if (udp + 1 > dend) {\n",
        "        LLBS_PPLN_DROP (xf);\n",
        "        return -1;\n",
        "    }\n",
        "    udp->source = bpf_htons (GTPU_UDP_SPORT);\n",
        "    udp->dest = bpf_htons (GTPU_UDP_DPORT);\n",
        "    udp->check = 0;\n",
        "    udp->len = bpf_htons (xf->pm.l3_len + olen - sizeof (*iph));\n",
        "    gh = (void *) (udp + 1);\n",
        "    if (gh + 1 > dend) {\n",
        "        LLBS_PPLN_DROP (xf);\n",
        "        return -1;\n",
        "    }\n",
        "    gh->ver = GTP_VER_1;\n",
        "    gh->pt = 1;\n",
        "    gh->espn = espn;\n",
        "    gh->teid = tid;\n",
        "    gh->mt = GTP_MT_TPDU;\n",
        "    gh->mlen = bpf_ntohs (xf->pm.l3_len + ghlen);\n",
        "    if (qfi) {\n",
        "        geh = (void *) (gh + 1);\n",
        "        if (geh + 1 > dend) {\n",
        "            LLBS_PPLN_DROP (xf);\n",
        "            return -1;\n",
        "        }\n",
        "        geh->seq = 0;\n",
        "        geh->npdu = 0;\n",
        "        geh->next_hdr = GTP_NH_PDU_SESS;\n",
        "        gedh = (void *) (geh + 1);\n",
        "        if (gedh + 1 > dend) {\n",
        "            LLBS_PPLN_DROP (xf);\n",
        "            return -1;\n",
        "        }\n",
        "        gedh->cmn.len = 1;\n",
        "        gedh->cmn.pdu_type = GTP_PDU_SESS_DL;\n",
        "        gedh->qfi = qfi;\n",
        "        gedh->ppp = 0;\n",
        "        gedh->rqi = 0;\n",
        "        gedh->next_hdr = 0;\n",
        "    }\n",
        "    xf->tm.tun_type = LLB_TUN_GTP;\n",
        "    xf->tm.tunnel_id = bpf_ntohl (tid);\n",
        "    xf->pm.tun_off = sizeof (*eth) + sizeof (*iph) + sizeof (*udp);\n",
        "    xf->tm.tun_encap = 1;\n",
        "    if (skip_md) {\n",
        "        return 0;\n",
        "    }\n",
        "    memcpy (&xf->il34m, &xf->l34m, sizeof (xf->l34m));\n",
        "    xf->il2m.vlan[0] = 0;\n",
        "    xf->pm.lkup_dmac[0] = 0xff;\n",
        "    xf->l34m.saddr4 = sip;\n",
        "    xf->l34m.daddr4 = rip;\n",
        "    xf->l34m.source = udp->source;\n",
        "    xf->l34m.dest = udp->dest;\n",
        "    xf->pm.l4_off = xf->pm.l3_off + sizeof (*iph);\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "dp_ipv4_new_csum",
        "dp_buf_add_room"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "xdp2tc_has_xmd": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 2531,
      "endLine": 2559,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "xdp2tc_has_xmd",
      "developer_inline_comments": [
        {
          "start_line": 2538,
          "end_line": 2538,
          "text": " Check XDP gave us some data_meta "
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *md",
        " struct xfi *xf"
      ],
      "output": "staticint__always_inline",
      "helper": [],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "perf_event",
        "cgroup_device",
        "lwt_xmit",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "cgroup_sysctl",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "cgroup_sock",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline xdp2tc_has_xmd (void *md, struct xfi *xf)\n",
        "{\n",
        "    void *data = DP_TC_PTR (DP_PDATA (md));\n",
        "    void *data_meta = DP_TC_PTR (DP_MDATA (md));\n",
        "    struct ll_xmdi *meta = data_meta;\n",
        "    if (meta + 1 <= data) {\n",
        "        if (meta->pi.skip != 0) {\n",
        "            xf->pm.tc = 0;\n",
        "            LLBS_PPLN_PASS (xf);\n",
        "            return 1;\n",
        "        }\n",
        "        if (meta->pi.iport) {\n",
        "            xf->pm.oport = meta->pi.iport;\n",
        "            LLBS_PPLN_REWIRE (xf);\n",
        "        }\n",
        "        else {\n",
        "            xf->pm.oport = meta->pi.oport;\n",
        "            LLBS_PPLN_RDR (xf);\n",
        "        }\n",
        "        xf->pm.tc = 0;\n",
        "        meta->pi.skip = 1;\n",
        "        return 1;\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ],
  "dp_tail_call": [
    {
      "capabilities": [
        {
          "capability": "map_update",
          "map_update": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "bpf_map_update_elem",
              "Input Params": [
                "{Type: struct bpf_map ,Var: *map}",
                "{Type:  const void ,Var: *key}",
                "{Type:  const void ,Var: *value}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_update"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 2561,
      "endLine": 2581,
      "File": "/home/sayandes/ebpf-projects-annotations/projects/loxilb-ebpf/original_source/kernel/llb_kern_cdefs.h",
      "funcName": "dp_tail_call",
      "developer_inline_comments": [
        {
          "start_line": 2571,
          "end_line": 2571,
          "text": " fa state can be reused "
        },
        {
          "start_line": 2575,
          "end_line": 2575,
          "text": " xfi state can be reused "
        }
      ],
      "updateMaps": [
        " fcas",
        " xfis"
      ],
      "readMaps": [],
      "input": [
        "void *ctx",
        " struct xfi *xf",
        " void *fa",
        " __u32 idx"
      ],
      "output": "staticint__always_inline",
      "helper": [
        "bpf_tail_call",
        "bpf_map_update_elem",
        "tail_call"
      ],
      "compatibleHookpoints": [
        "sk_reuseport",
        "raw_tracepoint",
        "sk_skb",
        "lwt_out",
        "sched_act",
        "lwt_xmit",
        "cgroup_sock",
        "sched_cls",
        "tracepoint",
        "xdp",
        "raw_tracepoint_writable",
        "kprobe",
        "sk_msg",
        "socket_filter",
        "sock_ops",
        "lwt_seg6local",
        "lwt_in",
        "perf_event",
        "flow_dissector",
        "cgroup_skb",
        "cgroup_sock_addr"
      ],
      "source": [
        "static int __always_inline dp_tail_call (void *ctx, struct xfi *xf, void *fa, __u32 idx)\n",
        "{\n",
        "    int z = 0;\n",
        "    if (xf->nm.ct_sts != 0) {\n",
        "        return DP_PASS;\n",
        "    }\n",
        "\n",
        "#ifdef HAVE_DP_FC\n",
        "    bpf_map_update_elem (&fcas, &z, fa, BPF_ANY);\n",
        "\n",
        "#endif\n",
        "    bpf_map_update_elem (&xfis, &z, xf, BPF_ANY);\n",
        "    bpf_tail_call (ctx, &pgm_tbl, idx);\n",
        "    return DP_PASS;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": ""
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ],
      "is_root_fn": 0
    }
  ]
}