{"_default": {"1": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}, {"capability": "pkt_stop_processing_drop_packet", "pkt_stop_processing_drop_packet": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_ABORTED", "Return": 0, "Description": "which serves denoting an exception like state from the program and has the same behavior as XDP_DROP only that XDP_ABORTED passes the trace_xdp_exception tracepoint which can be additionally monitored to detect misbehavior.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_stop_processing_drop_packet"]}]}, {"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_PASS", "Return": 2, "Description": "The XDP_PASS return code means that the packet is allowed to be passed up to the kernel\u2019s networking stack. Meaning, the current CPU that was processing this packet now allocates a skb, populates it, and passes it onwards into the GRO engine. This would be equivalent to the default packet handling behavior without XDP.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 73, "endLine": 99, "File": "/home/palani/github/ebpf-projects-annotations/projects/suricata-master/original_source/ebpf/xdp_lb.c", "funcName": "hash_ipv4", "developer_inline_comments": [{"start_line": 1, "end_line": 16, "text": "/* Copyright (C) 2019 Open Information Security Foundation\n *\n * You can copy, redistribute or modify this Program under the terms of\n * the GNU General Public License version 2 as published by the Free\n * Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * version 2 along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n * 02110-1301, USA.\n */"}, {"start_line": 26, "end_line": 26, "text": "/* Workaround to avoid the need of 32bit headers */"}, {"start_line": 40, "end_line": 40, "text": "/* Hashing initval */"}, {"start_line": 43, "end_line": 43, "text": "/* Increase CPUMAP_MAX_CPUS if ever you have more than 128 CPUs */"}, {"start_line": 51, "end_line": 51, "text": "/* Special map type that can XDP_REDIRECT frames to another CPU */"}, {"start_line": 85, "end_line": 85, "text": "/* IP-pairs hit same CPU */"}], "updateMaps": [], "readMaps": [" cpus_count", "  cpus_available"], "input": ["void *data", " void *data_end"], "output": "staticint__always_inline", "helper": ["bpf_map_lookup_elem", "XDP_ABORTED", "bpf_redirect_map", "bpf_redirect", "XDP_PASS"], "compatibleHookpoints": ["xdp"], "source": ["static int __always_inline hash_ipv4 (void *data, void *data_end)\n", "{\n", "    struct iphdr *iph = data;\n", "    if ((void *) (iph + 1) > data_end)\n", "        return XDP_PASS;\n", "    __u32 key0 = 0;\n", "    __u32 cpu_dest;\n", "    __u32 *cpu_max = bpf_map_lookup_elem (&cpus_count, &key0);\n", "    __u32 *cpu_selected;\n", "    __u32 cpu_hash;\n", "    cpu_hash = iph->saddr + iph->daddr;\n", "    cpu_hash = SuperFastHash ((char *) & cpu_hash, 4, INITVAL);\n", "    if (cpu_max && *cpu_max) {\n", "        cpu_dest = cpu_hash % *cpu_max;\n", "        cpu_selected = bpf_map_lookup_elem (& cpus_available, & cpu_dest);\n", "        if (!cpu_selected)\n", "            return XDP_ABORTED;\n", "        cpu_dest = *cpu_selected;\n", "        return bpf_redirect_map (&cpu_map, cpu_dest, 0);\n", "    }\n", "    else {\n", "        return XDP_PASS;\n", "    }\n", "}\n"], "called_function_list": ["SuperFastHash"], "call_depth": 1, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 0}, "2": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}, {"capability": "pkt_stop_processing_drop_packet", "pkt_stop_processing_drop_packet": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_ABORTED", "Return": 0, "Description": "which serves denoting an exception like state from the program and has the same behavior as XDP_DROP only that XDP_ABORTED passes the trace_xdp_exception tracepoint which can be additionally monitored to detect misbehavior.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_stop_processing_drop_packet"]}]}, {"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_PASS", "Return": 2, "Description": "The XDP_PASS return code means that the packet is allowed to be passed up to the kernel\u2019s networking stack. Meaning, the current CPU that was processing this packet now allocates a skb, populates it, and passes it onwards into the GRO engine. This would be equivalent to the default packet handling behavior without XDP.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 101, "endLine": 132, "File": "/home/palani/github/ebpf-projects-annotations/projects/suricata-master/original_source/ebpf/xdp_lb.c", "funcName": "hash_ipv6", "developer_inline_comments": [{"start_line": 113, "end_line": 113, "text": "/* IP-pairs hit same CPU */"}], "updateMaps": [], "readMaps": [" cpus_count", "  cpus_available"], "input": ["void *data", " void *data_end"], "output": "staticint__always_inline", "helper": ["bpf_map_lookup_elem", "XDP_ABORTED", "bpf_redirect_map", "bpf_redirect", "XDP_PASS"], "compatibleHookpoints": ["xdp"], "source": ["static int __always_inline hash_ipv6 (void *data, void *data_end)\n", "{\n", "    struct ipv6hdr *ip6h = data;\n", "    if ((void *) (ip6h + 1) > data_end)\n", "        return XDP_PASS;\n", "    __u32 key0 = 0;\n", "    __u32 cpu_dest;\n", "    __u32 *cpu_max = bpf_map_lookup_elem (&cpus_count, &key0);\n", "    __u32 *cpu_selected;\n", "    __u32 cpu_hash;\n", "    cpu_hash = ip6h->saddr.s6_addr32[0] + ip6h->daddr.s6_addr32[0];\n", "    cpu_hash += ip6h->saddr.s6_addr32[1] + ip6h->daddr.s6_addr32[1];\n", "    cpu_hash += ip6h->saddr.s6_addr32[2] + ip6h->daddr.s6_addr32[2];\n", "    cpu_hash += ip6h->saddr.s6_addr32[3] + ip6h->daddr.s6_addr32[3];\n", "    cpu_hash = SuperFastHash ((char *) & cpu_hash, 4, INITVAL);\n", "    if (cpu_max && *cpu_max) {\n", "        cpu_dest = cpu_hash % *cpu_max;\n", "        cpu_selected = bpf_map_lookup_elem (& cpus_available, & cpu_dest);\n", "        if (!cpu_selected)\n", "            return XDP_ABORTED;\n", "        cpu_dest = *cpu_selected;\n", "        return bpf_redirect_map (&cpu_map, cpu_dest, 0);\n", "    }\n", "    else {\n", "        return XDP_PASS;\n", "    }\n", "    return XDP_PASS;\n", "}\n"], "called_function_list": ["SuperFastHash"], "call_depth": 1, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 0}, "3": {"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_PASS", "Return": 2, "Description": "The XDP_PASS return code means that the packet is allowed to be passed up to the kernel\u2019s networking stack. Meaning, the current CPU that was processing this packet now allocates a skb, populates it, and passes it onwards into the GRO engine. This would be equivalent to the default packet handling behavior without XDP.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 134, "endLine": 202, "File": "/home/palani/github/ebpf-projects-annotations/projects/suricata-master/original_source/ebpf/xdp_lb.c", "funcName": "filter_gre", "developer_inline_comments": [{"start_line": 161, "end_line": 161, "text": "/* Update offset to skip ERPSAN header if we have one */"}, {"start_line": 174, "end_line": 174, "text": "/* we have now data starting at Ethernet header */"}, {"start_line": 177, "end_line": 177, "text": "/* we want to hash on IP so we need to get to ip hdr */"}, {"start_line": 183, "end_line": 184, "text": "/* we need to increase offset and update protocol\n     * in the case we have VLANs */"}, {"start_line": 195, "end_line": 195, "text": "/* proto should now be IP style */"}], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *ctx", " void *data", " __u64 nh_off", " void *data_end"], "output": "staticint__always_inline", "helper": ["XDP_PASS"], "compatibleHookpoints": ["xdp"], "source": ["static int __always_inline filter_gre (struct xdp_md *ctx, void *data, __u64 nh_off, void *data_end)\n", "{\n", "    struct iphdr *iph = data + nh_off;\n", "    __u16 proto;\n", "    struct gre_hdr {\n", "        __be16 flags;\n", "        __be16 proto;\n", "    }\n", "    ;\n", "    nh_off += sizeof (struct iphdr);\n", "    struct gre_hdr *grhdr = (struct gre_hdr *) (iph + 1);\n", "    if ((void *) (grhdr + 1) > data_end)\n", "        return XDP_PASS;\n", "    if (grhdr->flags & (GRE_VERSION | GRE_ROUTING))\n", "        return XDP_PASS;\n", "    nh_off += 4;\n", "    proto = grhdr->proto;\n", "    if (grhdr->flags & GRE_CSUM)\n", "        nh_off += 4;\n", "    if (grhdr->flags & GRE_KEY)\n", "        nh_off += 4;\n", "    if (grhdr->flags & GRE_SEQ)\n", "        nh_off += 4;\n", "    if (proto == __constant_htons (ETH_P_ERSPAN)) {\n", "        nh_off += 8;\n", "    }\n", "    if (data + nh_off > data_end)\n", "        return XDP_PASS;\n", "    if (bpf_xdp_adjust_head (ctx, 0 + nh_off))\n", "        return XDP_PASS;\n", "    data = (void *) (long) ctx->data;\n", "    data_end = (void *) (long) ctx->data_end;\n", "    struct ethhdr *eth = data;\n", "    proto = eth->h_proto;\n", "    nh_off = sizeof (*eth);\n", "    if (data + nh_off > data_end)\n", "        return XDP_PASS;\n", "    if (proto == __constant_htons (ETH_P_8021Q)) {\n", "        struct vlan_hdr *vhdr = (struct vlan_hdr *) (data + nh_off);\n", "        if ((void *) (vhdr + 1) > data_end)\n", "            return XDP_PASS;\n", "        proto = vhdr->h_vlan_encapsulated_proto;\n", "        nh_off += sizeof (struct vlan_hdr);\n", "    }\n", "    if (data + nh_off > data_end)\n", "        return XDP_PASS;\n", "    if (proto == __constant_htons (ETH_P_IP)) {\n", "        return hash_ipv4 (data + nh_off, data_end);\n", "    }\n", "    else if (proto == __constant_htons (ETH_P_IPV6)) {\n", "        return hash_ipv6 (data + nh_off, data_end);\n", "    }\n", "    else\n", "        return XDP_PASS;\n", "}\n"], "called_function_list": ["hash_ipv4", "hash_ipv6"], "call_depth": 2, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 0}, "4": {"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_PASS", "Return": 2, "Description": "The XDP_PASS return code means that the packet is allowed to be passed up to the kernel\u2019s networking stack. Meaning, the current CPU that was processing this packet now allocates a skb, populates it, and passes it onwards into the GRO engine. This would be equivalent to the default packet handling behavior without XDP.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 204, "endLine": 214, "File": "/home/palani/github/ebpf-projects-annotations/projects/suricata-master/original_source/ebpf/xdp_lb.c", "funcName": "filter_ipv4", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *ctx", " void *data", " __u64 nh_off", " void *data_end"], "output": "staticint__always_inline", "helper": ["XDP_PASS"], "compatibleHookpoints": ["xdp"], "source": ["static int __always_inline filter_ipv4 (struct xdp_md *ctx, void *data, __u64 nh_off, void *data_end)\n", "{\n", "    struct iphdr *iph = data + nh_off;\n", "    if ((void *) (iph + 1) > data_end)\n", "        return XDP_PASS;\n", "    if (iph->protocol == IPPROTO_GRE) {\n", "        return filter_gre (ctx, data, nh_off, data_end);\n", "    }\n", "    return hash_ipv4 (data + nh_off, data_end);\n", "}\n"], "called_function_list": ["SuperFastHash", "hash_ipv4", "get_sport", "filter_gre", "get_dport"], "call_depth": 1, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 0}, "5": {"capabilities": [{"capability": "pkt_stop_processing_drop_packet", "pkt_stop_processing_drop_packet": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_ABORTED", "Return": 0, "Description": "which serves denoting an exception like state from the program and has the same behavior as XDP_DROP only that XDP_ABORTED passes the trace_xdp_exception tracepoint which can be additionally monitored to detect misbehavior.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_stop_processing_drop_packet"]}, {"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_DROP", "Return": 1, "Description": "will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_stop_processing_drop_packet"]}]}, {"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}, {"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_PASS", "Return": 2, "Description": "The XDP_PASS return code means that the packet is allowed to be passed up to the kernel\u2019s networking stack. Meaning, the current CPU that was processing this packet now allocates a skb, populates it, and passes it onwards into the GRO engine. This would be equivalent to the default packet handling behavior without XDP.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 235, "endLine": 377, "File": "/home/palani/github/ebpf-projects-annotations/projects/suricata-master/original_source/ebpf/xdp_filter.c", "funcName": "filter_ipv4", "developer_inline_comments": [{"start_line": 324, "end_line": 324, "text": "/* drop application data for tls 1.2 */"}, {"start_line": 325, "end_line": 325, "text": "/* FIXME better parsing */"}, {"start_line": 354, "end_line": 354, "text": "/* IP-pairs + protocol (UDP/TCP/ICMP) hit same CPU */"}, {"start_line": 370, "end_line": 370, "text": "/* IP-pairs + protocol (UDP/TCP/ICMP) hit same CPU */"}], "updateMaps": [], "readMaps": ["  flow_table_v4", "  tx_peer_int", " cpus_count", "  tls_bypass_count", "  cpus_available"], "input": ["struct xdp_md *ctx", " void *data", " __u64 nh_off", " void *data_end", " __u16 vlan0", " __u16 vlan1"], "output": "staticint__always_inline", "helper": ["XDP_ABORTED", "bpf_redirect_map", "bpf_redirect", "bpf_trace_printk", "XDP_DROP", "bpf_map_lookup_elem", "XDP_PASS"], "compatibleHookpoints": ["xdp"], "source": ["static int __always_inline filter_ipv4 (struct xdp_md *ctx, void *data, __u64 nh_off, void *data_end, __u16 vlan0, __u16 vlan1)\n", "{\n", "    struct iphdr *iph = data + nh_off;\n", "    int dport;\n", "    int sport;\n", "    struct flowv4_keys tuple;\n", "    struct pair *value;\n", "\n", "#if BUILD_CPUMAP || GOT_TX_PEER\n", "    __u32 key0 = 0;\n", "\n", "#endif\n", "\n", "#if ENCRYPTED_TLS_BYPASS\n", "    __u32 key1 = 0;\n", "    __u32 *tls_count = NULL;\n", "\n", "#endif\n", "\n", "#if BUILD_CPUMAP\n", "    __u32 cpu_dest;\n", "    __u32 *cpu_max = bpf_map_lookup_elem (&cpus_count, &key0);\n", "    __u32 *cpu_selected;\n", "    __u32 cpu_hash;\n", "\n", "#endif\n", "\n", "#if GOT_TX_PEER\n", "    int *iface_peer;\n", "    int tx_port = 0;\n", "\n", "#endif\n", "    if ((void *) (iph + 1) > data_end)\n", "        return XDP_PASS;\n", "    if (iph->protocol == IPPROTO_TCP) {\n", "        tuple.ip_proto = 1;\n", "    }\n", "    else {\n", "        tuple.ip_proto = 0;\n", "    }\n", "    tuple.src = iph->saddr;\n", "    tuple.dst = iph->daddr;\n", "    dport = get_dport (iph + 1, data_end, iph -> protocol);\n", "    if (dport == -1)\n", "        return XDP_PASS;\n", "    sport = get_sport (iph + 1, data_end, iph -> protocol);\n", "    if (sport == -1)\n", "        return XDP_PASS;\n", "    tuple.port16[0] = (__u16) sport;\n", "    tuple.port16[1] = (__u16) dport;\n", "    tuple.vlan0 = vlan0;\n", "    tuple.vlan1 = vlan1;\n", "    value = bpf_map_lookup_elem (& flow_table_v4, & tuple);\n", "\n", "#if 0\n", "    {\n", "        char fmt [] = \"Current flow src: %u:%d\\n\";\n", "        char fmt1 [] = \"Current flow dst: %u:%d\\n\";\n", "        bpf_trace_printk (fmt, sizeof (fmt), tuple.src, tuple.port16[0]);\n", "        bpf_trace_printk (fmt1, sizeof (fmt1), tuple.dst, tuple.port16[1]);\n", "    }\n", "\n", "#endif\n", "    if (value) {\n", "\n", "#if 0\n", "        char fmt [] = \"Found flow v4: %u %d -> %d\\n\";\n", "        bpf_trace_printk (fmt, sizeof (fmt), tuple.src, sport, dport);\n", "        char fmt [] = \"Data: t:%lu p:%lu n:%lu\\n\";\n", "        bpf_trace_printk (fmt, sizeof (fmt), value->time, value->packets, value->bytes);\n", "\n", "#endif\n", "\n", "#if USE_PERCPU_HASH\n", "        value->packets++;\n", "        value->bytes += data_end - data;\n", "\n", "#else\n", "        __sync_fetch_and_add (&value->packets, 1);\n", "        __sync_fetch_and_add (&value->bytes, data_end - data);\n", "\n", "#endif\n", "\n", "#if GOT_TX_PEER\n", "        iface_peer = bpf_map_lookup_elem (& tx_peer_int, & key0);\n", "        if (!iface_peer) {\n", "            return XDP_DROP;\n", "        }\n", "        else {\n", "            return bpf_redirect_map (&tx_peer, tx_port, 0);\n", "        }\n", "\n", "#else\n", "        return XDP_DROP;\n", "\n", "#endif\n", "    }\n", "\n", "#if ENCRYPTED_TLS_BYPASS\n", "    if ((dport == __constant_ntohs (443)) || (sport == __constant_ntohs (443))) {\n", "        __u8 *app_data;\n", "        nh_off += sizeof (struct iphdr) + sizeof (struct tcphdr);\n", "        if (data_end > data + nh_off + 4) {\n", "            app_data = data + nh_off;\n", "            if (app_data[0] == 0x17 && app_data[1] == 0x3 && app_data[2] == 0x3) {\n", "                tls_count = bpf_map_lookup_elem (& tls_bypass_count, & key1);\n", "                if (tls_count) {\n", "\n", "#if USE_PERCPU_HASH\n", "                    tls_count++;\n", "\n", "#else\n", "                    __sync_fetch_and_add (tls_count, 1);\n", "\n", "#endif\n", "                }\n", "\n", "#if GOT_TX_PEER\n", "                iface_peer = bpf_map_lookup_elem (& tx_peer_int, & key0);\n", "                if (!iface_peer) {\n", "                    return XDP_DROP;\n", "                }\n", "                else {\n", "                    return bpf_redirect_map (&tx_peer, tx_port, 0);\n", "                }\n", "\n", "#else\n", "                return XDP_DROP;\n", "\n", "#endif\n", "            }\n", "        }\n", "    }\n", "\n", "#endif\n", "\n", "#if BUILD_CPUMAP\n", "    cpu_hash = tuple.src + tuple.dst;\n", "    cpu_hash = SuperFastHash ((char *) & cpu_hash, 4, INITVAL + iph -> protocol);\n", "    if (cpu_max && *cpu_max) {\n", "        cpu_dest = cpu_hash % *cpu_max;\n", "        cpu_selected = bpf_map_lookup_elem (& cpus_available, & cpu_dest);\n", "        if (!cpu_selected)\n", "            return XDP_ABORTED;\n", "        cpu_dest = *cpu_selected;\n", "        return bpf_redirect_map (&cpu_map, cpu_dest, 0);\n", "    }\n", "    else {\n", "        return XDP_PASS;\n", "    }\n", "\n", "#else\n", "\n", "#if RSS_QUEUE_NUMBERS\n", "    __u32 xdp_hash = tuple.src + tuple.dst;\n", "    xdp_hash = SuperFastHash ((char *) & xdp_hash, 4, INITVAL + iph -> protocol);\n", "    ctx->rx_queue_index = xdp_hash % RSS_QUEUE_NUMBERS;\n", "\n", "#endif\n", "    return XDP_PASS;\n", "\n", "#endif\n", "}\n"], "called_function_list": ["SuperFastHash", "hash_ipv4", "get_sport", "filter_gre", "get_dport"], "call_depth": 1, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 0}, "6": {"capabilities": [], "helperCallParams": {}, "startLine": 216, "endLine": 220, "File": "/home/palani/github/ebpf-projects-annotations/projects/suricata-master/original_source/ebpf/xdp_lb.c", "funcName": "filter_ipv6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *ctx", " void *data", " __u64 nh_off", " void *data_end"], "output": "staticint__always_inline", "helper": [], "compatibleHookpoints": ["xdp", "raw_tracepoint", "cgroup_sysctl", "cgroup_sock_addr", "cgroup_sock", "socket_filter", "lwt_xmit", "sk_skb", "tracepoint", "sched_act", "cgroup_skb", "sched_cls", "sk_msg", "raw_tracepoint_writable", "perf_event", "sk_reuseport", "lwt_out", "cgroup_device", "flow_dissector", "sock_ops", "kprobe", "lwt_seg6local", "lwt_in"], "source": ["static int __always_inline filter_ipv6 (struct xdp_md *ctx, void *data, __u64 nh_off, void *data_end)\n", "{\n", "    struct ipv6hdr *ip6h = data + nh_off;\n", "    return hash_ipv6 ((void *) ip6h, data_end);\n", "}\n"], "called_function_list": ["SuperFastHash", "hash_ipv6", "get_sport", "get_dport"], "call_depth": 1, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 0}, "7": {"capabilities": [{"capability": "pkt_stop_processing_drop_packet", "pkt_stop_processing_drop_packet": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_ABORTED", "Return": 0, "Description": "which serves denoting an exception like state from the program and has the same behavior as XDP_DROP only that XDP_ABORTED passes the trace_xdp_exception tracepoint which can be additionally monitored to detect misbehavior.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_stop_processing_drop_packet"]}, {"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_DROP", "Return": 1, "Description": "will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_stop_processing_drop_packet"]}]}, {"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}, {"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_PASS", "Return": 2, "Description": "The XDP_PASS return code means that the packet is allowed to be passed up to the kernel\u2019s networking stack. Meaning, the current CPU that was processing this packet now allocates a skb, populates it, and passes it onwards into the GRO engine. This would be equivalent to the default packet handling behavior without XDP.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 379, "endLine": 483, "File": "/home/palani/github/ebpf-projects-annotations/projects/suricata-master/original_source/ebpf/xdp_filter.c", "funcName": "filter_ipv6", "developer_inline_comments": [{"start_line": 453, "end_line": 453, "text": "/* IP-pairs + protocol (UDP/TCP/ICMP) hit same CPU */"}, {"start_line": 472, "end_line": 472, "text": "/* IP-pairs + protocol (UDP/TCP/ICMP) hit same CPU */"}], "updateMaps": [], "readMaps": ["  cpus_available", " cpus_count", "  flow_table_v6", "  tx_peer_int"], "input": ["struct xdp_md *ctx", " void *data", " __u64 nh_off", " void *data_end", " __u16 vlan0", " __u16 vlan1"], "output": "staticint__always_inline", "helper": ["XDP_ABORTED", "bpf_redirect_map", "bpf_redirect", "bpf_trace_printk", "XDP_DROP", "bpf_map_lookup_elem", "XDP_PASS"], "compatibleHookpoints": ["xdp"], "source": ["static int __always_inline filter_ipv6 (struct xdp_md *ctx, void *data, __u64 nh_off, void *data_end, __u16 vlan0, __u16 vlan1)\n", "{\n", "    struct ipv6hdr *ip6h = data + nh_off;\n", "    int dport;\n", "    int sport;\n", "    struct flowv6_keys tuple;\n", "    struct pair *value;\n", "\n", "#if BUILD_CPUMAP || GOT_TX_PEER\n", "    __u32 key0 = 0;\n", "\n", "#endif\n", "\n", "#if BUILD_CPUMAP\n", "    __u32 cpu_dest;\n", "    int *cpu_max = bpf_map_lookup_elem (&cpus_count, &key0);\n", "    __u32 *cpu_selected;\n", "    __u32 cpu_hash;\n", "\n", "#endif\n", "\n", "#if GOT_TX_PEER\n", "    int tx_port = 0;\n", "    int *iface_peer;\n", "\n", "#endif\n", "    if ((void *) (ip6h + 1) > data_end)\n", "        return 0;\n", "    if (!((ip6h->nexthdr == IPPROTO_UDP) || (ip6h->nexthdr == IPPROTO_TCP)))\n", "        return XDP_PASS;\n", "    dport = get_dport (ip6h + 1, data_end, ip6h -> nexthdr);\n", "    if (dport == -1)\n", "        return XDP_PASS;\n", "    sport = get_sport (ip6h + 1, data_end, ip6h -> nexthdr);\n", "    if (sport == -1)\n", "        return XDP_PASS;\n", "    if (ip6h->nexthdr == IPPROTO_TCP) {\n", "        tuple.ip_proto = 1;\n", "    }\n", "    else {\n", "        tuple.ip_proto = 0;\n", "    }\n", "    __builtin_memcpy (tuple.src, ip6h->saddr.s6_addr32, sizeof (tuple.src));\n", "    __builtin_memcpy (tuple.dst, ip6h->daddr.s6_addr32, sizeof (tuple.dst));\n", "    tuple.port16[0] = sport;\n", "    tuple.port16[1] = dport;\n", "    tuple.vlan0 = vlan0;\n", "    tuple.vlan1 = vlan1;\n", "    value = bpf_map_lookup_elem (& flow_table_v6, & tuple);\n", "    if (value) {\n", "\n", "#if 0\n", "        char fmt6 [] = \"Found IPv6 flow: %d -> %d\\n\";\n", "        bpf_trace_printk (fmt6, sizeof (fmt6), sport, dport);\n", "\n", "#endif\n", "\n", "#if USE_PERCPU_HASH\n", "        value->packets++;\n", "        value->bytes += data_end - data;\n", "\n", "#else\n", "        __sync_fetch_and_add (&value->packets, 1);\n", "        __sync_fetch_and_add (&value->bytes, data_end - data);\n", "\n", "#endif\n", "\n", "#if GOT_TX_PEER\n", "        iface_peer = bpf_map_lookup_elem (& tx_peer_int, & key0);\n", "        if (!iface_peer) {\n", "            return XDP_DROP;\n", "        }\n", "        else {\n", "            return bpf_redirect_map (&tx_peer, tx_port, 0);\n", "        }\n", "\n", "#else\n", "        return XDP_DROP;\n", "\n", "#endif\n", "    }\n", "\n", "#if BUILD_CPUMAP\n", "    cpu_hash = tuple.src[0] + tuple.dst[0];\n", "    cpu_hash += tuple.src[1] + tuple.dst[1];\n", "    cpu_hash += tuple.src[2] + tuple.dst[2];\n", "    cpu_hash += tuple.src[3] + tuple.dst[3];\n", "    cpu_hash = SuperFastHash ((char *) & cpu_hash, 4, INITVAL);\n", "    if (cpu_max && *cpu_max) {\n", "        cpu_dest = cpu_hash % *cpu_max;\n", "        cpu_selected = bpf_map_lookup_elem (& cpus_available, & cpu_dest);\n", "        if (!cpu_selected)\n", "            return XDP_ABORTED;\n", "        cpu_dest = *cpu_selected;\n", "        return bpf_redirect_map (&cpu_map, cpu_dest, 0);\n", "    }\n", "    else {\n", "        return XDP_PASS;\n", "    }\n", "\n", "#else\n", "\n", "#if RSS_QUEUE_NUMBERS\n", "    __u32 xdp_hash = tuple.src[0] + tuple.dst[0];\n", "    xdp_hash += tuple.src[1] + tuple.dst[1];\n", "    xdp_hash += tuple.src[2] + tuple.dst[2];\n", "    xdp_hash += tuple.src[3] + tuple.dst[3];\n", "    xdp_hash = SuperFastHash ((char *) & xdp_hash, 4, INITVAL);\n", "    ctx->rx_queue_index = xdp_hash % RSS_QUEUE_NUMBERS;\n", "\n", "#endif\n", "    return XDP_PASS;\n", "\n", "#endif\n", "}\n"], "called_function_list": ["SuperFastHash", "hash_ipv6", "get_sport", "get_dport"], "call_depth": 1, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 0}, "8": {"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_PASS", "Return": 2, "Description": "The XDP_PASS return code means that the packet is allowed to be passed up to the kernel\u2019s networking stack. Meaning, the current CPU that was processing this packet now allocates a skb, populates it, and passes it onwards into the GRO engine. This would be equivalent to the default packet handling behavior without XDP.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 222, "endLine": 267, "File": "/home/palani/github/ebpf-projects-annotations/projects/suricata-master/original_source/ebpf/xdp_lb.c", "funcName": "xdp_loadfilter", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *ctx"], "output": "\\xdp\\)", "helper": ["XDP_PASS", "bpf_trace_printk"], "compatibleHookpoints": ["xdp"], "source": ["int SEC (\"xdp\") xdp_loadfilter (struct xdp_md *ctx)\n", "{\n", "    void *data_end = (void *) (long) ctx->data_end;\n", "    void *data = (void *) (long) ctx->data;\n", "    struct ethhdr *eth = data;\n", "    __u16 h_proto;\n", "    __u64 nh_off;\n", "    nh_off = sizeof (*eth);\n", "    if (data + nh_off > data_end)\n", "        return XDP_PASS;\n", "    h_proto = eth->h_proto;\n", "\n", "#if 0\n", "    if (h_proto != __constant_htons (ETH_P_IP)) {\n", "        char fmt [] = \"Current proto: %u\\n\";\n", "        bpf_trace_printk (fmt, sizeof (fmt), h_proto);\n", "    }\n", "\n", "#endif\n", "    if (h_proto == __constant_htons (ETH_P_8021Q) || h_proto == __constant_htons (ETH_P_8021AD)) {\n", "        struct vlan_hdr *vhdr;\n", "        vhdr = data + nh_off;\n", "        nh_off += sizeof (struct vlan_hdr);\n", "        if (data + nh_off > data_end)\n", "            return XDP_PASS;\n", "        h_proto = vhdr->h_vlan_encapsulated_proto;\n", "    }\n", "    if (h_proto == __constant_htons (ETH_P_8021Q) || h_proto == __constant_htons (ETH_P_8021AD)) {\n", "        struct vlan_hdr *vhdr;\n", "        vhdr = data + nh_off;\n", "        nh_off += sizeof (struct vlan_hdr);\n", "        if (data + nh_off > data_end)\n", "            return XDP_PASS;\n", "        h_proto = vhdr->h_vlan_encapsulated_proto;\n", "    }\n", "    if (h_proto == __constant_htons (ETH_P_IP))\n", "        return filter_ipv4 (ctx, data, nh_off, data_end);\n", "    else if (h_proto == __constant_htons (ETH_P_IPV6))\n", "        return filter_ipv6 (ctx, data, nh_off, data_end);\n", "    return XDP_PASS;\n", "}\n"], "called_function_list": ["filter_ipv6", "filter_ipv4"], "call_depth": 2, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 1}, "9": {"capabilities": [], "helperCallParams": {}, "startLine": 41, "endLine": 57, "File": "/home/palani/github/ebpf-projects-annotations/projects/suricata-master/original_source/ebpf/lb.c", "funcName": "ipv4_hash", "developer_inline_comments": [{"start_line": 1, "end_line": 16, "text": "/* Copyright (C) 2018 Open Information Security Foundation\n *\n * You can copy, redistribute or modify this Program under the terms of\n * the GNU General Public License version 2 as published by the Free\n * Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * version 2 along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n * 02110-1301, USA.\n */"}, {"start_line": 53, "end_line": 53, "text": "//char fmt2[] = \"Got hash %u\\n\";"}, {"start_line": 54, "end_line": 54, "text": "//bpf_trace_printk(fmt2, sizeof(fmt2), src + dst);"}], "updateMaps": [], "readMaps": [], "input": ["struct  __sk_buff *skb"], "output": "static__always_inlineint", "helper": ["bpf_trace_printk"], "compatibleHookpoints": ["xdp", "raw_tracepoint", "cgroup_sysctl", "cgroup_sock_addr", "cgroup_sock", "socket_filter", "lwt_xmit", "sk_skb", "tracepoint", "sched_act", "cgroup_skb", "sched_cls", "sk_msg", "raw_tracepoint_writable", "perf_event", "sk_reuseport", "lwt_out", "cgroup_device", "flow_dissector", "sock_ops", "kprobe", "lwt_seg6local", "lwt_in"], "source": ["static __always_inline int ipv4_hash (struct  __sk_buff *skb)\n", "{\n", "    __u32 nhoff;\n", "    __u32 src, dst;\n", "    nhoff = skb->cb[0];\n", "    src = load_word (skb, nhoff + offsetof (struct iphdr, saddr));\n", "    dst = load_word (skb, nhoff + offsetof (struct iphdr, daddr));\n", "\n", "#if 0\n", "    char fmt [] = \"Got addr: %x -> %x at %d\\n\";\n", "    bpf_trace_printk (fmt, sizeof (fmt), src, dst, nhoff);\n", "\n", "#endif\n", "    return src + dst;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 0}, "10": {"capabilities": [], "helperCallParams": {}, "startLine": 59, "endLine": 67, "File": "/home/palani/github/ebpf-projects-annotations/projects/suricata-master/original_source/ebpf/lb.c", "funcName": "ipv6_addr_hash", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __sk_buff *ctx", " __u64 off"], "output": "staticinline__u32", "helper": [], "compatibleHookpoints": ["xdp", "raw_tracepoint", "cgroup_sysctl", "cgroup_sock_addr", "cgroup_sock", "socket_filter", "lwt_xmit", "sk_skb", "tracepoint", "sched_act", "cgroup_skb", "sched_cls", "sk_msg", "raw_tracepoint_writable", "perf_event", "sk_reuseport", "lwt_out", "cgroup_device", "flow_dissector", "sock_ops", "kprobe", "lwt_seg6local", "lwt_in"], "source": ["static inline __u32 ipv6_addr_hash (struct  __sk_buff *ctx, __u64 off)\n", "{\n", "    __u64 w0 = load_word (ctx, off);\n", "    __u64 w1 = load_word (ctx, off + 4);\n", "    __u64 w2 = load_word (ctx, off + 8);\n", "    __u64 w3 = load_word (ctx, off + 12);\n", "    return (__u32) (w0 ^ w1 ^ w2 ^ w3);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 0}, "11": {"capabilities": [], "helperCallParams": {}, "startLine": 69, "endLine": 81, "File": "/home/palani/github/ebpf-projects-annotations/projects/suricata-master/original_source/ebpf/lb.c", "funcName": "ipv6_hash", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __sk_buff *skb"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["xdp", "raw_tracepoint", "cgroup_sysctl", "cgroup_sock_addr", "cgroup_sock", "socket_filter", "lwt_xmit", "sk_skb", "tracepoint", "sched_act", "cgroup_skb", "sched_cls", "sk_msg", "raw_tracepoint_writable", "perf_event", "sk_reuseport", "lwt_out", "cgroup_device", "flow_dissector", "sock_ops", "kprobe", "lwt_seg6local", "lwt_in"], "source": ["static __always_inline int ipv6_hash (struct  __sk_buff *skb)\n", "{\n", "    __u32 nhoff;\n", "    __u32 src_hash, dst_hash;\n", "    nhoff = skb->cb[0];\n", "    src_hash = ipv6_addr_hash (skb, nhoff + offsetof (struct ipv6hdr, saddr));\n", "    dst_hash = ipv6_addr_hash (skb, nhoff + offsetof (struct ipv6hdr, daddr));\n", "    return src_hash + dst_hash;\n", "}\n"], "called_function_list": ["ipv6_addr_hash"], "call_depth": 1, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 0}, "12": {"capabilities": [], "helperCallParams": {}, "startLine": 83, "endLine": 145, "File": "/home/palani/github/ebpf-projects-annotations/projects/suricata-master/original_source/ebpf/lb.c", "funcName": "lb", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __sk_buff *skb"], "output": "\\loadbalancer\\)", "helper": ["bpf_trace_printk"], "compatibleHookpoints": ["xdp", "raw_tracepoint", "cgroup_sysctl", "cgroup_sock_addr", "cgroup_sock", "socket_filter", "lwt_xmit", "sk_skb", "tracepoint", "sched_act", "cgroup_skb", "sched_cls", "sk_msg", "raw_tracepoint_writable", "perf_event", "sk_reuseport", "lwt_out", "cgroup_device", "flow_dissector", "sock_ops", "kprobe", "lwt_seg6local", "lwt_in"], "source": ["int  __section (\"loadbalancer\") lb (struct  __sk_buff *skb)\n", "{\n", "    __u64 nhoff = ETH_HLEN;\n", "    __u16 proto = load_half (skb, ETH_HLEN - ETH_TLEN);\n", "    __u16 ret = proto;\n", "    switch (proto) {\n", "    case ETH_P_8021Q :\n", "    case ETH_P_8021AD :\n", "        {\n", "            __u16 vproto = load_half (skb, nhoff + offsetof (struct vlan_hdr, h_vlan_encapsulated_proto));\n", "            switch (vproto) {\n", "            case ETH_P_8021AD :\n", "            case ETH_P_8021Q :\n", "                nhoff += sizeof (struct vlan_hdr);\n", "                proto = load_half (skb, nhoff + offsetof (struct vlan_hdr, h_vlan_encapsulated_proto));\n", "                break;\n", "            default :\n", "                proto = vproto;\n", "            }\n", "            nhoff += sizeof (struct vlan_hdr);\n", "            skb->cb[0] = nhoff;\n", "            switch (proto) {\n", "            case ETH_P_IP :\n", "\n", "#if 0\n", "                {\n", "                    char fmt [] = \"ipv4\\n\";\n", "                    bpf_trace_printk (fmt, sizeof (fmt));\n", "                }\n", "\n", "#endif\n", "                ret = ipv4_hash (skb);\n", "                break;\n", "            case ETH_P_IPV6 :\n", "                ret = ipv6_hash (skb);\n", "                break;\n", "            default :\n", "\n", "#if 0\n", "                {\n", "                    char fmt [] = \"Dflt VLAN proto %u\\n\";\n", "                    bpf_trace_printk (fmt, sizeof (fmt), proto);\n", "                    break;\n", "                }\n", "\n", "#else\n", "                break;\n", "\n", "#endif\n", "            }\n", "        }\n", "        break;\n", "    case ETH_P_IP :\n", "        ret = ipv4_hash (skb);\n", "        break;\n", "    case ETH_P_IPV6 :\n", "        ret = ipv6_hash (skb);\n", "        break;\n", "    default :\n", "\n", "#if 0\n", "        {\n", "            char fmt [] = \"Got proto %x\\n\";\n", "            bpf_trace_printk (fmt, sizeof (fmt), proto);\n", "            break;\n", "        }\n", "\n", "#else\n", "        break;\n", "\n", "#endif\n", "    }\n", "    return ret;\n", "}\n"], "called_function_list": ["ipv4_hash", "ipv6_hash"], "call_depth": 2, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 1}, "13": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 88, "endLine": 148, "File": "/home/palani/github/ebpf-projects-annotations/projects/suricata-master/original_source/ebpf/bypass_filter.c", "funcName": "ipv4_filter", "developer_inline_comments": [{"start_line": 1, "end_line": 16, "text": "/* Copyright (C) 2018 Open Information Security Foundation\n *\n * You can copy, redistribute or modify this Program under the terms of\n * the GNU General Public License version 2 as published by the Free\n * Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * version 2 along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n * 02110-1301, USA.\n */"}, {"start_line": 30, "end_line": 30, "text": "/* vlan tracking: set it to 0 if you don't use VLAN for flow tracking */"}, {"start_line": 83, "end_line": 87, "text": "/**\n * IPv4 filter\n *\n * \\return 0 to drop packet out and -1 to accept it\n */"}, {"start_line": 99, "end_line": 99, "text": "/* only support TCP and UDP for now */"}, {"start_line": 114, "end_line": 114, "text": "/*offsetof(struct iphdr, ihl)*/"}, {"start_line": 127, "end_line": 127, "text": "//__u16 dp = tuple.port16[1];"}, {"start_line": 132, "end_line": 132, "text": "/* Test if src is in hash */"}, {"start_line": 138, "end_line": 138, "text": "//__u16 dp = tuple.port16[1];"}], "updateMaps": [], "readMaps": ["  flow_table_v4"], "input": ["struct  __sk_buff *skb", " __u16 vlan0", " __u16 vlan1"], "output": "static__always_inlineint", "helper": ["bpf_map_lookup_elem", "bpf_trace_printk"], "compatibleHookpoints": ["xdp", "raw_tracepoint", "cgroup_sysctl", "cgroup_sock_addr", "cgroup_sock", "socket_filter", "lwt_xmit", "tracepoint", "sk_skb", "sched_act", "cgroup_skb", "sched_cls", "sk_msg", "raw_tracepoint_writable", "perf_event", "sk_reuseport", "lwt_out", "cgroup_device", "flow_dissector", "sock_ops", "kprobe", "lwt_seg6local", "lwt_in"], "source": ["static __always_inline int ipv4_filter (struct  __sk_buff *skb, __u16 vlan0, __u16 vlan1)\n", "{\n", "    __u32 nhoff, verlen;\n", "    struct flowv4_keys tuple;\n", "    struct pair *value;\n", "    __u16 port;\n", "    __u8 ip_proto;\n", "    nhoff = skb->cb[0];\n", "    ip_proto = load_byte (skb, nhoff + offsetof (struct iphdr, protocol));\n", "    switch (ip_proto) {\n", "    case IPPROTO_TCP :\n", "        tuple.ip_proto = 1;\n", "        break;\n", "    case IPPROTO_UDP :\n", "        tuple.ip_proto = 0;\n", "        break;\n", "    default :\n", "        return -1;\n", "    }\n", "    tuple.src = load_word (skb, nhoff + offsetof (struct iphdr, saddr));\n", "    tuple.dst = load_word (skb, nhoff + offsetof (struct iphdr, daddr));\n", "    verlen = load_byte (skb, nhoff + 0);\n", "    nhoff += (verlen & 0xF) << 2;\n", "    tuple.ports = load_word (skb, nhoff);\n", "    port = tuple.port16[1];\n", "    tuple.port16[1] = tuple.port16[0];\n", "    tuple.port16[0] = port;\n", "    tuple.vlan0 = vlan0;\n", "    tuple.vlan1 = vlan1;\n", "\n", "#if 0\n", "    if ((tuple.port16[0] == 22) || (tuple.port16[1] == 22)) {\n", "        __u16 sp = tuple.port16[0];\n", "        char fmt [] = \"Parsed SSH flow: %u %d -> %u\\n\";\n", "        bpf_trace_printk (fmt, sizeof (fmt), tuple.src, sp, tuple.dst);\n", "    }\n", "\n", "#endif\n", "    value = bpf_map_lookup_elem (& flow_table_v4, & tuple);\n", "    if (value) {\n", "\n", "#if 0\n", "        {\n", "            __u16 sp = tuple.port16[0];\n", "            char bfmt [] = \"Found flow: %u %d -> %u\\n\";\n", "            bpf_trace_printk (bfmt, sizeof (bfmt), tuple.src, sp, tuple.dst);\n", "        }\n", "\n", "#endif\n", "        value->packets++;\n", "        value->bytes += skb->len;\n", "        return 0;\n", "    }\n", "    return -1;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 0}, "14": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 46, "endLine": 81, "File": "/home/palani/github/ebpf-projects-annotations/projects/suricata-master/original_source/ebpf/filter.c", "funcName": "ipv4_filter", "developer_inline_comments": [{"start_line": 1, "end_line": 16, "text": "/* Copyright (C) 2018 Open Information Security Foundation\n *\n * You can copy, redistribute or modify this Program under the terms of\n * the GNU General Public License version 2 as published by the Free\n * Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * version 2 along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n * 02110-1301, USA.\n */"}], "updateMaps": [], "readMaps": ["  ipv4_drop"], "input": ["struct  __sk_buff *skb"], "output": "static__always_inlineint", "helper": ["bpf_map_lookup_elem", "bpf_trace_printk"], "compatibleHookpoints": ["xdp", "raw_tracepoint", "cgroup_sysctl", "cgroup_sock_addr", "cgroup_sock", "socket_filter", "lwt_xmit", "tracepoint", "sk_skb", "sched_act", "cgroup_skb", "sched_cls", "sk_msg", "raw_tracepoint_writable", "perf_event", "sk_reuseport", "lwt_out", "cgroup_device", "flow_dissector", "sock_ops", "kprobe", "lwt_seg6local", "lwt_in"], "source": ["static __always_inline int ipv4_filter (struct  __sk_buff *skb)\n", "{\n", "    __u32 nhoff;\n", "    __u32 *value;\n", "    __u32 ip = 0;\n", "    nhoff = skb->cb[0];\n", "    ip = load_word (skb, nhoff + offsetof (struct iphdr, saddr));\n", "    value = bpf_map_lookup_elem (& ipv4_drop, & ip);\n", "    if (value) {\n", "\n", "#if DEBUG\n", "        char fmt [] = \"Found value for saddr: %u\\n\";\n", "        bpf_trace_printk (fmt, sizeof (fmt), value);\n", "\n", "#endif\n", "        *value = *value + 1;\n", "        return 0;\n", "    }\n", "    ip = load_word (skb, nhoff + offsetof (struct iphdr, daddr));\n", "    value = bpf_map_lookup_elem (& ipv4_drop, & ip);\n", "    if (value) {\n", "\n", "#if DEBUG\n", "        char fmt [] = \"Found value for daddr: %u\\n\";\n", "        bpf_trace_printk (fmt, sizeof (fmt), value);\n", "\n", "#endif\n", "        *value = *value + 1;\n", "        return 0;\n", "    }\n", "\n", "#if DEBUG\n", "    char fmt [] = \"Nothing so ok\\n\";\n", "    bpf_trace_printk (fmt, sizeof (fmt));\n", "\n", "#endif\n", "    return -1;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 0}, "15": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 155, "endLine": 210, "File": "/home/palani/github/ebpf-projects-annotations/projects/suricata-master/original_source/ebpf/bypass_filter.c", "funcName": "ipv6_filter", "developer_inline_comments": [{"start_line": 150, "end_line": 154, "text": "/**\n * IPv6 filter\n *\n * \\return 0 to drop packet out and -1 to accept it\n */"}, {"start_line": 165, "end_line": 165, "text": "/* get next header */"}, {"start_line": 168, "end_line": 168, "text": "/* only support direct TCP and UDP for now */"}, {"start_line": 189, "end_line": 189, "text": "/* Parse TCP */"}, {"start_line": 190, "end_line": 190, "text": "/* IPV6_HEADER_LEN */"}, {"start_line": 198, "end_line": 198, "text": "//char fmt[] = \"Now Got IPv6 port %u and %u\\n\";"}, {"start_line": 199, "end_line": 199, "text": "//bpf_trace_printk(fmt, sizeof(fmt), tuple.port16[0], tuple.port16[1]);"}, {"start_line": 200, "end_line": 200, "text": "/* Test if src is in hash */"}, {"start_line": 203, "end_line": 203, "text": "//char fmt[] = \"Got a match IPv6: %u and %u\\n\";"}, {"start_line": 204, "end_line": 204, "text": "//bpf_trace_printk(fmt, sizeof(fmt), tuple.port16[0], tuple.port16[1]);"}], "updateMaps": [], "readMaps": ["  flow_table_v6"], "input": ["struct  __sk_buff *skb", " __u16 vlan0", " __u16 vlan1"], "output": "static__always_inlineint", "helper": ["bpf_map_lookup_elem"], "compatibleHookpoints": ["xdp", "raw_tracepoint", "cgroup_sysctl", "cgroup_sock_addr", "cgroup_sock", "socket_filter", "lwt_xmit", "sk_skb", "tracepoint", "sched_act", "cgroup_skb", "sched_cls", "sk_msg", "raw_tracepoint_writable", "perf_event", "sk_reuseport", "lwt_out", "cgroup_device", "flow_dissector", "sock_ops", "kprobe", "lwt_seg6local", "lwt_in"], "source": ["static __always_inline int ipv6_filter (struct  __sk_buff *skb, __u16 vlan0, __u16 vlan1)\n", "{\n", "    __u32 nhoff;\n", "    __u8 nhdr;\n", "    struct flowv6_keys tuple;\n", "    struct pair *value;\n", "    __u16 port;\n", "    nhoff = skb->cb[0];\n", "    nhdr = load_byte (skb, nhoff + offsetof (struct ipv6hdr, nexthdr));\n", "    switch (nhdr) {\n", "    case IPPROTO_TCP :\n", "        tuple.ip_proto = 1;\n", "        break;\n", "    case IPPROTO_UDP :\n", "        tuple.ip_proto = 0;\n", "        break;\n", "    default :\n", "        return -1;\n", "    }\n", "    tuple.src[0] = load_word (skb, nhoff + offsetof (struct ipv6hdr, saddr));\n", "    tuple.src[1] = load_word (skb, nhoff + offsetof (struct ipv6hdr, saddr) + 4);\n", "    tuple.src[2] = load_word (skb, nhoff + offsetof (struct ipv6hdr, saddr) + 8);\n", "    tuple.src[3] = load_word (skb, nhoff + offsetof (struct ipv6hdr, saddr) + 12);\n", "    tuple.dst[0] = load_word (skb, nhoff + offsetof (struct ipv6hdr, daddr));\n", "    tuple.dst[1] = load_word (skb, nhoff + offsetof (struct ipv6hdr, daddr) + 4);\n", "    tuple.dst[2] = load_word (skb, nhoff + offsetof (struct ipv6hdr, daddr) + 8);\n", "    tuple.dst[3] = load_word (skb, nhoff + offsetof (struct ipv6hdr, daddr) + 12);\n", "    tuple.ports = load_word (skb, nhoff + 40);\n", "    port = tuple.port16[1];\n", "    tuple.port16[1] = tuple.port16[0];\n", "    tuple.port16[0] = port;\n", "    tuple.vlan0 = vlan0;\n", "    tuple.vlan1 = vlan1;\n", "    value = bpf_map_lookup_elem (& flow_table_v6, & tuple);\n", "    if (value) {\n", "        value->packets++;\n", "        value->bytes += skb->len;\n", "        return 0;\n", "    }\n", "    return -1;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 0}, "16": {"capabilities": [], "helperCallParams": {}, "startLine": 83, "endLine": 86, "File": "/home/palani/github/ebpf-projects-annotations/projects/suricata-master/original_source/ebpf/filter.c", "funcName": "ipv6_filter", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __sk_buff *skb"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["xdp", "raw_tracepoint", "cgroup_sysctl", "cgroup_sock_addr", "cgroup_sock", "socket_filter", "lwt_xmit", "sk_skb", "tracepoint", "sched_act", "cgroup_skb", "sched_cls", "sk_msg", "raw_tracepoint_writable", "perf_event", "sk_reuseport", "lwt_out", "cgroup_device", "flow_dissector", "sock_ops", "kprobe", "lwt_seg6local", "lwt_in"], "source": ["static __always_inline int ipv6_filter (struct  __sk_buff *skb)\n", "{\n", "    return -1;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 0}, "17": {"capabilities": [], "helperCallParams": {}, "startLine": 220, "endLine": 256, "File": "/home/palani/github/ebpf-projects-annotations/projects/suricata-master/original_source/ebpf/bypass_filter.c", "funcName": "hashfilter", "developer_inline_comments": [{"start_line": 212, "end_line": 219, "text": "/**\n * filter function\n *\n * It is loaded in kernel by Suricata that uses the section name specified\n * by the SEC call to find it in the Elf binary object and load it.\n *\n * \\return 0 to drop packet out and -1 to accept it\n */"}, {"start_line": 231, "end_line": 231, "text": "/* one vlan layer is stripped by OS so get vlan 1 at first pass */"}], "updateMaps": [], "readMaps": [], "input": ["struct  __sk_buff *skb"], "output": "\\filter\\)", "helper": ["bpf_trace_printk"], "compatibleHookpoints": ["xdp", "raw_tracepoint", "cgroup_sysctl", "cgroup_sock_addr", "cgroup_sock", "socket_filter", "lwt_xmit", "sk_skb", "tracepoint", "sched_act", "cgroup_skb", "sched_cls", "sk_msg", "raw_tracepoint_writable", "perf_event", "sk_reuseport", "lwt_out", "cgroup_device", "flow_dissector", "sock_ops", "kprobe", "lwt_seg6local", "lwt_in"], "source": ["int SEC (\"filter\") hashfilter (struct  __sk_buff *skb)\n", "{\n", "    __u32 nhoff = ETH_HLEN;\n", "    __u16 proto = load_half (skb, offsetof (struct ethhdr, h_proto));\n", "    __u16 vlan0 = skb->vlan_tci & 0x0fff;\n", "    __u16 vlan1 = 0;\n", "    if (proto == ETH_P_8021AD || proto == ETH_P_8021Q) {\n", "        proto = load_half (skb, nhoff + offsetof (struct vlan_hdr, h_vlan_encapsulated_proto));\n", "\n", "#if VLAN_TRACKING\n", "        vlan1 = load_half (skb, nhoff + offsetof (struct vlan_hdr, h_vlan_TCI)) & 0x0fff;\n", "\n", "#endif\n", "        nhoff += sizeof (struct vlan_hdr);\n", "    }\n", "    skb->cb[0] = nhoff;\n", "    switch (proto) {\n", "    case ETH_P_IP :\n", "        return ipv4_filter (skb, vlan0, vlan1);\n", "    case ETH_P_IPV6 :\n", "        return ipv6_filter (skb, vlan0, vlan1);\n", "    default :\n", "\n", "#if 0\n", "        {\n", "            char fmt [] = \"Got proto %u\\n\";\n", "            bpf_trace_printk (fmt, sizeof (fmt), h_proto);\n", "            break;\n", "        }\n", "\n", "#else\n", "        break;\n", "\n", "#endif\n", "    }\n", "    return -1;\n", "}\n"], "called_function_list": ["ipv4_filter", "ipv6_filter"], "call_depth": 1, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 1}, "18": {"capabilities": [], "helperCallParams": {}, "startLine": 25, "endLine": 36, "File": "/home/palani/github/ebpf-projects-annotations/projects/suricata-master/original_source/ebpf/vlan_filter.c", "funcName": "hashfilter", "developer_inline_comments": [{"start_line": 1, "end_line": 16, "text": "/* Copyright (C) 2018 Open Information Security Foundation\n *\n * You can copy, redistribute or modify this Program under the terms of\n * the GNU General Public License version 2 as published by the Free\n * Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * version 2 along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n * 02110-1301, USA.\n */"}, {"start_line": 27, "end_line": 27, "text": "/* accept VLAN 2 and 4 and drop the rest */"}], "updateMaps": [], "readMaps": [], "input": ["struct  __sk_buff *skb"], "output": "\\filter\\)", "helper": [], "compatibleHookpoints": ["xdp", "raw_tracepoint", "cgroup_sysctl", "cgroup_sock_addr", "cgroup_sock", "socket_filter", "lwt_xmit", "sk_skb", "tracepoint", "sched_act", "cgroup_skb", "sched_cls", "sk_msg", "raw_tracepoint_writable", "perf_event", "sk_reuseport", "lwt_out", "cgroup_device", "flow_dissector", "sock_ops", "kprobe", "lwt_seg6local", "lwt_in"], "source": ["int SEC (\"filter\") hashfilter (struct  __sk_buff *skb)\n", "{\n", "    __u16 vlan_id = skb->vlan_tci & 0x0fff;\n", "    switch (vlan_id) {\n", "    case 2 :\n", "    case 4 :\n", "        return -1;\n", "    default :\n", "        return 0;\n", "    }\n", "    return 0;\n", "}\n"], "called_function_list": ["ipv4_filter", "ipv6_filter"], "call_depth": 1, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 1}, "19": {"capabilities": [], "helperCallParams": {}, "startLine": 88, "endLine": 110, "File": "/home/palani/github/ebpf-projects-annotations/projects/suricata-master/original_source/ebpf/filter.c", "funcName": "hashfilter", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __sk_buff *skb"], "output": "\\filter\\)", "helper": [], "compatibleHookpoints": ["xdp", "raw_tracepoint", "cgroup_sysctl", "cgroup_sock_addr", "cgroup_sock", "socket_filter", "lwt_xmit", "sk_skb", "tracepoint", "sched_act", "cgroup_skb", "sched_cls", "sk_msg", "raw_tracepoint_writable", "perf_event", "sk_reuseport", "lwt_out", "cgroup_device", "flow_dissector", "sock_ops", "kprobe", "lwt_seg6local", "lwt_in"], "source": ["int SEC (\"filter\") hashfilter (struct  __sk_buff *skb)\n", "{\n", "    __u32 nhoff = ETH_HLEN;\n", "    __u16 proto = load_half (skb, offsetof (struct ethhdr, h_proto));\n", "    if (proto == ETH_P_8021AD || proto == ETH_P_8021Q) {\n", "        proto = load_half (skb, nhoff + offsetof (struct vlan_hdr, h_vlan_encapsulated_proto));\n", "        nhoff += sizeof (struct vlan_hdr);\n", "    }\n", "    skb->cb[0] = nhoff;\n", "    switch (proto) {\n", "    case ETH_P_IP :\n", "        return ipv4_filter (skb);\n", "    case ETH_P_IPV6 :\n", "        return ipv6_filter (skb);\n", "    default :\n", "        break;\n", "    }\n", "    return -1;\n", "}\n"], "called_function_list": ["ipv4_filter", "ipv6_filter"], "call_depth": 1, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 1}, "20": {"capabilities": [], "helperCallParams": {}, "startLine": 191, "endLine": 211, "File": "/home/palani/github/ebpf-projects-annotations/projects/suricata-master/original_source/ebpf/xdp_filter.c", "funcName": "get_sport", "developer_inline_comments": [{"start_line": 1, "end_line": 16, "text": "/* Copyright (C) 2018 Open Information Security Foundation\n *\n * You can copy, redistribute or modify this Program under the terms of\n * the GNU General Public License version 2 as published by the Free\n * Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * version 2 along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n * 02110-1301, USA.\n */"}, {"start_line": 36, "end_line": 36, "text": "/* Hashing initval */"}, {"start_line": 39, "end_line": 40, "text": "/* Set BUILD_CPUMAP to 0 if you want to run XDP bypass on kernel\n * older than 4.15 */"}, {"start_line": 42, "end_line": 42, "text": "/* Increase CPUMAP_MAX_CPUS if ever you have more than 64 CPUs */"}, {"start_line": 45, "end_line": 46, "text": "/* Set to 1 to bypass encrypted packets of TLS sessions. Suricata will\n * be blind to these packets or forged packets looking alike. */"}, {"start_line": 49, "end_line": 50, "text": "/* Set it to 0 if for example you plan to use the XDP filter in a\n * network card that don't support per CPU value (like netronome) */"}, {"start_line": 52, "end_line": 52, "text": "/* Set it to 0 if your XDP subsystem don't handle XDP_REDIRECT (like netronome) */"}, {"start_line": 55, "end_line": 56, "text": "/* set to non 0 to load balance in hardware mode on RSS_QUEUE_NUMBERS queues\n * and unset BUILD_CPUMAP (number must be a power of 2 for netronome) */"}, {"start_line": 59, "end_line": 60, "text": "/* no vlan tracking: set it to 0 if you don't use VLAN for tracking. Can\n * also be used as workaround of some hardware offload issue */"}, {"start_line": 134, "end_line": 134, "text": "/* Special map type that can XDP_REDIRECT frames to another CPU */"}, {"start_line": 158, "end_line": 160, "text": "/* Map has only one element as we don't handle any sort of\n * routing for now. Key value set by user space is 0 and\n * value is the peer interface. */"}, {"start_line": 168, "end_line": 170, "text": "/* single entry to indicate if we have peer, key value\n * set in user space is 0. It is only used to see if\n * a interface has a peer we need to send the information to */"}, {"start_line": 181, "end_line": 181, "text": "/* single entry to indicate if global bypass switch is on */"}], "updateMaps": [], "readMaps": [], "input": ["void *trans_data", " void *data_end", " __u8 protocol"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["xdp", "raw_tracepoint", "cgroup_sysctl", "cgroup_sock_addr", "cgroup_sock", "socket_filter", "lwt_xmit", "sk_skb", "tracepoint", "sched_act", "cgroup_skb", "sched_cls", "sk_msg", "raw_tracepoint_writable", "perf_event", "sk_reuseport", "lwt_out", "cgroup_device", "flow_dissector", "sock_ops", "kprobe", "lwt_seg6local", "lwt_in"], "source": ["static __always_inline int get_sport (void *trans_data, void *data_end, __u8 protocol)\n", "{\n", "    struct tcphdr *th;\n", "    struct udphdr *uh;\n", "    switch (protocol) {\n", "    case IPPROTO_TCP :\n", "        th = (struct tcphdr *) trans_data;\n", "        if ((void *) (th + 1) > data_end)\n", "            return -1;\n", "        return th->source;\n", "    case IPPROTO_UDP :\n", "        uh = (struct udphdr *) trans_data;\n", "        if ((void *) (uh + 1) > data_end)\n", "            return -1;\n", "        return uh->source;\n", "    default :\n", "        return 0;\n", "    }\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 0}, "21": {"capabilities": [], "helperCallParams": {}, "startLine": 213, "endLine": 233, "File": "/home/palani/github/ebpf-projects-annotations/projects/suricata-master/original_source/ebpf/xdp_filter.c", "funcName": "get_dport", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["void *trans_data", " void *data_end", " __u8 protocol"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["xdp", "raw_tracepoint", "cgroup_sysctl", "cgroup_sock_addr", "cgroup_sock", "socket_filter", "lwt_xmit", "sk_skb", "tracepoint", "sched_act", "cgroup_skb", "sched_cls", "sk_msg", "raw_tracepoint_writable", "perf_event", "sk_reuseport", "lwt_out", "cgroup_device", "flow_dissector", "sock_ops", "kprobe", "lwt_seg6local", "lwt_in"], "source": ["static __always_inline int get_dport (void *trans_data, void *data_end, __u8 protocol)\n", "{\n", "    struct tcphdr *th;\n", "    struct udphdr *uh;\n", "    switch (protocol) {\n", "    case IPPROTO_TCP :\n", "        th = (struct tcphdr *) trans_data;\n", "        if ((void *) (th + 1) > data_end)\n", "            return -1;\n", "        return th->dest;\n", "    case IPPROTO_UDP :\n", "        uh = (struct udphdr *) trans_data;\n", "        if ((void *) (uh + 1) > data_end)\n", "            return -1;\n", "        return uh->dest;\n", "    default :\n", "        return 0;\n", "    }\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 0}, "22": {"capabilities": [{"capability": "pkt_stop_processing_drop_packet", "pkt_stop_processing_drop_packet": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_DROP", "Return": 1, "Description": "will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_stop_processing_drop_packet"]}]}, {"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}, {"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_PASS", "Return": 2, "Description": "The XDP_PASS return code means that the packet is allowed to be passed up to the kernel\u2019s networking stack. Meaning, the current CPU that was processing this packet now allocates a skb, populates it, and passes it onwards into the GRO engine. This would be equivalent to the default packet handling behavior without XDP.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 485, "endLine": 552, "File": "/home/palani/github/ebpf-projects-annotations/projects/suricata-master/original_source/ebpf/xdp_filter.c", "funcName": "xdp_hashfilter", "developer_inline_comments": [], "updateMaps": [], "readMaps": ["  global_bypass", "  tx_peer_int"], "input": ["struct xdp_md *ctx"], "output": "\\xdp\\)", "helper": ["bpf_redirect_map", "bpf_redirect", "XDP_DROP", "bpf_map_lookup_elem", "XDP_PASS"], "compatibleHookpoints": ["xdp"], "source": ["int SEC (\"xdp\") xdp_hashfilter (struct xdp_md *ctx)\n", "{\n", "    void *data_end = (void *) (long) ctx->data_end;\n", "    void *data = (void *) (long) ctx->data;\n", "    struct ethhdr *eth = data;\n", "    __u16 h_proto;\n", "    __u64 nh_off;\n", "    __u16 vlan0 = 0;\n", "    __u16 vlan1 = 0;\n", "\n", "#if USE_GLOBAL_BYPASS\n", "    int *iface_peer;\n", "    char *g_switch = 0;\n", "    char key0;\n", "    int tx_port = 0;\n", "    g_switch = bpf_map_lookup_elem (& global_bypass, & key0);\n", "    if (g_switch && *g_switch) {\n", "        iface_peer = bpf_map_lookup_elem (& tx_peer_int, & key0);\n", "        if (!iface_peer) {\n", "            return XDP_DROP;\n", "        }\n", "        else {\n", "            return bpf_redirect_map (&tx_peer, tx_port, 0);\n", "        }\n", "    }\n", "\n", "#endif\n", "    nh_off = sizeof (*eth);\n", "    if (data + nh_off > data_end)\n", "        return XDP_PASS;\n", "    h_proto = eth->h_proto;\n", "    if (h_proto == __constant_htons (ETH_P_8021Q) || h_proto == __constant_htons (ETH_P_8021AD)) {\n", "        struct vlan_hdr *vhdr;\n", "        vhdr = data + nh_off;\n", "        nh_off += sizeof (struct vlan_hdr);\n", "        if (data + nh_off > data_end)\n", "            return XDP_PASS;\n", "        h_proto = vhdr->h_vlan_encapsulated_proto;\n", "\n", "#if VLAN_TRACKING\n", "        vlan0 = vhdr->h_vlan_TCI & 0x0fff;\n", "\n", "#else\n", "        vlan0 = 0;\n", "\n", "#endif\n", "    }\n", "    if (h_proto == __constant_htons (ETH_P_8021Q) || h_proto == __constant_htons (ETH_P_8021AD)) {\n", "        struct vlan_hdr *vhdr;\n", "        vhdr = data + nh_off;\n", "        nh_off += sizeof (struct vlan_hdr);\n", "        if (data + nh_off > data_end)\n", "            return XDP_PASS;\n", "        h_proto = vhdr->h_vlan_encapsulated_proto;\n", "\n", "#if VLAN_TRACKING\n", "        vlan1 = vhdr->h_vlan_TCI & 0x0fff;\n", "\n", "#else\n", "        vlan1 = 0;\n", "\n", "#endif\n", "    }\n", "    if (h_proto == __constant_htons (ETH_P_IP))\n", "        return filter_ipv4 (ctx, data, nh_off, data_end, vlan0, vlan1);\n", "    else if (h_proto == __constant_htons (ETH_P_IPV6))\n", "        return filter_ipv6 (ctx, data, nh_off, data_end, vlan0, vlan1);\n", "    return XDP_PASS;\n", "}\n"], "called_function_list": ["filter_ipv6", "filter_ipv4"], "call_depth": 2, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 1}, "23": {"capabilities": [], "helperCallParams": {}, "startLine": 9, "endLine": 55, "File": "/home/palani/github/ebpf-projects-annotations/projects/suricata-master/original_source/ebpf/hash_func01.h", "funcName": "SuperFastHash", "developer_inline_comments": [{"start_line": 1, "end_line": 5, "text": "/* SPDX-License-Identifier: LGPL-2.1\n *\n * Based on Paul Hsieh's (LGPG 2.1) hash function\n * From: http://www.azillionmonkeys.com/qed/hash.html\n */"}, {"start_line": 20, "end_line": 20, "text": "/* Main loop */"}, {"start_line": 30, "end_line": 30, "text": "/* Handle end cases */"}, {"start_line": 46, "end_line": 46, "text": "/* Force \"avalanching\" of final 127 bits */"}], "updateMaps": [], "readMaps": [], "input": ["const char *data", " int len", " __u32 initval"], "output": "static__always_inline__u32", "helper": [], "compatibleHookpoints": ["xdp", "raw_tracepoint", "cgroup_sysctl", "cgroup_sock_addr", "cgroup_sock", "socket_filter", "lwt_xmit", "sk_skb", "tracepoint", "sched_act", "cgroup_skb", "sched_cls", "sk_msg", "raw_tracepoint_writable", "perf_event", "sk_reuseport", "lwt_out", "cgroup_device", "flow_dissector", "sock_ops", "kprobe", "lwt_seg6local", "lwt_in"], "source": ["static __always_inline __u32 SuperFastHash (const char *data, int len, __u32 initval)\n", "{\n", "    __u32 hash = initval;\n", "    __u32 tmp;\n", "    int rem;\n", "    if (len <= 0 || data == NULL)\n", "        return 0;\n", "    rem = len & 3;\n", "    len >>= 2;\n", "\n", "#pragma clang loop unroll(full)\n", "    for (; len > 0; len--) {\n", "        hash += get16bits (data);\n", "        tmp = (get16bits (data + 2) << 11) ^ hash;\n", "        hash = (hash << 16) ^ tmp;\n", "        data += 2 * sizeof (__u16);\n", "        hash += hash >> 11;\n", "    }\n", "    switch (rem) {\n", "    case 3 :\n", "        hash += get16bits (data);\n", "        hash ^= hash << 16;\n", "        hash ^= ((signed char) data[sizeof (__u16)]) << 18;\n", "        hash += hash >> 11;\n", "        break;\n", "    case 2 :\n", "        hash += get16bits (data);\n", "        hash ^= hash << 11;\n", "        hash += hash >> 17;\n", "        break;\n", "    case 1 :\n", "        hash += (signed char) *data;\n", "        hash ^= hash << 10;\n", "        hash += hash >> 1;\n", "    }\n", "    hash ^= hash << 3;\n", "    hash += hash >> 5;\n", "    hash ^= hash << 4;\n", "    hash += hash >> 17;\n", "    hash ^= hash << 25;\n", "    hash += hash >> 6;\n", "    return hash;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 0}}}