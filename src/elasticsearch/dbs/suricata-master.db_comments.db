{"_default": {"1": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}, {"capability": "pkt_stop_processing_drop_packet", "pkt_stop_processing_drop_packet": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_ABORTED", "Return": 0, "Description": "which serves denoting an exception like state from the program and has the same behavior as XDP_DROP only that XDP_ABORTED passes the trace_xdp_exception tracepoint which can be additionally monitored to detect misbehavior.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_stop_processing_drop_packet"]}]}, {"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_PASS", "Return": 2, "Description": "The XDP_PASS return code means that the packet is allowed to be passed up to the kernel\u2019s networking stack. Meaning, the current CPU that was processing this packet now allocates a skb, populates it, and passes it onwards into the GRO engine. This would be equivalent to the default packet handling behavior without XDP.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 73, "endLine": 99, "File": "/home/palani/github/ebpf-projects-annotations/projects/suricata-master/original_source/ebpf/xdp_lb.c", "funcName": "hash_ipv4", "developer_inline_comments": [{"start_line": 1, "end_line": 16, "text": "/* Copyright (C) 2019 Open Information Security Foundation\n *\n * You can copy, redistribute or modify this Program under the terms of\n * the GNU General Public License version 2 as published by the Free\n * Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * version 2 along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n * 02110-1301, USA.\n */"}, {"start_line": 26, "end_line": 26, "text": "/* Workaround to avoid the need of 32bit headers */"}, {"start_line": 40, "end_line": 40, "text": "/* Hashing initval */"}, {"start_line": 43, "end_line": 43, "text": "/* Increase CPUMAP_MAX_CPUS if ever you have more than 128 CPUs */"}, {"start_line": 51, "end_line": 51, "text": "/* Special map type that can XDP_REDIRECT frames to another CPU */"}, {"start_line": 85, "end_line": 85, "text": "/* IP-pairs hit same CPU */"}], "updateMaps": [], "readMaps": [" cpus_count", "  cpus_available"], "input": ["void *data", " void *data_end"], "output": "staticint__always_inline", "helper": ["bpf_map_lookup_elem", "XDP_ABORTED", "bpf_redirect_map", "bpf_redirect", "XDP_PASS"], "compatibleHookpoints": ["xdp"], "source": ["static int __always_inline hash_ipv4 (void *data, void *data_end)\n", "{\n", "    struct iphdr *iph = data;\n", "    if ((void *) (iph + 1) > data_end)\n", "        return XDP_PASS;\n", "    __u32 key0 = 0;\n", "    __u32 cpu_dest;\n", "    __u32 *cpu_max = bpf_map_lookup_elem (&cpus_count, &key0);\n", "    __u32 *cpu_selected;\n", "    __u32 cpu_hash;\n", "    cpu_hash = iph->saddr + iph->daddr;\n", "    cpu_hash = SuperFastHash ((char *) & cpu_hash, 4, INITVAL);\n", "    if (cpu_max && *cpu_max) {\n", "        cpu_dest = cpu_hash % *cpu_max;\n", "        cpu_selected = bpf_map_lookup_elem (& cpus_available, & cpu_dest);\n", "        if (!cpu_selected)\n", "            return XDP_ABORTED;\n", "        cpu_dest = *cpu_selected;\n", "        return bpf_redirect_map (&cpu_map, cpu_dest, 0);\n", "    }\n", "    else {\n", "        return XDP_PASS;\n", "    }\n", "}\n"], "called_function_list": ["SuperFastHash"], "call_depth": 1, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}, {"description": "This function computes the hash of the extracted IPv4 packet. After the initial bounds check, the cpu_hash is composed by adding the source and destination addresses. This is done in order to be able to hit the same CPU in case the source and destination IP pairs are the same. The SuperFastHash method is used to compose the hash. It takes in 3 arguments- constant character format of the composed cpu_hash, its length and a variable to add randomness called INITVAL. If the CPU assigned is greater than the maximum CPUs, modulus operator is used to wrap around and find a CPU within the maximum allocated range. If no CPU is assigned, the XDP-ABORTED action is returned. Else, the bpf_redirect_map is called to redirect the flow from one CPU to another allocated CPU.", "author": "Madhuri Annavazzala", "authorEmail": "madhuriannavazzala@gmail.com", "date": "2023-04-05"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 0}, "2": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}, {"capability": "pkt_stop_processing_drop_packet", "pkt_stop_processing_drop_packet": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_ABORTED", "Return": 0, "Description": "which serves denoting an exception like state from the program and has the same behavior as XDP_DROP only that XDP_ABORTED passes the trace_xdp_exception tracepoint which can be additionally monitored to detect misbehavior.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_stop_processing_drop_packet"]}]}, {"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_PASS", "Return": 2, "Description": "The XDP_PASS return code means that the packet is allowed to be passed up to the kernel\u2019s networking stack. Meaning, the current CPU that was processing this packet now allocates a skb, populates it, and passes it onwards into the GRO engine. This would be equivalent to the default packet handling behavior without XDP.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 101, "endLine": 132, "File": "/home/palani/github/ebpf-projects-annotations/projects/suricata-master/original_source/ebpf/xdp_lb.c", "funcName": "hash_ipv6", "developer_inline_comments": [{"start_line": 113, "end_line": 113, "text": "/* IP-pairs hit same CPU */"}], "updateMaps": [], "readMaps": [" cpus_count", "  cpus_available"], "input": ["void *data", " void *data_end"], "output": "staticint__always_inline", "helper": ["bpf_map_lookup_elem", "XDP_ABORTED", "bpf_redirect_map", "bpf_redirect", "XDP_PASS"], "compatibleHookpoints": ["xdp"], "source": ["static int __always_inline hash_ipv6 (void *data, void *data_end)\n", "{\n", "    struct ipv6hdr *ip6h = data;\n", "    if ((void *) (ip6h + 1) > data_end)\n", "        return XDP_PASS;\n", "    __u32 key0 = 0;\n", "    __u32 cpu_dest;\n", "    __u32 *cpu_max = bpf_map_lookup_elem (&cpus_count, &key0);\n", "    __u32 *cpu_selected;\n", "    __u32 cpu_hash;\n", "    cpu_hash = ip6h->saddr.s6_addr32[0] + ip6h->daddr.s6_addr32[0];\n", "    cpu_hash += ip6h->saddr.s6_addr32[1] + ip6h->daddr.s6_addr32[1];\n", "    cpu_hash += ip6h->saddr.s6_addr32[2] + ip6h->daddr.s6_addr32[2];\n", "    cpu_hash += ip6h->saddr.s6_addr32[3] + ip6h->daddr.s6_addr32[3];\n", "    cpu_hash = SuperFastHash ((char *) & cpu_hash, 4, INITVAL);\n", "    if (cpu_max && *cpu_max) {\n", "        cpu_dest = cpu_hash % *cpu_max;\n", "        cpu_selected = bpf_map_lookup_elem (& cpus_available, & cpu_dest);\n", "        if (!cpu_selected)\n", "            return XDP_ABORTED;\n", "        cpu_dest = *cpu_selected;\n", "        return bpf_redirect_map (&cpu_map, cpu_dest, 0);\n", "    }\n", "    else {\n", "        return XDP_PASS;\n", "    }\n", "    return XDP_PASS;\n", "}\n"], "called_function_list": ["SuperFastHash"], "call_depth": 1, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}, {"description": "This function composes the hash of the extracted IPv6 packet. After the initial bounds check, the cpu_hash is composed by adding the source and destination addresses. This is done in order to be able to hit the same CPU in case the source and destination IP pairs are the same. The SuperFastHash method is used to compose the hash. It takes in 3 arguments- constant character format of the composed cpu_hash, its length and a variable to add randomness called INITVAL. If the CPU assigned is greater than the maximum CPUs, modulus operator is used to wrap around and find a CPU within the maximum allocated range. If no CPU is assigned, the XDP-ABORTED action is returned. Else, the bpf_redirect_map is called to redirect the flow from one CPU to another allocated CPU.", "author": "Madhuri Annavazzala", "authorEmail": "madhuriannavazzala@gmail.com", "date": "2023-04-05"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 0}, "3": {"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_PASS", "Return": 2, "Description": "The XDP_PASS return code means that the packet is allowed to be passed up to the kernel\u2019s networking stack. Meaning, the current CPU that was processing this packet now allocates a skb, populates it, and passes it onwards into the GRO engine. This would be equivalent to the default packet handling behavior without XDP.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 134, "endLine": 202, "File": "/home/palani/github/ebpf-projects-annotations/projects/suricata-master/original_source/ebpf/xdp_lb.c", "funcName": "filter_gre", "developer_inline_comments": [{"start_line": 161, "end_line": 161, "text": "/* Update offset to skip ERPSAN header if we have one */"}, {"start_line": 174, "end_line": 174, "text": "/* we have now data starting at Ethernet header */"}, {"start_line": 177, "end_line": 177, "text": "/* we want to hash on IP so we need to get to ip hdr */"}, {"start_line": 183, "end_line": 184, "text": "/* we need to increase offset and update protocol\n     * in the case we have VLANs */"}, {"start_line": 195, "end_line": 195, "text": "/* proto should now be IP style */"}], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *ctx", " void *data", " __u64 nh_off", " void *data_end"], "output": "staticint__always_inline", "helper": ["XDP_PASS"], "compatibleHookpoints": ["xdp"], "source": ["static int __always_inline filter_gre (struct xdp_md *ctx, void *data, __u64 nh_off, void *data_end)\n", "{\n", "    struct iphdr *iph = data + nh_off;\n", "    __u16 proto;\n", "    struct gre_hdr {\n", "        __be16 flags;\n", "        __be16 proto;\n", "    }\n", "    ;\n", "    nh_off += sizeof (struct iphdr);\n", "    struct gre_hdr *grhdr = (struct gre_hdr *) (iph + 1);\n", "    if ((void *) (grhdr + 1) > data_end)\n", "        return XDP_PASS;\n", "    if (grhdr->flags & (GRE_VERSION | GRE_ROUTING))\n", "        return XDP_PASS;\n", "    nh_off += 4;\n", "    proto = grhdr->proto;\n", "    if (grhdr->flags & GRE_CSUM)\n", "        nh_off += 4;\n", "    if (grhdr->flags & GRE_KEY)\n", "        nh_off += 4;\n", "    if (grhdr->flags & GRE_SEQ)\n", "        nh_off += 4;\n", "    if (proto == __constant_htons (ETH_P_ERSPAN)) {\n", "        nh_off += 8;\n", "    }\n", "    if (data + nh_off > data_end)\n", "        return XDP_PASS;\n", "    if (bpf_xdp_adjust_head (ctx, 0 + nh_off))\n", "        return XDP_PASS;\n", "    data = (void *) (long) ctx->data;\n", "    data_end = (void *) (long) ctx->data_end;\n", "    struct ethhdr *eth = data;\n", "    proto = eth->h_proto;\n", "    nh_off = sizeof (*eth);\n", "    if (data + nh_off > data_end)\n", "        return XDP_PASS;\n", "    if (proto == __constant_htons (ETH_P_8021Q)) {\n", "        struct vlan_hdr *vhdr = (struct vlan_hdr *) (data + nh_off);\n", "        if ((void *) (vhdr + 1) > data_end)\n", "            return XDP_PASS;\n", "        proto = vhdr->h_vlan_encapsulated_proto;\n", "        nh_off += sizeof (struct vlan_hdr);\n", "    }\n", "    if (data + nh_off > data_end)\n", "        return XDP_PASS;\n", "    if (proto == __constant_htons (ETH_P_IP)) {\n", "        return hash_ipv4 (data + nh_off, data_end);\n", "    }\n", "    else if (proto == __constant_htons (ETH_P_IPV6)) {\n", "        return hash_ipv6 (data + nh_off, data_end);\n", "    }\n", "    else\n", "        return XDP_PASS;\n", "}\n"], "called_function_list": ["hash_ipv4", "hash_ipv6"], "call_depth": 2, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}, {"description": "This function extracts the encapsulated IP header packet to be hashed. Initially the GRE header is processed to get the GRE_VERSION and GRE_ROUTING information. Then any ERPSAN and VLAN headers present are stripped to reach the ETHERNET HEADER. Based on the version of the IP packet mentioned the relevant function handles the hashing. i.e. either hash_ipv4 or hash_ipv6. If an IP header is not present the packet is passed onto the usual onto the usual kernel network processing stack.", "author": "Madhuri Annavazzala", "authorEmail": "madhuriannavazzala@gmail.com", "date": "2023-04-05"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 0}, "4": {"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_PASS", "Return": 2, "Description": "The XDP_PASS return code means that the packet is allowed to be passed up to the kernel\u2019s networking stack. Meaning, the current CPU that was processing this packet now allocates a skb, populates it, and passes it onwards into the GRO engine. This would be equivalent to the default packet handling behavior without XDP.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 204, "endLine": 214, "File": "/home/palani/github/ebpf-projects-annotations/projects/suricata-master/original_source/ebpf/xdp_lb.c", "funcName": "filter_ipv4", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *ctx", " void *data", " __u64 nh_off", " void *data_end"], "output": "staticint__always_inline", "helper": ["XDP_PASS"], "compatibleHookpoints": ["xdp"], "source": ["static int __always_inline filter_ipv4 (struct xdp_md *ctx, void *data, __u64 nh_off, void *data_end)\n", "{\n", "    struct iphdr *iph = data + nh_off;\n", "    if ((void *) (iph + 1) > data_end)\n", "        return XDP_PASS;\n", "    if (iph->protocol == IPPROTO_GRE) {\n", "        return filter_gre (ctx, data, nh_off, data_end);\n", "    }\n", "    return hash_ipv4 (data + nh_off, data_end);\n", "}\n"], "called_function_list": ["SuperFastHash", "hash_ipv4", "get_sport", "filter_gre", "get_dport"], "call_depth": 1, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}, {"description": "This function filters the IPv4 packets. It initially does the basic bounds checking for the packet length, the packet is checked for a GRE header. If there is a GRE header it is handled by the filter_gre function, else the IPv4 packet is extracted to be hashed by hash_ipv4 funtion.", "author": "Madhuri Annavazzala", "authorEmail": "madhuriannavazzala@gmail.com", "date": "2023-04-05"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 0}, "5": {"capabilities": [{"capability": "pkt_stop_processing_drop_packet", "pkt_stop_processing_drop_packet": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_ABORTED", "Return": 0, "Description": "which serves denoting an exception like state from the program and has the same behavior as XDP_DROP only that XDP_ABORTED passes the trace_xdp_exception tracepoint which can be additionally monitored to detect misbehavior.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_stop_processing_drop_packet"]}, {"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_DROP", "Return": 1, "Description": "will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_stop_processing_drop_packet"]}]}, {"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}, {"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_PASS", "Return": 2, "Description": "The XDP_PASS return code means that the packet is allowed to be passed up to the kernel\u2019s networking stack. Meaning, the current CPU that was processing this packet now allocates a skb, populates it, and passes it onwards into the GRO engine. This would be equivalent to the default packet handling behavior without XDP.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 235, "endLine": 377, "File": "/home/palani/github/ebpf-projects-annotations/projects/suricata-master/original_source/ebpf/xdp_filter.c", "funcName": "filter_ipv4", "developer_inline_comments": [{"start_line": 324, "end_line": 324, "text": "/* drop application data for tls 1.2 */"}, {"start_line": 325, "end_line": 325, "text": "/* FIXME better parsing */"}, {"start_line": 354, "end_line": 354, "text": "/* IP-pairs + protocol (UDP/TCP/ICMP) hit same CPU */"}, {"start_line": 370, "end_line": 370, "text": "/* IP-pairs + protocol (UDP/TCP/ICMP) hit same CPU */"}], "updateMaps": [], "readMaps": ["  flow_table_v4", "  tx_peer_int", " cpus_count", "  tls_bypass_count", "  cpus_available"], "input": ["struct xdp_md *ctx", " void *data", " __u64 nh_off", " void *data_end", " __u16 vlan0", " __u16 vlan1"], "output": "staticint__always_inline", "helper": ["XDP_ABORTED", "bpf_redirect_map", "bpf_redirect", "bpf_trace_printk", "XDP_DROP", "bpf_map_lookup_elem", "XDP_PASS"], "compatibleHookpoints": ["xdp"], "source": ["static int __always_inline filter_ipv4 (struct xdp_md *ctx, void *data, __u64 nh_off, void *data_end, __u16 vlan0, __u16 vlan1)\n", "{\n", "    struct iphdr *iph = data + nh_off;\n", "    int dport;\n", "    int sport;\n", "    struct flowv4_keys tuple;\n", "    struct pair *value;\n", "\n", "#if BUILD_CPUMAP || GOT_TX_PEER\n", "    __u32 key0 = 0;\n", "\n", "#endif\n", "\n", "#if ENCRYPTED_TLS_BYPASS\n", "    __u32 key1 = 0;\n", "    __u32 *tls_count = NULL;\n", "\n", "#endif\n", "\n", "#if BUILD_CPUMAP\n", "    __u32 cpu_dest;\n", "    __u32 *cpu_max = bpf_map_lookup_elem (&cpus_count, &key0);\n", "    __u32 *cpu_selected;\n", "    __u32 cpu_hash;\n", "\n", "#endif\n", "\n", "#if GOT_TX_PEER\n", "    int *iface_peer;\n", "    int tx_port = 0;\n", "\n", "#endif\n", "    if ((void *) (iph + 1) > data_end)\n", "        return XDP_PASS;\n", "    if (iph->protocol == IPPROTO_TCP) {\n", "        tuple.ip_proto = 1;\n", "    }\n", "    else {\n", "        tuple.ip_proto = 0;\n", "    }\n", "    tuple.src = iph->saddr;\n", "    tuple.dst = iph->daddr;\n", "    dport = get_dport (iph + 1, data_end, iph -> protocol);\n", "    if (dport == -1)\n", "        return XDP_PASS;\n", "    sport = get_sport (iph + 1, data_end, iph -> protocol);\n", "    if (sport == -1)\n", "        return XDP_PASS;\n", "    tuple.port16[0] = (__u16) sport;\n", "    tuple.port16[1] = (__u16) dport;\n", "    tuple.vlan0 = vlan0;\n", "    tuple.vlan1 = vlan1;\n", "    value = bpf_map_lookup_elem (& flow_table_v4, & tuple);\n", "\n", "#if 0\n", "    {\n", "        char fmt [] = \"Current flow src: %u:%d\\n\";\n", "        char fmt1 [] = \"Current flow dst: %u:%d\\n\";\n", "        bpf_trace_printk (fmt, sizeof (fmt), tuple.src, tuple.port16[0]);\n", "        bpf_trace_printk (fmt1, sizeof (fmt1), tuple.dst, tuple.port16[1]);\n", "    }\n", "\n", "#endif\n", "    if (value) {\n", "\n", "#if 0\n", "        char fmt [] = \"Found flow v4: %u %d -> %d\\n\";\n", "        bpf_trace_printk (fmt, sizeof (fmt), tuple.src, sport, dport);\n", "        char fmt [] = \"Data: t:%lu p:%lu n:%lu\\n\";\n", "        bpf_trace_printk (fmt, sizeof (fmt), value->time, value->packets, value->bytes);\n", "\n", "#endif\n", "\n", "#if USE_PERCPU_HASH\n", "        value->packets++;\n", "        value->bytes += data_end - data;\n", "\n", "#else\n", "        __sync_fetch_and_add (&value->packets, 1);\n", "        __sync_fetch_and_add (&value->bytes, data_end - data);\n", "\n", "#endif\n", "\n", "#if GOT_TX_PEER\n", "        iface_peer = bpf_map_lookup_elem (& tx_peer_int, & key0);\n", "        if (!iface_peer) {\n", "            return XDP_DROP;\n", "        }\n", "        else {\n", "            return bpf_redirect_map (&tx_peer, tx_port, 0);\n", "        }\n", "\n", "#else\n", "        return XDP_DROP;\n", "\n", "#endif\n", "    }\n", "\n", "#if ENCRYPTED_TLS_BYPASS\n", "    if ((dport == __constant_ntohs (443)) || (sport == __constant_ntohs (443))) {\n", "        __u8 *app_data;\n", "        nh_off += sizeof (struct iphdr) + sizeof (struct tcphdr);\n", "        if (data_end > data + nh_off + 4) {\n", "            app_data = data + nh_off;\n", "            if (app_data[0] == 0x17 && app_data[1] == 0x3 && app_data[2] == 0x3) {\n", "                tls_count = bpf_map_lookup_elem (& tls_bypass_count, & key1);\n", "                if (tls_count) {\n", "\n", "#if USE_PERCPU_HASH\n", "                    tls_count++;\n", "\n", "#else\n", "                    __sync_fetch_and_add (tls_count, 1);\n", "\n", "#endif\n", "                }\n", "\n", "#if GOT_TX_PEER\n", "                iface_peer = bpf_map_lookup_elem (& tx_peer_int, & key0);\n", "                if (!iface_peer) {\n", "                    return XDP_DROP;\n", "                }\n", "                else {\n", "                    return bpf_redirect_map (&tx_peer, tx_port, 0);\n", "                }\n", "\n", "#else\n", "                return XDP_DROP;\n", "\n", "#endif\n", "            }\n", "        }\n", "    }\n", "\n", "#endif\n", "\n", "#if BUILD_CPUMAP\n", "    cpu_hash = tuple.src + tuple.dst;\n", "    cpu_hash = SuperFastHash ((char *) & cpu_hash, 4, INITVAL + iph -> protocol);\n", "    if (cpu_max && *cpu_max) {\n", "        cpu_dest = cpu_hash % *cpu_max;\n", "        cpu_selected = bpf_map_lookup_elem (& cpus_available, & cpu_dest);\n", "        if (!cpu_selected)\n", "            return XDP_ABORTED;\n", "        cpu_dest = *cpu_selected;\n", "        return bpf_redirect_map (&cpu_map, cpu_dest, 0);\n", "    }\n", "    else {\n", "        return XDP_PASS;\n", "    }\n", "\n", "#else\n", "\n", "#if RSS_QUEUE_NUMBERS\n", "    __u32 xdp_hash = tuple.src + tuple.dst;\n", "    xdp_hash = SuperFastHash ((char *) & xdp_hash, 4, INITVAL + iph -> protocol);\n", "    ctx->rx_queue_index = xdp_hash % RSS_QUEUE_NUMBERS;\n", "\n", "#endif\n", "    return XDP_PASS;\n", "\n", "#endif\n", "}\n"], "called_function_list": ["SuperFastHash", "hash_ipv4", "get_sport", "filter_gre", "get_dport"], "call_depth": 1, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}, {"description": "This function filters the IPv4 packets. If the L4 protocol is TCP, tuple.ip_proto is set to 1. If it is UDP, tuple.ip_proto is set to 0. The source port and destination port of the packet are also extracted. The packet is DROPPED if the packets' ports are not able to get extracted. The tuple array consists of the identification fields for the packet such as - src address, destination address, src port, dest port, vlan0 and vlan1 (used for VLAN flow tracking) which are then used as a key to lookup in the map. If it exists, the number of packets is incremented by 1 and the bytes is incremented by the length of the packet. The increments are done using atomic operations if the map type is BPF_MAP_TYPE_ARRAY. If GOT_TX_PEER flag is enabled, the key0 is initialized as 0. The key is then searched in tx_peer_int BPF MAP. The packet is dropped if the key doesn't exist. Otherwise, the packet is redirect to the corresponding port. If ENCRYPTED_TLS_BYPASS flag is set, the key1 variable is initialized to 0. Then, the transport protocol is checked if it is secured. If the protocol is secured, the key1 is searched in the tls_bypass_count and incremented appropriately. If BUILD_CPUMAP flag is set, the hash is generated using the src and dst addresses using the SuperFastHash function. A destination CPU is selected from the available CPUs using this hash as key. If the corresponding value exists in the map, the packet is redirected to the destination CPU, otherwise it is dropped. If the RSS_QUE_NUMBERS macro is defined, the hash is generated using src and dst addresses using the SuperFastHash function. The rx_queue_index field of the context variable is updated with the hash. The packet is PASSED.", "author": "R V B R N Aaseesh", "authorEmail": "aaseesh.rallapalli@gmail.com", "date": "2023-04-04"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 0}, "6": {"capabilities": [], "helperCallParams": {}, "startLine": 216, "endLine": 220, "File": "/home/palani/github/ebpf-projects-annotations/projects/suricata-master/original_source/ebpf/xdp_lb.c", "funcName": "filter_ipv6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *ctx", " void *data", " __u64 nh_off", " void *data_end"], "output": "staticint__always_inline", "helper": [], "compatibleHookpoints": ["xdp", "raw_tracepoint", "cgroup_sysctl", "cgroup_sock_addr", "cgroup_sock", "socket_filter", "lwt_xmit", "sk_skb", "tracepoint", "sched_act", "cgroup_skb", "sched_cls", "sk_msg", "raw_tracepoint_writable", "perf_event", "sk_reuseport", "lwt_out", "cgroup_device", "flow_dissector", "sock_ops", "kprobe", "lwt_seg6local", "lwt_in"], "source": ["static int __always_inline filter_ipv6 (struct xdp_md *ctx, void *data, __u64 nh_off, void *data_end)\n", "{\n", "    struct ipv6hdr *ip6h = data + nh_off;\n", "    return hash_ipv6 ((void *) ip6h, data_end);\n", "}\n"], "called_function_list": ["SuperFastHash", "hash_ipv6", "get_sport", "get_dport"], "call_depth": 1, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}, {"description": "This function extracts the IPv6 packet and is then sent to be handled by the hash_ipv6 method.", "author": "Madhuri Annavazzala", "authorEmail": "madhuriannavazzala@gmail.com", "date": "2023-04-05"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 0}, "7": {"capabilities": [{"capability": "pkt_stop_processing_drop_packet", "pkt_stop_processing_drop_packet": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_ABORTED", "Return": 0, "Description": "which serves denoting an exception like state from the program and has the same behavior as XDP_DROP only that XDP_ABORTED passes the trace_xdp_exception tracepoint which can be additionally monitored to detect misbehavior.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_stop_processing_drop_packet"]}, {"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_DROP", "Return": 1, "Description": "will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_stop_processing_drop_packet"]}]}, {"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}, {"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_PASS", "Return": 2, "Description": "The XDP_PASS return code means that the packet is allowed to be passed up to the kernel\u2019s networking stack. Meaning, the current CPU that was processing this packet now allocates a skb, populates it, and passes it onwards into the GRO engine. This would be equivalent to the default packet handling behavior without XDP.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 379, "endLine": 483, "File": "/home/palani/github/ebpf-projects-annotations/projects/suricata-master/original_source/ebpf/xdp_filter.c", "funcName": "filter_ipv6", "developer_inline_comments": [{"start_line": 453, "end_line": 453, "text": "/* IP-pairs + protocol (UDP/TCP/ICMP) hit same CPU */"}, {"start_line": 472, "end_line": 472, "text": "/* IP-pairs + protocol (UDP/TCP/ICMP) hit same CPU */"}], "updateMaps": [], "readMaps": ["  cpus_available", " cpus_count", "  flow_table_v6", "  tx_peer_int"], "input": ["struct xdp_md *ctx", " void *data", " __u64 nh_off", " void *data_end", " __u16 vlan0", " __u16 vlan1"], "output": "staticint__always_inline", "helper": ["XDP_ABORTED", "bpf_redirect_map", "bpf_redirect", "bpf_trace_printk", "XDP_DROP", "bpf_map_lookup_elem", "XDP_PASS"], "compatibleHookpoints": ["xdp"], "source": ["static int __always_inline filter_ipv6 (struct xdp_md *ctx, void *data, __u64 nh_off, void *data_end, __u16 vlan0, __u16 vlan1)\n", "{\n", "    struct ipv6hdr *ip6h = data + nh_off;\n", "    int dport;\n", "    int sport;\n", "    struct flowv6_keys tuple;\n", "    struct pair *value;\n", "\n", "#if BUILD_CPUMAP || GOT_TX_PEER\n", "    __u32 key0 = 0;\n", "\n", "#endif\n", "\n", "#if BUILD_CPUMAP\n", "    __u32 cpu_dest;\n", "    int *cpu_max = bpf_map_lookup_elem (&cpus_count, &key0);\n", "    __u32 *cpu_selected;\n", "    __u32 cpu_hash;\n", "\n", "#endif\n", "\n", "#if GOT_TX_PEER\n", "    int tx_port = 0;\n", "    int *iface_peer;\n", "\n", "#endif\n", "    if ((void *) (ip6h + 1) > data_end)\n", "        return 0;\n", "    if (!((ip6h->nexthdr == IPPROTO_UDP) || (ip6h->nexthdr == IPPROTO_TCP)))\n", "        return XDP_PASS;\n", "    dport = get_dport (ip6h + 1, data_end, ip6h -> nexthdr);\n", "    if (dport == -1)\n", "        return XDP_PASS;\n", "    sport = get_sport (ip6h + 1, data_end, ip6h -> nexthdr);\n", "    if (sport == -1)\n", "        return XDP_PASS;\n", "    if (ip6h->nexthdr == IPPROTO_TCP) {\n", "        tuple.ip_proto = 1;\n", "    }\n", "    else {\n", "        tuple.ip_proto = 0;\n", "    }\n", "    __builtin_memcpy (tuple.src, ip6h->saddr.s6_addr32, sizeof (tuple.src));\n", "    __builtin_memcpy (tuple.dst, ip6h->daddr.s6_addr32, sizeof (tuple.dst));\n", "    tuple.port16[0] = sport;\n", "    tuple.port16[1] = dport;\n", "    tuple.vlan0 = vlan0;\n", "    tuple.vlan1 = vlan1;\n", "    value = bpf_map_lookup_elem (& flow_table_v6, & tuple);\n", "    if (value) {\n", "\n", "#if 0\n", "        char fmt6 [] = \"Found IPv6 flow: %d -> %d\\n\";\n", "        bpf_trace_printk (fmt6, sizeof (fmt6), sport, dport);\n", "\n", "#endif\n", "\n", "#if USE_PERCPU_HASH\n", "        value->packets++;\n", "        value->bytes += data_end - data;\n", "\n", "#else\n", "        __sync_fetch_and_add (&value->packets, 1);\n", "        __sync_fetch_and_add (&value->bytes, data_end - data);\n", "\n", "#endif\n", "\n", "#if GOT_TX_PEER\n", "        iface_peer = bpf_map_lookup_elem (& tx_peer_int, & key0);\n", "        if (!iface_peer) {\n", "            return XDP_DROP;\n", "        }\n", "        else {\n", "            return bpf_redirect_map (&tx_peer, tx_port, 0);\n", "        }\n", "\n", "#else\n", "        return XDP_DROP;\n", "\n", "#endif\n", "    }\n", "\n", "#if BUILD_CPUMAP\n", "    cpu_hash = tuple.src[0] + tuple.dst[0];\n", "    cpu_hash += tuple.src[1] + tuple.dst[1];\n", "    cpu_hash += tuple.src[2] + tuple.dst[2];\n", "    cpu_hash += tuple.src[3] + tuple.dst[3];\n", "    cpu_hash = SuperFastHash ((char *) & cpu_hash, 4, INITVAL);\n", "    if (cpu_max && *cpu_max) {\n", "        cpu_dest = cpu_hash % *cpu_max;\n", "        cpu_selected = bpf_map_lookup_elem (& cpus_available, & cpu_dest);\n", "        if (!cpu_selected)\n", "            return XDP_ABORTED;\n", "        cpu_dest = *cpu_selected;\n", "        return bpf_redirect_map (&cpu_map, cpu_dest, 0);\n", "    }\n", "    else {\n", "        return XDP_PASS;\n", "    }\n", "\n", "#else\n", "\n", "#if RSS_QUEUE_NUMBERS\n", "    __u32 xdp_hash = tuple.src[0] + tuple.dst[0];\n", "    xdp_hash += tuple.src[1] + tuple.dst[1];\n", "    xdp_hash += tuple.src[2] + tuple.dst[2];\n", "    xdp_hash += tuple.src[3] + tuple.dst[3];\n", "    xdp_hash = SuperFastHash ((char *) & xdp_hash, 4, INITVAL);\n", "    ctx->rx_queue_index = xdp_hash % RSS_QUEUE_NUMBERS;\n", "\n", "#endif\n", "    return XDP_PASS;\n", "\n", "#endif\n", "}\n"], "called_function_list": ["SuperFastHash", "hash_ipv6", "get_sport", "get_dport"], "call_depth": 1, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}, {"description": "This function filters the IPv6 packets. If the L4 protocol is TCP, tuple.ip_proto is set to 1. If it is UDP, tuple.ip_proto is set to 0. The source port and destination port of the packet are also extracted. The packet is DROPPED if the packets' ports are not able to get extracted. The tuple array consists of the identification fields for the packet such as - src address, destination address, src port, dest port, vlan0 and vlan1 (used for VLAN flow tracking) which are then used as a key to lookup in the map. If it exists, the number of packets is incremented by 1 and the bytes is incremented by the length of the packet. The increments are done using atomic operations if the map type is BPF_MAP_TYPE_ARRAY. If GOT_TX_PEER flag is enabled, the key0 is initialized as 0. The key is then searched in tx_peer_int BPF MAP. The packet is dropped if the key doesn't exist. Otherwise, the packet is redirect to the corresponding port. If ENCRYPTED_TLS_BYPASS flag is set, the key1 variable is initialized to 0. Then, the transport protocol is checked if it is secured. If the protocol is secured, the key1 is searched in the tls_bypass_count and incremented appropriately. If BUILD_CPUMAP flag is set, the hash is generated using the src and dst addresses using the SuperFastHash function. A destination CPU is selected from the available CPUs using this hash as key. If the corresponding value exists in the map, the packet is redirected to the destination CPU, otherwise it is dropped. If the RSS_QUE_NUMBERS macro is defined, the hash is generated using src and dst addresses using the SuperFastHash function. The rx_queue_index field of the context variable is updated with the hash. The packet is PASSED.", "author": "R V B R N Aaseesh", "authorEmail": "aaseesh.rallapalli@gmail.com", "date": "2023-04-05"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 0}, "8": {"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_PASS", "Return": 2, "Description": "The XDP_PASS return code means that the packet is allowed to be passed up to the kernel\u2019s networking stack. Meaning, the current CPU that was processing this packet now allocates a skb, populates it, and passes it onwards into the GRO engine. This would be equivalent to the default packet handling behavior without XDP.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 222, "endLine": 267, "File": "/home/palani/github/ebpf-projects-annotations/projects/suricata-master/original_source/ebpf/xdp_lb.c", "funcName": "xdp_loadfilter", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *ctx"], "output": "\\xdp\\)", "helper": ["XDP_PASS", "bpf_trace_printk"], "compatibleHookpoints": ["xdp"], "source": ["int SEC (\"xdp\") xdp_loadfilter (struct xdp_md *ctx)\n", "{\n", "    void *data_end = (void *) (long) ctx->data_end;\n", "    void *data = (void *) (long) ctx->data;\n", "    struct ethhdr *eth = data;\n", "    __u16 h_proto;\n", "    __u64 nh_off;\n", "    nh_off = sizeof (*eth);\n", "    if (data + nh_off > data_end)\n", "        return XDP_PASS;\n", "    h_proto = eth->h_proto;\n", "\n", "#if 0\n", "    if (h_proto != __constant_htons (ETH_P_IP)) {\n", "        char fmt [] = \"Current proto: %u\\n\";\n", "        bpf_trace_printk (fmt, sizeof (fmt), h_proto);\n", "    }\n", "\n", "#endif\n", "    if (h_proto == __constant_htons (ETH_P_8021Q) || h_proto == __constant_htons (ETH_P_8021AD)) {\n", "        struct vlan_hdr *vhdr;\n", "        vhdr = data + nh_off;\n", "        nh_off += sizeof (struct vlan_hdr);\n", "        if (data + nh_off > data_end)\n", "            return XDP_PASS;\n", "        h_proto = vhdr->h_vlan_encapsulated_proto;\n", "    }\n", "    if (h_proto == __constant_htons (ETH_P_8021Q) || h_proto == __constant_htons (ETH_P_8021AD)) {\n", "        struct vlan_hdr *vhdr;\n", "        vhdr = data + nh_off;\n", "        nh_off += sizeof (struct vlan_hdr);\n", "        if (data + nh_off > data_end)\n", "            return XDP_PASS;\n", "        h_proto = vhdr->h_vlan_encapsulated_proto;\n", "    }\n", "    if (h_proto == __constant_htons (ETH_P_IP))\n", "        return filter_ipv4 (ctx, data, nh_off, data_end);\n", "    else if (h_proto == __constant_htons (ETH_P_IPV6))\n", "        return filter_ipv6 (ctx, data, nh_off, data_end);\n", "    return XDP_PASS;\n", "}\n"], "called_function_list": ["filter_ipv6", "filter_ipv4"], "call_depth": 2, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}, {"description": "This function parses the received packet to extract the VLAN header, followed by the Ethernet header. Based on the version of the IP packet relevant filter functions are called i.e, for IPv4 packets filter_ipv4 function is called and for IPv6 packets the filter_ipv6 function is called.", "author": "Madhuri Annavazzala", "authorEmail": "madhuriannavazzala@gmail.com", "date": "2023-04-05"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 1}, "9": {"capabilities": [], "helperCallParams": {}, "startLine": 41, "endLine": 57, "File": "/home/palani/github/ebpf-projects-annotations/projects/suricata-master/original_source/ebpf/lb.c", "funcName": "ipv4_hash", "developer_inline_comments": [{"start_line": 1, "end_line": 16, "text": "/* Copyright (C) 2018 Open Information Security Foundation\n *\n * You can copy, redistribute or modify this Program under the terms of\n * the GNU General Public License version 2 as published by the Free\n * Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * version 2 along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n * 02110-1301, USA.\n */"}, {"start_line": 53, "end_line": 53, "text": "//char fmt2[] = \"Got hash %u\\n\";"}, {"start_line": 54, "end_line": 54, "text": "//bpf_trace_printk(fmt2, sizeof(fmt2), src + dst);"}], "updateMaps": [], "readMaps": [], "input": ["struct  __sk_buff *skb"], "output": "static__always_inlineint", "helper": ["bpf_trace_printk"], "compatibleHookpoints": ["xdp", "raw_tracepoint", "cgroup_sysctl", "cgroup_sock_addr", "cgroup_sock", "socket_filter", "lwt_xmit", "sk_skb", "tracepoint", "sched_act", "cgroup_skb", "sched_cls", "sk_msg", "raw_tracepoint_writable", "perf_event", "sk_reuseport", "lwt_out", "cgroup_device", "flow_dissector", "sock_ops", "kprobe", "lwt_seg6local", "lwt_in"], "source": ["static __always_inline int ipv4_hash (struct  __sk_buff *skb)\n", "{\n", "    __u32 nhoff;\n", "    __u32 src, dst;\n", "    nhoff = skb->cb[0];\n", "    src = load_word (skb, nhoff + offsetof (struct iphdr, saddr));\n", "    dst = load_word (skb, nhoff + offsetof (struct iphdr, daddr));\n", "\n", "#if 0\n", "    char fmt [] = \"Got addr: %x -> %x at %d\\n\";\n", "    bpf_trace_printk (fmt, sizeof (fmt), src, dst, nhoff);\n", "\n", "#endif\n", "    return src + dst;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}, {"description": "The function computes a hash for a given packet, by adding the source and destination IP addresses.", "author": "Pragna Mamidipaka", "authorEmail": "pragna.pune@gmail.com", "date": "2023-04-05"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 0}, "10": {"capabilities": [], "helperCallParams": {}, "startLine": 59, "endLine": 67, "File": "/home/palani/github/ebpf-projects-annotations/projects/suricata-master/original_source/ebpf/lb.c", "funcName": "ipv6_addr_hash", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __sk_buff *ctx", " __u64 off"], "output": "staticinline__u32", "helper": [], "compatibleHookpoints": ["xdp", "raw_tracepoint", "cgroup_sysctl", "cgroup_sock_addr", "cgroup_sock", "socket_filter", "lwt_xmit", "sk_skb", "tracepoint", "sched_act", "cgroup_skb", "sched_cls", "sk_msg", "raw_tracepoint_writable", "perf_event", "sk_reuseport", "lwt_out", "cgroup_device", "flow_dissector", "sock_ops", "kprobe", "lwt_seg6local", "lwt_in"], "source": ["static inline __u32 ipv6_addr_hash (struct  __sk_buff *ctx, __u64 off)\n", "{\n", "    __u64 w0 = load_word (ctx, off);\n", "    __u64 w1 = load_word (ctx, off + 4);\n", "    __u64 w2 = load_word (ctx, off + 8);\n", "    __u64 w3 = load_word (ctx, off + 12);\n", "    return (__u32) (w0 ^ w1 ^ w2 ^ w3);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}, {"description": "The function takes an IPv6 address and computes a hash by bitwise XOR of its four octets.", "author": "Pragna Mamidipaka", "authorEmail": "pragna.pune@gmail.com", "date": "2023-04-05"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 0}, "11": {"capabilities": [], "helperCallParams": {}, "startLine": 69, "endLine": 81, "File": "/home/palani/github/ebpf-projects-annotations/projects/suricata-master/original_source/ebpf/lb.c", "funcName": "ipv6_hash", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __sk_buff *skb"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["xdp", "raw_tracepoint", "cgroup_sysctl", "cgroup_sock_addr", "cgroup_sock", "socket_filter", "lwt_xmit", "sk_skb", "tracepoint", "sched_act", "cgroup_skb", "sched_cls", "sk_msg", "raw_tracepoint_writable", "perf_event", "sk_reuseport", "lwt_out", "cgroup_device", "flow_dissector", "sock_ops", "kprobe", "lwt_seg6local", "lwt_in"], "source": ["static __always_inline int ipv6_hash (struct  __sk_buff *skb)\n", "{\n", "    __u32 nhoff;\n", "    __u32 src_hash, dst_hash;\n", "    nhoff = skb->cb[0];\n", "    src_hash = ipv6_addr_hash (skb, nhoff + offsetof (struct ipv6hdr, saddr));\n", "    dst_hash = ipv6_addr_hash (skb, nhoff + offsetof (struct ipv6hdr, daddr));\n", "    return src_hash + dst_hash;\n", "}\n"], "called_function_list": ["ipv6_addr_hash"], "call_depth": 1, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}, {"description": "The function uses source address hash and destination address hash of a packet, and returns the sum of the two as the final hash value.", "author": "Pragna Mamidipaka", "authorEmail": "pragna.pune@gmail.com", "date": "2023-04-05"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 0}, "12": {"capabilities": [], "helperCallParams": {}, "startLine": 83, "endLine": 145, "File": "/home/palani/github/ebpf-projects-annotations/projects/suricata-master/original_source/ebpf/lb.c", "funcName": "lb", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __sk_buff *skb"], "output": "\\loadbalancer\\)", "helper": ["bpf_trace_printk"], "compatibleHookpoints": ["xdp", "raw_tracepoint", "cgroup_sysctl", "cgroup_sock_addr", "cgroup_sock", "socket_filter", "lwt_xmit", "sk_skb", "tracepoint", "sched_act", "cgroup_skb", "sched_cls", "sk_msg", "raw_tracepoint_writable", "perf_event", "sk_reuseport", "lwt_out", "cgroup_device", "flow_dissector", "sock_ops", "kprobe", "lwt_seg6local", "lwt_in"], "source": ["int  __section (\"loadbalancer\") lb (struct  __sk_buff *skb)\n", "{\n", "    __u64 nhoff = ETH_HLEN;\n", "    __u16 proto = load_half (skb, ETH_HLEN - ETH_TLEN);\n", "    __u16 ret = proto;\n", "    switch (proto) {\n", "    case ETH_P_8021Q :\n", "    case ETH_P_8021AD :\n", "        {\n", "            __u16 vproto = load_half (skb, nhoff + offsetof (struct vlan_hdr, h_vlan_encapsulated_proto));\n", "            switch (vproto) {\n", "            case ETH_P_8021AD :\n", "            case ETH_P_8021Q :\n", "                nhoff += sizeof (struct vlan_hdr);\n", "                proto = load_half (skb, nhoff + offsetof (struct vlan_hdr, h_vlan_encapsulated_proto));\n", "                break;\n", "            default :\n", "                proto = vproto;\n", "            }\n", "            nhoff += sizeof (struct vlan_hdr);\n", "            skb->cb[0] = nhoff;\n", "            switch (proto) {\n", "            case ETH_P_IP :\n", "\n", "#if 0\n", "                {\n", "                    char fmt [] = \"ipv4\\n\";\n", "                    bpf_trace_printk (fmt, sizeof (fmt));\n", "                }\n", "\n", "#endif\n", "                ret = ipv4_hash (skb);\n", "                break;\n", "            case ETH_P_IPV6 :\n", "                ret = ipv6_hash (skb);\n", "                break;\n", "            default :\n", "\n", "#if 0\n", "                {\n", "                    char fmt [] = \"Dflt VLAN proto %u\\n\";\n", "                    bpf_trace_printk (fmt, sizeof (fmt), proto);\n", "                    break;\n", "                }\n", "\n", "#else\n", "                break;\n", "\n", "#endif\n", "            }\n", "        }\n", "        break;\n", "    case ETH_P_IP :\n", "        ret = ipv4_hash (skb);\n", "        break;\n", "    case ETH_P_IPV6 :\n", "        ret = ipv6_hash (skb);\n", "        break;\n", "    default :\n", "\n", "#if 0\n", "        {\n", "            char fmt [] = \"Got proto %x\\n\";\n", "            bpf_trace_printk (fmt, sizeof (fmt), proto);\n", "            break;\n", "        }\n", "\n", "#else\n", "        break;\n", "\n", "#endif\n", "    }\n", "    return ret;\n", "}\n"], "called_function_list": ["ipv4_hash", "ipv6_hash"], "call_depth": 2, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}, {"description": "The function parses the ethernet and VLAN headers to extract the IP header. Based on whether it is an IPv4 packet or IPv6 packet, the corresponding hashing functions are called and hash values are returned. If IP header is not present, the ether type is returned. ", "author": "Pragna Mamidipaka", "authorEmail": "pragna.pune@gmail.com", "date": "2023-04-05"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 1}, "13": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 88, "endLine": 148, "File": "/home/palani/github/ebpf-projects-annotations/projects/suricata-master/original_source/ebpf/bypass_filter.c", "funcName": "ipv4_filter", "developer_inline_comments": [{"start_line": 1, "end_line": 16, "text": "/* Copyright (C) 2018 Open Information Security Foundation\n *\n * You can copy, redistribute or modify this Program under the terms of\n * the GNU General Public License version 2 as published by the Free\n * Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * version 2 along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n * 02110-1301, USA.\n */"}, {"start_line": 30, "end_line": 30, "text": "/* vlan tracking: set it to 0 if you don't use VLAN for flow tracking */"}, {"start_line": 83, "end_line": 87, "text": "/**\n * IPv4 filter\n *\n * \\return 0 to drop packet out and -1 to accept it\n */"}, {"start_line": 99, "end_line": 99, "text": "/* only support TCP and UDP for now */"}, {"start_line": 114, "end_line": 114, "text": "/*offsetof(struct iphdr, ihl)*/"}, {"start_line": 127, "end_line": 127, "text": "//__u16 dp = tuple.port16[1];"}, {"start_line": 132, "end_line": 132, "text": "/* Test if src is in hash */"}, {"start_line": 138, "end_line": 138, "text": "//__u16 dp = tuple.port16[1];"}], "updateMaps": [], "readMaps": ["  flow_table_v4"], "input": ["struct  __sk_buff *skb", " __u16 vlan0", " __u16 vlan1"], "output": "static__always_inlineint", "helper": ["bpf_map_lookup_elem", "bpf_trace_printk"], "compatibleHookpoints": ["xdp", "raw_tracepoint", "cgroup_sysctl", "cgroup_sock_addr", "cgroup_sock", "socket_filter", "lwt_xmit", "tracepoint", "sk_skb", "sched_act", "cgroup_skb", "sched_cls", "sk_msg", "raw_tracepoint_writable", "perf_event", "sk_reuseport", "lwt_out", "cgroup_device", "flow_dissector", "sock_ops", "kprobe", "lwt_seg6local", "lwt_in"], "source": ["static __always_inline int ipv4_filter (struct  __sk_buff *skb, __u16 vlan0, __u16 vlan1)\n", "{\n", "    __u32 nhoff, verlen;\n", "    struct flowv4_keys tuple;\n", "    struct pair *value;\n", "    __u16 port;\n", "    __u8 ip_proto;\n", "    nhoff = skb->cb[0];\n", "    ip_proto = load_byte (skb, nhoff + offsetof (struct iphdr, protocol));\n", "    switch (ip_proto) {\n", "    case IPPROTO_TCP :\n", "        tuple.ip_proto = 1;\n", "        break;\n", "    case IPPROTO_UDP :\n", "        tuple.ip_proto = 0;\n", "        break;\n", "    default :\n", "        return -1;\n", "    }\n", "    tuple.src = load_word (skb, nhoff + offsetof (struct iphdr, saddr));\n", "    tuple.dst = load_word (skb, nhoff + offsetof (struct iphdr, daddr));\n", "    verlen = load_byte (skb, nhoff + 0);\n", "    nhoff += (verlen & 0xF) << 2;\n", "    tuple.ports = load_word (skb, nhoff);\n", "    port = tuple.port16[1];\n", "    tuple.port16[1] = tuple.port16[0];\n", "    tuple.port16[0] = port;\n", "    tuple.vlan0 = vlan0;\n", "    tuple.vlan1 = vlan1;\n", "\n", "#if 0\n", "    if ((tuple.port16[0] == 22) || (tuple.port16[1] == 22)) {\n", "        __u16 sp = tuple.port16[0];\n", "        char fmt [] = \"Parsed SSH flow: %u %d -> %u\\n\";\n", "        bpf_trace_printk (fmt, sizeof (fmt), tuple.src, sp, tuple.dst);\n", "    }\n", "\n", "#endif\n", "    value = bpf_map_lookup_elem (& flow_table_v4, & tuple);\n", "    if (value) {\n", "\n", "#if 0\n", "        {\n", "            __u16 sp = tuple.port16[0];\n", "            char bfmt [] = \"Found flow: %u %d -> %u\\n\";\n", "            bpf_trace_printk (bfmt, sizeof (bfmt), tuple.src, sp, tuple.dst);\n", "        }\n", "\n", "#endif\n", "        value->packets++;\n", "        value->bytes += skb->len;\n", "        return 0;\n", "    }\n", "    return -1;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}, {"description": "The function extracts the src and dst IP addresses of the IPv4 packet, and checks whether the dst address is in the list of IPs to be dropped. If yes, count of packet drops is incremented by 1, and function returns 0. If not, function returns -1.", "author": "Pragna Mamidipaka", "authorEmail": "pragna.pune@gmail.com", "date": "2023-04-04"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 0}, "14": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 46, "endLine": 81, "File": "/home/palani/github/ebpf-projects-annotations/projects/suricata-master/original_source/ebpf/filter.c", "funcName": "ipv4_filter", "developer_inline_comments": [{"start_line": 1, "end_line": 16, "text": "/* Copyright (C) 2018 Open Information Security Foundation\n *\n * You can copy, redistribute or modify this Program under the terms of\n * the GNU General Public License version 2 as published by the Free\n * Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * version 2 along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n * 02110-1301, USA.\n */"}], "updateMaps": [], "readMaps": ["  ipv4_drop"], "input": ["struct  __sk_buff *skb"], "output": "static__always_inlineint", "helper": ["bpf_map_lookup_elem", "bpf_trace_printk"], "compatibleHookpoints": ["xdp", "raw_tracepoint", "cgroup_sysctl", "cgroup_sock_addr", "cgroup_sock", "socket_filter", "lwt_xmit", "tracepoint", "sk_skb", "sched_act", "cgroup_skb", "sched_cls", "sk_msg", "raw_tracepoint_writable", "perf_event", "sk_reuseport", "lwt_out", "cgroup_device", "flow_dissector", "sock_ops", "kprobe", "lwt_seg6local", "lwt_in"], "source": ["static __always_inline int ipv4_filter (struct  __sk_buff *skb)\n", "{\n", "    __u32 nhoff;\n", "    __u32 *value;\n", "    __u32 ip = 0;\n", "    nhoff = skb->cb[0];\n", "    ip = load_word (skb, nhoff + offsetof (struct iphdr, saddr));\n", "    value = bpf_map_lookup_elem (& ipv4_drop, & ip);\n", "    if (value) {\n", "\n", "#if DEBUG\n", "        char fmt [] = \"Found value for saddr: %u\\n\";\n", "        bpf_trace_printk (fmt, sizeof (fmt), value);\n", "\n", "#endif\n", "        *value = *value + 1;\n", "        return 0;\n", "    }\n", "    ip = load_word (skb, nhoff + offsetof (struct iphdr, daddr));\n", "    value = bpf_map_lookup_elem (& ipv4_drop, & ip);\n", "    if (value) {\n", "\n", "#if DEBUG\n", "        char fmt [] = \"Found value for daddr: %u\\n\";\n", "        bpf_trace_printk (fmt, sizeof (fmt), value);\n", "\n", "#endif\n", "        *value = *value + 1;\n", "        return 0;\n", "    }\n", "\n", "#if DEBUG\n", "    char fmt [] = \"Nothing so ok\\n\";\n", "    bpf_trace_printk (fmt, sizeof (fmt));\n", "\n", "#endif\n", "    return -1;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}, {"description": "The function extracts the src and dst IP addresses of the IPv4 packet, and checks whether the dst address is in the list of IPs to be dropped. If yes, count of packet drops is incremented by 1, and function returns 0. If not, function returns -1.", "author": "Pragna Mamidipaka", "authorEmail": "pragna.pune@gmail.com", "date": "2023-04-04"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 0}, "15": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 155, "endLine": 210, "File": "/home/palani/github/ebpf-projects-annotations/projects/suricata-master/original_source/ebpf/bypass_filter.c", "funcName": "ipv6_filter", "developer_inline_comments": [{"start_line": 150, "end_line": 154, "text": "/**\n * IPv6 filter\n *\n * \\return 0 to drop packet out and -1 to accept it\n */"}, {"start_line": 165, "end_line": 165, "text": "/* get next header */"}, {"start_line": 168, "end_line": 168, "text": "/* only support direct TCP and UDP for now */"}, {"start_line": 189, "end_line": 189, "text": "/* Parse TCP */"}, {"start_line": 190, "end_line": 190, "text": "/* IPV6_HEADER_LEN */"}, {"start_line": 198, "end_line": 198, "text": "//char fmt[] = \"Now Got IPv6 port %u and %u\\n\";"}, {"start_line": 199, "end_line": 199, "text": "//bpf_trace_printk(fmt, sizeof(fmt), tuple.port16[0], tuple.port16[1]);"}, {"start_line": 200, "end_line": 200, "text": "/* Test if src is in hash */"}, {"start_line": 203, "end_line": 203, "text": "//char fmt[] = \"Got a match IPv6: %u and %u\\n\";"}, {"start_line": 204, "end_line": 204, "text": "//bpf_trace_printk(fmt, sizeof(fmt), tuple.port16[0], tuple.port16[1]);"}], "updateMaps": [], "readMaps": ["  flow_table_v6"], "input": ["struct  __sk_buff *skb", " __u16 vlan0", " __u16 vlan1"], "output": "static__always_inlineint", "helper": ["bpf_map_lookup_elem"], "compatibleHookpoints": ["xdp", "raw_tracepoint", "cgroup_sysctl", "cgroup_sock_addr", "cgroup_sock", "socket_filter", "lwt_xmit", "sk_skb", "tracepoint", "sched_act", "cgroup_skb", "sched_cls", "sk_msg", "raw_tracepoint_writable", "perf_event", "sk_reuseport", "lwt_out", "cgroup_device", "flow_dissector", "sock_ops", "kprobe", "lwt_seg6local", "lwt_in"], "source": ["static __always_inline int ipv6_filter (struct  __sk_buff *skb, __u16 vlan0, __u16 vlan1)\n", "{\n", "    __u32 nhoff;\n", "    __u8 nhdr;\n", "    struct flowv6_keys tuple;\n", "    struct pair *value;\n", "    __u16 port;\n", "    nhoff = skb->cb[0];\n", "    nhdr = load_byte (skb, nhoff + offsetof (struct ipv6hdr, nexthdr));\n", "    switch (nhdr) {\n", "    case IPPROTO_TCP :\n", "        tuple.ip_proto = 1;\n", "        break;\n", "    case IPPROTO_UDP :\n", "        tuple.ip_proto = 0;\n", "        break;\n", "    default :\n", "        return -1;\n", "    }\n", "    tuple.src[0] = load_word (skb, nhoff + offsetof (struct ipv6hdr, saddr));\n", "    tuple.src[1] = load_word (skb, nhoff + offsetof (struct ipv6hdr, saddr) + 4);\n", "    tuple.src[2] = load_word (skb, nhoff + offsetof (struct ipv6hdr, saddr) + 8);\n", "    tuple.src[3] = load_word (skb, nhoff + offsetof (struct ipv6hdr, saddr) + 12);\n", "    tuple.dst[0] = load_word (skb, nhoff + offsetof (struct ipv6hdr, daddr));\n", "    tuple.dst[1] = load_word (skb, nhoff + offsetof (struct ipv6hdr, daddr) + 4);\n", "    tuple.dst[2] = load_word (skb, nhoff + offsetof (struct ipv6hdr, daddr) + 8);\n", "    tuple.dst[3] = load_word (skb, nhoff + offsetof (struct ipv6hdr, daddr) + 12);\n", "    tuple.ports = load_word (skb, nhoff + 40);\n", "    port = tuple.port16[1];\n", "    tuple.port16[1] = tuple.port16[0];\n", "    tuple.port16[0] = port;\n", "    tuple.vlan0 = vlan0;\n", "    tuple.vlan1 = vlan1;\n", "    value = bpf_map_lookup_elem (& flow_table_v6, & tuple);\n", "    if (value) {\n", "        value->packets++;\n", "        value->bytes += skb->len;\n", "        return 0;\n", "    }\n", "    return -1;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}, {"description": "The function does not filter any IPv6 packets. It returns -1 for all packets.", "author": "Pragna Mamidipaka", "authorEmail": "pragna.pune@gmail.com", "date": "2023-04-04"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 0}, "16": {"capabilities": [], "helperCallParams": {}, "startLine": 83, "endLine": 86, "File": "/home/palani/github/ebpf-projects-annotations/projects/suricata-master/original_source/ebpf/filter.c", "funcName": "ipv6_filter", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __sk_buff *skb"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["xdp", "raw_tracepoint", "cgroup_sysctl", "cgroup_sock_addr", "cgroup_sock", "socket_filter", "lwt_xmit", "sk_skb", "tracepoint", "sched_act", "cgroup_skb", "sched_cls", "sk_msg", "raw_tracepoint_writable", "perf_event", "sk_reuseport", "lwt_out", "cgroup_device", "flow_dissector", "sock_ops", "kprobe", "lwt_seg6local", "lwt_in"], "source": ["static __always_inline int ipv6_filter (struct  __sk_buff *skb)\n", "{\n", "    return -1;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}, {"description": "The function does not filter any IPv6 packets. It returns -1 for all packets.", "author": "Pragna Mamidipaka", "authorEmail": "pragna.pune@gmail.com", "date": "2023-04-04"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 0}, "17": {"capabilities": [], "helperCallParams": {}, "startLine": 220, "endLine": 256, "File": "/home/palani/github/ebpf-projects-annotations/projects/suricata-master/original_source/ebpf/bypass_filter.c", "funcName": "hashfilter", "developer_inline_comments": [{"start_line": 212, "end_line": 219, "text": "/**\n * filter function\n *\n * It is loaded in kernel by Suricata that uses the section name specified\n * by the SEC call to find it in the Elf binary object and load it.\n *\n * \\return 0 to drop packet out and -1 to accept it\n */"}, {"start_line": 231, "end_line": 231, "text": "/* one vlan layer is stripped by OS so get vlan 1 at first pass */"}], "updateMaps": [], "readMaps": [], "input": ["struct  __sk_buff *skb"], "output": "\\filter\\)", "helper": ["bpf_trace_printk"], "compatibleHookpoints": ["xdp", "raw_tracepoint", "cgroup_sysctl", "cgroup_sock_addr", "cgroup_sock", "socket_filter", "lwt_xmit", "sk_skb", "tracepoint", "sched_act", "cgroup_skb", "sched_cls", "sk_msg", "raw_tracepoint_writable", "perf_event", "sk_reuseport", "lwt_out", "cgroup_device", "flow_dissector", "sock_ops", "kprobe", "lwt_seg6local", "lwt_in"], "source": ["int SEC (\"filter\") hashfilter (struct  __sk_buff *skb)\n", "{\n", "    __u32 nhoff = ETH_HLEN;\n", "    __u16 proto = load_half (skb, offsetof (struct ethhdr, h_proto));\n", "    __u16 vlan0 = skb->vlan_tci & 0x0fff;\n", "    __u16 vlan1 = 0;\n", "    if (proto == ETH_P_8021AD || proto == ETH_P_8021Q) {\n", "        proto = load_half (skb, nhoff + offsetof (struct vlan_hdr, h_vlan_encapsulated_proto));\n", "\n", "#if VLAN_TRACKING\n", "        vlan1 = load_half (skb, nhoff + offsetof (struct vlan_hdr, h_vlan_TCI)) & 0x0fff;\n", "\n", "#endif\n", "        nhoff += sizeof (struct vlan_hdr);\n", "    }\n", "    skb->cb[0] = nhoff;\n", "    switch (proto) {\n", "    case ETH_P_IP :\n", "        return ipv4_filter (skb, vlan0, vlan1);\n", "    case ETH_P_IPV6 :\n", "        return ipv6_filter (skb, vlan0, vlan1);\n", "    default :\n", "\n", "#if 0\n", "        {\n", "            char fmt [] = \"Got proto %u\\n\";\n", "            bpf_trace_printk (fmt, sizeof (fmt), h_proto);\n", "            break;\n", "        }\n", "\n", "#else\n", "        break;\n", "\n", "#endif\n", "    }\n", "    return -1;\n", "}\n"], "called_function_list": ["ipv4_filter", "ipv6_filter"], "call_depth": 1, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}, {"description": "This hash function filter, filters the Ethernet packets based on the IP packet version. If GLOBAL_BYPASS flag is set, then the key0 is initialized to 0 and is checked in the global_bypass map. If the key exists, the same key0 is checked in tx_peer_int map. If the key doesn't exist, the packet is dropped. Othereise, the tx_port is written into the tx_peer map. If GLOBAL_BYPASS is not set, the fields vlan0 is set to the last 12 bits of the VLAN TCI field and vlan1 is set to 0 if the VLAN_TRACKING is off else it is set to the last 12 bits of the VLAN TCI field(since vlan0 is stripped by the OS). Based on the version of IP packets, the function filter_ipv4 or filter_ipv6 is invoked accordingly. If it is neither of them -1 is returned.", "author": "R V B R N Aaseesh", "authorEmail": "aaseesh.rallapalli@gmail.com", "date": "2023-04-05"}, {"description": "The function checks whether the packet is an IPv4 packet or an IPv6 packet, and correspondingly calls the filter functions. If the packet does not contain any IP header, then -1 is returned.", "author": "Pragna Mamidipaka", "authorEmail": "pragna.pune@gmail.com", "date": "2023-04-04"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 1}, "18": {"capabilities": [], "helperCallParams": {}, "startLine": 25, "endLine": 36, "File": "/home/palani/github/ebpf-projects-annotations/projects/suricata-master/original_source/ebpf/vlan_filter.c", "funcName": "hashfilter", "developer_inline_comments": [{"start_line": 1, "end_line": 16, "text": "/* Copyright (C) 2018 Open Information Security Foundation\n *\n * You can copy, redistribute or modify this Program under the terms of\n * the GNU General Public License version 2 as published by the Free\n * Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * version 2 along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n * 02110-1301, USA.\n */"}, {"start_line": 27, "end_line": 27, "text": "/* accept VLAN 2 and 4 and drop the rest */"}], "updateMaps": [], "readMaps": [], "input": ["struct  __sk_buff *skb"], "output": "\\filter\\)", "helper": [], "compatibleHookpoints": ["xdp", "raw_tracepoint", "cgroup_sysctl", "cgroup_sock_addr", "cgroup_sock", "socket_filter", "lwt_xmit", "sk_skb", "tracepoint", "sched_act", "cgroup_skb", "sched_cls", "sk_msg", "raw_tracepoint_writable", "perf_event", "sk_reuseport", "lwt_out", "cgroup_device", "flow_dissector", "sock_ops", "kprobe", "lwt_seg6local", "lwt_in"], "source": ["int SEC (\"filter\") hashfilter (struct  __sk_buff *skb)\n", "{\n", "    __u16 vlan_id = skb->vlan_tci & 0x0fff;\n", "    switch (vlan_id) {\n", "    case 2 :\n", "    case 4 :\n", "        return -1;\n", "    default :\n", "        return 0;\n", "    }\n", "    return 0;\n", "}\n"], "called_function_list": ["ipv4_filter", "ipv6_filter"], "call_depth": 1, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}, {"description": "This hash function filter, filters the Ethernet packets based on the IP packet version. If GLOBAL_BYPASS flag is set, then the key0 is initialized to 0 and is checked in the global_bypass map. If the key exists, the same key0 is checked in tx_peer_int map. If the key doesn't exist, the packet is dropped. Othereise, the tx_port is written into the tx_peer map. If GLOBAL_BYPASS is not set, the fields vlan0 is set to the last 12 bits of the VLAN TCI field and vlan1 is set to 0 if the VLAN_TRACKING is off else it is set to the last 12 bits of the VLAN TCI field(since vlan0 is stripped by the OS). Based on the version of IP packets, the function filter_ipv4 or filter_ipv6 is invoked accordingly. If it is neither of them -1 is returned.", "author": "R V B R N Aaseesh", "authorEmail": "aaseesh.rallapalli@gmail.com", "date": "2023-04-05"}, {"description": "The function checks whether the packet is an IPv4 packet or an IPv6 packet, and correspondingly calls the filter functions. If the packet does not contain any IP header, then -1 is returned.", "author": "Pragna Mamidipaka", "authorEmail": "pragna.pune@gmail.com", "date": "2023-04-04"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 1}, "19": {"capabilities": [], "helperCallParams": {}, "startLine": 88, "endLine": 110, "File": "/home/palani/github/ebpf-projects-annotations/projects/suricata-master/original_source/ebpf/filter.c", "funcName": "hashfilter", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __sk_buff *skb"], "output": "\\filter\\)", "helper": [], "compatibleHookpoints": ["xdp", "raw_tracepoint", "cgroup_sysctl", "cgroup_sock_addr", "cgroup_sock", "socket_filter", "lwt_xmit", "sk_skb", "tracepoint", "sched_act", "cgroup_skb", "sched_cls", "sk_msg", "raw_tracepoint_writable", "perf_event", "sk_reuseport", "lwt_out", "cgroup_device", "flow_dissector", "sock_ops", "kprobe", "lwt_seg6local", "lwt_in"], "source": ["int SEC (\"filter\") hashfilter (struct  __sk_buff *skb)\n", "{\n", "    __u32 nhoff = ETH_HLEN;\n", "    __u16 proto = load_half (skb, offsetof (struct ethhdr, h_proto));\n", "    if (proto == ETH_P_8021AD || proto == ETH_P_8021Q) {\n", "        proto = load_half (skb, nhoff + offsetof (struct vlan_hdr, h_vlan_encapsulated_proto));\n", "        nhoff += sizeof (struct vlan_hdr);\n", "    }\n", "    skb->cb[0] = nhoff;\n", "    switch (proto) {\n", "    case ETH_P_IP :\n", "        return ipv4_filter (skb);\n", "    case ETH_P_IPV6 :\n", "        return ipv6_filter (skb);\n", "    default :\n", "        break;\n", "    }\n", "    return -1;\n", "}\n"], "called_function_list": ["ipv4_filter", "ipv6_filter"], "call_depth": 1, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}, {"description": "This hash function filter, filters the Ethernet packets based on the IP packet version. If GLOBAL_BYPASS flag is set, then the key0 is initialized to 0 and is checked in the global_bypass map. If the key exists, the same key0 is checked in tx_peer_int map. If the key doesn't exist, the packet is dropped. Othereise, the tx_port is written into the tx_peer map. If GLOBAL_BYPASS is not set, the fields vlan0 is set to the last 12 bits of the VLAN TCI field and vlan1 is set to 0 if the VLAN_TRACKING is off else it is set to the last 12 bits of the VLAN TCI field(since vlan0 is stripped by the OS). Based on the version of IP packets, the function filter_ipv4 or filter_ipv6 is invoked accordingly. If it is neither of them -1 is returned.", "author": "R V B R N Aaseesh", "authorEmail": "aaseesh.rallapalli@gmail.com", "date": "2023-04-05"}, {"description": "The function checks whether the packet is an IPv4 packet or an IPv6 packet, and correspondingly calls the filter functions. If the packet does not contain any IP header, then -1 is returned.", "author": "Pragna Mamidipaka", "authorEmail": "pragna.pune@gmail.com", "date": "2023-04-04"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 1}, "20": {"capabilities": [], "helperCallParams": {}, "startLine": 191, "endLine": 211, "File": "/home/palani/github/ebpf-projects-annotations/projects/suricata-master/original_source/ebpf/xdp_filter.c", "funcName": "get_sport", "developer_inline_comments": [{"start_line": 1, "end_line": 16, "text": "/* Copyright (C) 2018 Open Information Security Foundation\n *\n * You can copy, redistribute or modify this Program under the terms of\n * the GNU General Public License version 2 as published by the Free\n * Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * version 2 along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n * 02110-1301, USA.\n */"}, {"start_line": 36, "end_line": 36, "text": "/* Hashing initval */"}, {"start_line": 39, "end_line": 40, "text": "/* Set BUILD_CPUMAP to 0 if you want to run XDP bypass on kernel\n * older than 4.15 */"}, {"start_line": 42, "end_line": 42, "text": "/* Increase CPUMAP_MAX_CPUS if ever you have more than 64 CPUs */"}, {"start_line": 45, "end_line": 46, "text": "/* Set to 1 to bypass encrypted packets of TLS sessions. Suricata will\n * be blind to these packets or forged packets looking alike. */"}, {"start_line": 49, "end_line": 50, "text": "/* Set it to 0 if for example you plan to use the XDP filter in a\n * network card that don't support per CPU value (like netronome) */"}, {"start_line": 52, "end_line": 52, "text": "/* Set it to 0 if your XDP subsystem don't handle XDP_REDIRECT (like netronome) */"}, {"start_line": 55, "end_line": 56, "text": "/* set to non 0 to load balance in hardware mode on RSS_QUEUE_NUMBERS queues\n * and unset BUILD_CPUMAP (number must be a power of 2 for netronome) */"}, {"start_line": 59, "end_line": 60, "text": "/* no vlan tracking: set it to 0 if you don't use VLAN for tracking. Can\n * also be used as workaround of some hardware offload issue */"}, {"start_line": 134, "end_line": 134, "text": "/* Special map type that can XDP_REDIRECT frames to another CPU */"}, {"start_line": 158, "end_line": 160, "text": "/* Map has only one element as we don't handle any sort of\n * routing for now. Key value set by user space is 0 and\n * value is the peer interface. */"}, {"start_line": 168, "end_line": 170, "text": "/* single entry to indicate if we have peer, key value\n * set in user space is 0. It is only used to see if\n * a interface has a peer we need to send the information to */"}, {"start_line": 181, "end_line": 181, "text": "/* single entry to indicate if global bypass switch is on */"}], "updateMaps": [], "readMaps": [], "input": ["void *trans_data", " void *data_end", " __u8 protocol"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["xdp", "raw_tracepoint", "cgroup_sysctl", "cgroup_sock_addr", "cgroup_sock", "socket_filter", "lwt_xmit", "sk_skb", "tracepoint", "sched_act", "cgroup_skb", "sched_cls", "sk_msg", "raw_tracepoint_writable", "perf_event", "sk_reuseport", "lwt_out", "cgroup_device", "flow_dissector", "sock_ops", "kprobe", "lwt_seg6local", "lwt_in"], "source": ["static __always_inline int get_sport (void *trans_data, void *data_end, __u8 protocol)\n", "{\n", "    struct tcphdr *th;\n", "    struct udphdr *uh;\n", "    switch (protocol) {\n", "    case IPPROTO_TCP :\n", "        th = (struct tcphdr *) trans_data;\n", "        if ((void *) (th + 1) > data_end)\n", "            return -1;\n", "        return th->source;\n", "    case IPPROTO_UDP :\n", "        uh = (struct udphdr *) trans_data;\n", "        if ((void *) (uh + 1) > data_end)\n", "            return -1;\n", "        return uh->source;\n", "    default :\n", "        return 0;\n", "    }\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}, {"description": "This function extracts and returns the source port of the TCP and UDP packets. Returns -1 if the packet is invalid. Returns 0 if the packet is neither TCP nor UDP.", "author": "R V B R N Aaseesh", "authorEmail": "aaseesh.rallapalli@gmail.com", "date": "2023-04-04"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 0}, "21": {"capabilities": [], "helperCallParams": {}, "startLine": 213, "endLine": 233, "File": "/home/palani/github/ebpf-projects-annotations/projects/suricata-master/original_source/ebpf/xdp_filter.c", "funcName": "get_dport", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["void *trans_data", " void *data_end", " __u8 protocol"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["xdp", "raw_tracepoint", "cgroup_sysctl", "cgroup_sock_addr", "cgroup_sock", "socket_filter", "lwt_xmit", "sk_skb", "tracepoint", "sched_act", "cgroup_skb", "sched_cls", "sk_msg", "raw_tracepoint_writable", "perf_event", "sk_reuseport", "lwt_out", "cgroup_device", "flow_dissector", "sock_ops", "kprobe", "lwt_seg6local", "lwt_in"], "source": ["static __always_inline int get_dport (void *trans_data, void *data_end, __u8 protocol)\n", "{\n", "    struct tcphdr *th;\n", "    struct udphdr *uh;\n", "    switch (protocol) {\n", "    case IPPROTO_TCP :\n", "        th = (struct tcphdr *) trans_data;\n", "        if ((void *) (th + 1) > data_end)\n", "            return -1;\n", "        return th->dest;\n", "    case IPPROTO_UDP :\n", "        uh = (struct udphdr *) trans_data;\n", "        if ((void *) (uh + 1) > data_end)\n", "            return -1;\n", "        return uh->dest;\n", "    default :\n", "        return 0;\n", "    }\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}, {"description": "This function extracts and returns the destination port of the TCP and UDP packets. Returns -1 if the packet is invalid. Returns 0 if the packet is neither TCP nor UDP.", "author": "R V B R N Aaseesh", "authorEmail": "aaseesh.rallapalli@gmail.com", "date": "2023-04-04"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 0}, "22": {"capabilities": [{"capability": "pkt_stop_processing_drop_packet", "pkt_stop_processing_drop_packet": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_DROP", "Return": 1, "Description": "will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_stop_processing_drop_packet"]}]}, {"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}, {"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_PASS", "Return": 2, "Description": "The XDP_PASS return code means that the packet is allowed to be passed up to the kernel\u2019s networking stack. Meaning, the current CPU that was processing this packet now allocates a skb, populates it, and passes it onwards into the GRO engine. This would be equivalent to the default packet handling behavior without XDP.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 485, "endLine": 552, "File": "/home/palani/github/ebpf-projects-annotations/projects/suricata-master/original_source/ebpf/xdp_filter.c", "funcName": "xdp_hashfilter", "developer_inline_comments": [], "updateMaps": [], "readMaps": ["  global_bypass", "  tx_peer_int"], "input": ["struct xdp_md *ctx"], "output": "\\xdp\\)", "helper": ["bpf_redirect_map", "bpf_redirect", "XDP_DROP", "bpf_map_lookup_elem", "XDP_PASS"], "compatibleHookpoints": ["xdp"], "source": ["int SEC (\"xdp\") xdp_hashfilter (struct xdp_md *ctx)\n", "{\n", "    void *data_end = (void *) (long) ctx->data_end;\n", "    void *data = (void *) (long) ctx->data;\n", "    struct ethhdr *eth = data;\n", "    __u16 h_proto;\n", "    __u64 nh_off;\n", "    __u16 vlan0 = 0;\n", "    __u16 vlan1 = 0;\n", "\n", "#if USE_GLOBAL_BYPASS\n", "    int *iface_peer;\n", "    char *g_switch = 0;\n", "    char key0;\n", "    int tx_port = 0;\n", "    g_switch = bpf_map_lookup_elem (& global_bypass, & key0);\n", "    if (g_switch && *g_switch) {\n", "        iface_peer = bpf_map_lookup_elem (& tx_peer_int, & key0);\n", "        if (!iface_peer) {\n", "            return XDP_DROP;\n", "        }\n", "        else {\n", "            return bpf_redirect_map (&tx_peer, tx_port, 0);\n", "        }\n", "    }\n", "\n", "#endif\n", "    nh_off = sizeof (*eth);\n", "    if (data + nh_off > data_end)\n", "        return XDP_PASS;\n", "    h_proto = eth->h_proto;\n", "    if (h_proto == __constant_htons (ETH_P_8021Q) || h_proto == __constant_htons (ETH_P_8021AD)) {\n", "        struct vlan_hdr *vhdr;\n", "        vhdr = data + nh_off;\n", "        nh_off += sizeof (struct vlan_hdr);\n", "        if (data + nh_off > data_end)\n", "            return XDP_PASS;\n", "        h_proto = vhdr->h_vlan_encapsulated_proto;\n", "\n", "#if VLAN_TRACKING\n", "        vlan0 = vhdr->h_vlan_TCI & 0x0fff;\n", "\n", "#else\n", "        vlan0 = 0;\n", "\n", "#endif\n", "    }\n", "    if (h_proto == __constant_htons (ETH_P_8021Q) || h_proto == __constant_htons (ETH_P_8021AD)) {\n", "        struct vlan_hdr *vhdr;\n", "        vhdr = data + nh_off;\n", "        nh_off += sizeof (struct vlan_hdr);\n", "        if (data + nh_off > data_end)\n", "            return XDP_PASS;\n", "        h_proto = vhdr->h_vlan_encapsulated_proto;\n", "\n", "#if VLAN_TRACKING\n", "        vlan1 = vhdr->h_vlan_TCI & 0x0fff;\n", "\n", "#else\n", "        vlan1 = 0;\n", "\n", "#endif\n", "    }\n", "    if (h_proto == __constant_htons (ETH_P_IP))\n", "        return filter_ipv4 (ctx, data, nh_off, data_end, vlan0, vlan1);\n", "    else if (h_proto == __constant_htons (ETH_P_IPV6))\n", "        return filter_ipv6 (ctx, data, nh_off, data_end, vlan0, vlan1);\n", "    return XDP_PASS;\n", "}\n"], "called_function_list": ["filter_ipv6", "filter_ipv4"], "call_depth": 2, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}, {"description": "This hash function filter, filters the Ethernet packets based on the IP packet version. If GLOBAL_BYPASS flag is set, then the key0 is initialized to 0 and is checked in the global_bypass map. If the key exists, the same key0 is checked in tx_peer_int map. If the key doesn't exist, the packet is dropped. Othereise, the tx_port is written into the tx_peer map. If GLOBAL_BYPASS is not set, the fields vlan0 is set to the last 12 bits of the VLAN TCI field and vlan1 is set to 0 if the VLAN_TRACKING is off else it is set to the last 12 bits of the VLAN TCI field(since vlan0 is stripped by the OS). Based on the version of IP packets, the function filter_ipv4 or filter_ipv6 is invoked accordingly. If it is neither of them -1 is returned.", "author": "R V B R N Aaseesh", "authorEmail": "aaseesh.rallapalli@gmail.com", "date": "2023-04-05"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 1}, "23": {"capabilities": [], "helperCallParams": {}, "startLine": 9, "endLine": 55, "File": "/home/palani/github/ebpf-projects-annotations/projects/suricata-master/original_source/ebpf/hash_func01.h", "funcName": "SuperFastHash", "developer_inline_comments": [{"start_line": 1, "end_line": 5, "text": "/* SPDX-License-Identifier: LGPL-2.1\n *\n * Based on Paul Hsieh's (LGPG 2.1) hash function\n * From: http://www.azillionmonkeys.com/qed/hash.html\n */"}, {"start_line": 20, "end_line": 20, "text": "/* Main loop */"}, {"start_line": 30, "end_line": 30, "text": "/* Handle end cases */"}, {"start_line": 46, "end_line": 46, "text": "/* Force \"avalanching\" of final 127 bits */"}], "updateMaps": [], "readMaps": [], "input": ["const char *data", " int len", " __u32 initval"], "output": "static__always_inline__u32", "helper": [], "compatibleHookpoints": ["xdp", "raw_tracepoint", "cgroup_sysctl", "cgroup_sock_addr", "cgroup_sock", "socket_filter", "lwt_xmit", "sk_skb", "tracepoint", "sched_act", "cgroup_skb", "sched_cls", "sk_msg", "raw_tracepoint_writable", "perf_event", "sk_reuseport", "lwt_out", "cgroup_device", "flow_dissector", "sock_ops", "kprobe", "lwt_seg6local", "lwt_in"], "source": ["static __always_inline __u32 SuperFastHash (const char *data, int len, __u32 initval)\n", "{\n", "    __u32 hash = initval;\n", "    __u32 tmp;\n", "    int rem;\n", "    if (len <= 0 || data == NULL)\n", "        return 0;\n", "    rem = len & 3;\n", "    len >>= 2;\n", "\n", "#pragma clang loop unroll(full)\n", "    for (; len > 0; len--) {\n", "        hash += get16bits (data);\n", "        tmp = (get16bits (data + 2) << 11) ^ hash;\n", "        hash = (hash << 16) ^ tmp;\n", "        data += 2 * sizeof (__u16);\n", "        hash += hash >> 11;\n", "    }\n", "    switch (rem) {\n", "    case 3 :\n", "        hash += get16bits (data);\n", "        hash ^= hash << 16;\n", "        hash ^= ((signed char) data[sizeof (__u16)]) << 18;\n", "        hash += hash >> 11;\n", "        break;\n", "    case 2 :\n", "        hash += get16bits (data);\n", "        hash ^= hash << 11;\n", "        hash += hash >> 17;\n", "        break;\n", "    case 1 :\n", "        hash += (signed char) *data;\n", "        hash ^= hash << 10;\n", "        hash += hash >> 1;\n", "    }\n", "    hash ^= hash << 3;\n", "    hash += hash >> 5;\n", "    hash ^= hash << 4;\n", "    hash += hash >> 17;\n", "    hash ^= hash << 25;\n", "    hash += hash >> 6;\n", "    return hash;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}, {"description": "This function is the implementation of the SuperFastHash algorithm by Paul Hsieh of MIT. This function returns the hash of length len, for the input data based on the random state initval.", "author": "R V B R N Aaseesh", "authorEmail": "aaseesh.rallapalli@gmail.com", "date": "2023-04-05"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}], "is_root_fn": 0}}}